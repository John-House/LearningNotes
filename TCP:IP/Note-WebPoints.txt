计算机或通信系统
===============================================
	1) 通信模型
		1.1) 七层模型
			即OSI模型(开放系统互联参考模型,由国际标准化组织(ISO)制定的一个用于计算机或通信系统间互联的标准体系),由下至上依次为:
			物理层 > 链路层 > 网络层 > 传输层 > 会话层 > 表示层 > 应用层
	
		1.2) 四层模型
			即TCP/IP模型,由下至上依次为:
			链路层 > 网络层 > 传输层 > 应用层
		
	2) IP地址
		2.1) 地址分类
			每个IPv4地址,都由'网络号'和'主机号'两部分组成(共32位,即4个字节): 网络号用于标识网段,主机号用于标识某个网段下的唯一主机；
			根据'网络号'和'主机号'的长度不同可以分为: A~E类地址:
				TYPE	CONSTRUCT			EXPLAIN								RANGE
				A 		8_inet  + 24_host	8位的网络号(第1位为0)和24位的主机号		 0.0.0.0   ~ 127.255.255.255			
				B		16_inet + 16_host	16位的网络号(前2位为10)和16位的主机号	 128.0.0.0 ~ 191.255.255.255
				C 		24_inet + 8_host 	24位的网络号(前3位为110)和8位的主机号	 192.0.0.0 ~ 223.255.255.255
				D 		32					32位的组播地址(前4位为1110)			   224.0.0.0 ~ 239.255.255.255
				E 		32 					32位的保留地址(前4位为1111)			   240.0.0.0 ~ 255.255.255.255
			
			A~C类地址中都保留了部分地址作为'私有IP地址'(这些地址不直接入网,它们必须借助NAT进行公/私IP地址转换后才能接入公网),参见:
				TYPE	RANGE-PRIVATE
				A		10.0.0.0    ~ 10.255.255.255
				B		172.16.0.0  ~ 172.31.255.255
				C 		192.168.0.0 ~ 192.168.255.0
			
			为了方便分配/管理同一网段下的主机,将B类地址'主机号'进一步拆分为'子网ID'和'主机ID'两部分(即子网寻址),例如:
				TYPE	CONSTRUCT						EXPLAIN
				B		16_inet + (8_subinet + 8_host)	16位的网络号和8位的子网ID和8位的主机ID
			
		2.2) 子网掩码
			为了方便确定某一网段,引入'子网掩码'(即IP子网掩码)的概念,其特点有:
				* 子网掩码与IP地址的长度一致(即IPv4的子网掩码为32位,IPv6的子网掩码为128位)
				* 子网掩码可以通过静态方式配置(例如:路由器),也可以通过动态方式配置(例如: DHCP协议,即动态主机配置协议)
				* 子网掩码需要配合IP地址使用才能确定网段,即将二者的每一位都按位与后的结果就是网段
				* 子网掩码的缩写(例如: /1 /8 /10),数字表示子网掩码中'前缀1'的个数,即 128.0.0.0 -> 10000000 0000000 00000000 0000000 -> /1 

	3) DNS协议
		3.1) 基本概念
			* IP地址被用于识别网络中的唯一主机但记忆它并不不易,因此使用映射至对应IP地址的'主机名'成为通行的做法,即'域名系统'；
			  然而,本质上协议使用的还是IP地址,因此在使用时需要将'主机名'解析成'IP地址',这一过程称为'名称解析'；
			* 域名系统,是一个分布式数据库系统(位于多个'名称服务器'上),它可以通过一台主机的'地址解析器'程序访问；
			  多个'辅名称服务器'会通过自己的'区域传输进程'从'主名称服务器'上拷贝这些数据的副本,而这也是DNS协议的一部分；
			  '名称服务器'会缓存这些数据来响应解析请求,缓存有效期为TTL；另一方面,客户端(即发送请求的主机)也可以缓存这些数据,
			  	例如: Linux系统就使用'名称服务缓存进程'来实现这一功能(见/etc/nscd.conf文件)；
			* 对于一次'名称解析'的请求,通常主机会请求'(本地)名称服务器',若它无法解析则会将请求转发至其他的名称服务器(例如ISP提供的名称服务器),这一行为成为'递归'；
			  若其他的名称服务器仍不知道,则会转发至根名称服务器(根名称服务器不会递归,而是直接返回能够解析的名称服务器地址)；
			* 全世界所有的域名构成了一个域名树(即'DNS名称空间')；位于树的最高层的是'顶级域名'(即TLD),包括:
			  '通用顶级域名-gTLD'、'国家代码顶级域名-ccTLD'、'国际化国家顶级域名-IDN ccTLD'和'基础设施顶级域名-infrastructure TLD')；
			* 域名是大小写不敏感的；从右往右分层设计的,使用'.'来分隔子域名(点与点之间的部分称为'标签',每个标签最长63个字符)；
			* 在解析时,会被转换成'完全限定域名'(即FQDN,最长255个字符,特点是域名以'.'结尾,例如: mit.edu.)；
			  如果一个域名是'非限定域名',它在被解析时可能会被添加其他信息,例如: 对于域名nonmit.edu,浏览器输入vangogh在被解析时会转换成'vangogh.nonmit.edu.'；
		
		3.2) DNS协议
			DNS协议,包括两个主要部分: a)用于对'域名系统'中指定名称的查询及响应的协议, b)用于对名称服务器之间数据交换(即区域传输)的协议； 基于UDP协议,使用端口53
			











	4) ARP协议
		4.1) 基本概念
			* ARP(即地址解析),是一个发现'IPv4地址'及其'Mac地址'之间'动态映射'关系的过程:
				a. 映射关系的双方是'32位的IPv4地址'和'48位的Mac地址',不涉及IPv6地址是因为它和'Mac地址'的映射关系由ICMPv6(即邻居发现协议)决定；
				b. 映射关系可能发生变化,但关系的更新是系统自适应的；
				c. APR通过'链路层广播'获取映射关系,即'如果你(主机)的IP地址是xxxx,则返回你(主机)的Mac地址'；
			* 仅靠IP地址(而没有物理地址)无法在两台主机之间传输数据,所以制定了位于网络层的ARP协议(即地址解析协议)；
			* ARP的映射关系由主机(或路由器)上的'ARP缓存'维护,在操作系统的shell中键入'arp -a'命令即可查看；
		
		4.2) ARP帧格式
			----------------------------------------------------------------------------------------------------------------------------------
			| dst_mac src_mac len_or_type | hard_type proto_type hard_size proto_size Op | src_mac src_ipv4 dst_mac dst_ipv4 |  FILL |  FCS  |
			|			Part 1			  |						Part 2					 |				Part 3				 | Part4 | Part5 |	
			----------------------------------------------------------------------------------------------------------------------------------
				* Part 1: 标准的Mac头部(14字节),包括'目的Mac地址'(6字节)、'源Mac地址'(6字节)和'长度类型'(2字节)等字段；
						  严格来说,这部分是由链路层添加的数据,不属于ARP协议的数据内容；
				* Part 2: ARP请求/应答的固定信息(8字节),包括:
							hard_type		->  硬件地址的类型(2字节),对于以太网为1
							proto_type		->  协议地址的类型(2字节),对于Ipv4为0x0800
							hard_size		->  硬件地址的字节数(1字节)
							proto_size		->  协议地址的字节数(1字节)
							Op				->  ARP帧的类型(ARP请求为1,ARP应答为2,RARP请求为3,RARP应答为4)
				* Part 3: ARP请求/应答的可变信息(n字节,IPv4与以太网之间为20字节),包括:
							src_mac			->  源Mac地址(6字节)
							src_ipv4		->  源协议地址(4字节)
							dst_mac			->  目的Mac地址(6字节),若是ARP请求帧,则为0(因为此时并不知道)
							dst_ipv4		->  目的协议地址(4字节)
				* Part 4: 填充内容(18字节)
				* Part 5: FCS(4字节)

	5) TCP协议
		5.1) 基本概念
			在数据传输领域,中间媒介可能丢失或改变被传输的数据内容,因此'差错纠正'成为一大关注点,其解决思路有(而TCP协议采用了b方案):
				a. 使用'差错纠正码'(大部分的原理是加入冗余信息,降低丢失关键数据的可能性)
				b. 重复发送(即自动重复请求[ARQ, Automatic Repeat Request],保证信息被最终接收)

			TCP协议(即传输控制协议),是'面向连接的'、'可靠的'、'字节流'服务,具有'差错纠正'、'队列管理'、'重复消除'、'流量控制'和'拥塞控制'等特点:
				a. 面向连接,即依托TCP协议传输数据,需要(数据)发送方和(数据)接收方事先建立连接；
				   * 这一过程涉及'两个端点'(或者说'两个套接字对象'),而每个端点(或者说每个套接字对象)都由'IP地址和端口号'这对数据唯一标识；
				   * 这一过程是'全双工'的,所以衍生出了'半连接'的概念；
				b. 字节流,即TCP协议不关心传输的数据类型,也没有'记录标志'或'消息边界'来界定区段范围；
				   * TCP协议从上层接收数据,然后封装成'报文段'传递给下层；
				c. 可靠的,即TCP协议将待传输的字节流划分为一个个的'组包',每个组包都具有'序列号'这一特性,以便发送方重新组包或接收方准确聚合数据；
				   * 序列号(不同于组号/编号等常规概念),是指所在组包的首个字节在整个字节流中的偏移量,因此序列号的参考系是固定的；
				   * 采用组包的形式,意味着在一个字节流中,接收方面对无序数据包的到来,若后面的数据先到必定会等到前面的数据全部到齐后再一并传给上层应用；
				   同时,TCP协议维持数据的校验,任何无效的组包都会被接收方丢弃；
				   此外,TCP协议的发送方维护着'重传计时器',当未收到接收方的确认时,会重新发送数据；
			
			滑动窗口协议
				对于组包形式的数据传输,TCP协议的连接双方各自定义了一个'分组窗口'(即己方已发送但未收到对方确认的组包集合,集合的个数也被称作'窗口大小'),
				同时衍生了'己方已发送且收到对方确认的组包集合'和'己方未发送的组包集合'这两个概念；
				当己方收到某个'分组窗口'中的组包被确认的消息时,这个'分组窗口'应当向下一个组包的方向滑动(此时窗口大小可能发生变化),这种行为就被称作'滑动窗口协议'；
			
			流量控制和拥塞控制
				流量控制,即解决'发送方数据传输过快,接收方强迫发送方降速问题'的措施,常见的有: 速率控制(即限制发送方传输数据的速率)和窗口控制(即动态更新发送方的分组窗口大小)； 
				拥塞控制,即解决'发送方数据传输过快,中间网络处理不及时导致丢包问题'的措施；

		5.2) TCP报文段格式
			--------------------------------------------------------------------------------------------------------------
			| IP_add | src_port dst_port Seq Ack head_len preserve Flags window_size checksum urg_point options |  data  |
			| Part 1 |						                      Part 2 																									| Part 3 |	
			--------------------------------------------------------------------------------------------------------------
				* Part 1: IP头部协议,严格来说这部分是由网络层添加的数据,不属于TCP协议的数据内容；
				* Part 2: TCP协议的头部(至少20字节,若附带options[最大段大小、时间戳、窗口缩放和选择性ACK等信息]可达60字节)
						  src_port		->  (16位)发送方端口号
						  dst_port		->  (16位)接收方端口号
						  Seq 				->  (32位)报文段的序列号(范围0 ~ 2**32-1,超过后归零再循环)；对于'初始序列号'(即ISN),出于安全考虑通常选择一个随机数字
						  Ack 				->  (32位)报文段的确认号,即该报文段的发送方期待接收的下一个序列号(也是该报文段的发送方最后成功接收的组包序列号+1)
						  head_len 		->  (4位)报文段头部的长度(以32位为单位)
						  preserve		->  (4位)报文段的保留位
						  Flags				->  (8位)报文段的标志位(共8个):
						  		CWR			->  (1位)告诉接收方发送方降低了速率(拥塞控制)
									ECE 		->  (1位)告诉接收方发送方收到了更早的拥塞通告
									URG 		->  (1位)紧急指针
									ACK 		->  (1位)告诉接收方该报文段确认号信息有效
															ACK是累积的,即发送方收到对应字节号N的ACK时,可以确定接收方一定收到了前N-1个字节(不包括N)的所有数据；
									PSH 		->  (1位)告诉接收方应尽快将该报文段传递给上层应用
									RST 		->  (1位)告诉接收方连接因错误而取消
									SYN 		->  (1位)告诉接收方发送方正在发生一个连接
									FIN 		->  (1位)告诉接收方发送方已关闭连接(不再向接收方发送数据)
						  window_size	->  (16位)分组窗口的大小(注意: 这里是按'字节数'计算而不是'组包个数',流量控制)
						  checksum		->  (16位)报文段的校验和(其算法与IP协议、ICMP协议、UDP协议一样)
						  urg_point		->  (16位)一个正偏移量(当且仅当URG标志位为1时生效),将'报文段的序列号 + 正偏移量'就能得到紧急数据的最后一个字节的偏移量(或者说序列号)
						  options			->  (n位)报文段的可选项,最常见的是'最大段大小'
				* Part 3: data,即报文段传输的实际数据
			
		5.3) TCP协议的连接和关闭
			三次握手(即新连接的建立)
				第一次握手 ->  客户端发送一个'SYN'报文段,表示希望与服务器建立连接；
				第二次握手 ->  服务器收到后返回一个'SYN+ACK'报文段,表示已收到客户端发送的关于建立连接的请求,同时也希望与客户端建立连接；
				第三次握手 ->  客户端收到后返回一个'ACK'报文段,表示已收到服务端发送的关于建立连接的请求；
				至此,客户端和服务器之间的双向连接建立,可以进行后续的通信；

			四次挥手(即连接的关闭)
				第一次挥手 ->  客户端发送一个'FIN+ACK'报文段,表示已收到服务器最近发送的数据,同时希望关闭'客户端->服务器'的连接；
				第二次挥手 ->  服务器收到后返回一个'ACK'报文段,表示已收到客户端发送的关于关闭连接的请求；
				第三次挥手 ->  服务器发送一个'FIN'报文段,表示希望关闭'服务器->客户端'的连接；
				第四次挥手 ->  客户端收到后返回一个'ACK'报文段,表示已收到服务器发送的关于关闭连接的请求；
				至此,客户端和服务器之间的双向连接关闭；

			状态变更(即客户端和服务器在一个连接周期内的状态变化)
				Client Init									—>	CLOSED			|						|	CLOSED			<- 	Server Init
																										|						|	LISTEN    	<- 	Server Listen Port, then
				Client Send SYN, then 			-> 	SYN_SENT		|						|	
																										|						|	SYS_RCVD		<- 	Server Send ACK + SYN, then 
																										|						|
				Client Send ACK, then 			-> 	ESTABLISHED	|						|
																										|						|	ESTABLISHED	<- 	Server Recv ACK
																										|~~~~~~~~~~~|
																										|~~~~~~~~~~~|
				Client Send FIN + ACK, then	-> 	FIN_WAIT1		|						|
																										|						|	CLOSE_WAIT	<- 	Server Send ACK 
				Client Recv FIN, then				-> 	FIN_WAIT2		|						|	LAST_ACK		<- 	Server Send FIN, then
				Client Send ACK, then 			-> 	TIME_WAIT		|						|	
																										|						|	CLOSED			<- 	Server Recv ACK
				Client Wait 2MSL, then 			->	CLOSED			|						|
				
				* CLOSED: 即客户端或服务器的初始状态(这不是官方定义的状态之一,只是描述性的词语,如果愿意随便叫什么都行)；
				* 2MSL: 即加倍等待时间；MSL(Maximum Segment Lifetime)是最大段生存期,表示任何报文段被丢弃前在网络中存在的最长时间；
								TCP报文段是以IP数据报的形式传输的,所以MSL由IP协议的TTL字段(对应IPv4)或跳数限制字段(对应IPv6)决定,标准规定是2min(通常设为30s、1min或2min)；
								该设定是考虑到客户端最后发送的ACK可能无法被服务器接收,因此至少需要等待1MSL(ACK报文段抵达服务器所需的最长时间),
								额外等待1MSL(若服务器未收到ACK,重传FIN报文段后抵达客户端所需的最长时间)；
				* TIME_WAIT: 即客户端关闭前的最后一个状态；在该状态下,客户端若接收到RST等其他类型的报文段会打破当前状态提前进入CLOSED状态,这种情况称为'时间等待错误'；
							 			 为避免该情况,通常客户端在TIME_WAIT状态下不会接受乱七八糟的报文段,而是安心等待2MSL时间过去；

	6) UDP协议 
		6.1) 基本概念

	



HTTP/1.0和HTTP/1.1协议
===============================================
	1) 请求格式
		method uri version\r\n				->  请求行(共3部分),以'空格'分隔、'回车换行符'结尾
		header1:value1\r\n						->  请求头(共n部分),每个'头:值'对都以'回车换行符'结尾
		...
		\r\n 													->  回车换行符标(共1部分),标志着请求头的结束、请求体的开始
		body_content									->  请求体(共n部分),保存着请求额外携带的数据
		[1] method	即请求方法,HTTP/1.1协议中规定了8种: 
					GET											->  向服务器请求指定资源(该操作应该仅用于读取服务器的数据)
					HEAD 										->  向服务器请求指定资源(同GET,但服务器仅返回资源的元数据而非本体)
					POST										->  向指定资源提交数据并请服务器处理(非幂等的请求方法,该操作可能新建和/或修改指定资源,待提交的数据保存在请求体中)
					PUT											->  向指定资源提交最新的数据(幂等的请求方法)
					DELETE									->  请求服务器删除指定资源
					TRACE										->  回显服务器收到的请求(该操作多用于测试或诊断)
					OPTIONS									->  向服务器请求指定资源支持的所有请求方法
					CONNECT									->  预留的请求方法(该操作多用于SSL连接)
					[1.1] 请求方法是'区分大小写'的；
					[1.2] 服务器不支持或不认识请求方法时,返回501(Not Implemented)错误；
					[1.3] 指定资源不支持请求方法时,返回405(Method Not Allowed)错误；
		[2] uri		即统一资源标识符(用于标识唯一的网络资源),它分为url(统一资源定位符)和urn(统一资源名称)；广义上已不再区分uri和url,而是统一改用uri；
					其格式为'scheme://hostname.domain:port/multilevel_Path?arg=val&arg=val...#anchor'
					[2.1] scheme:						->  协议名,例如: http、https、file、ftp等等
					[2.2] //								->  协议分隔符
					[2.3] hostname					->  主机名,例如: www
					[2.4] domain						->  域名(可以是多级域名),例如: baidu.com
					[2.5] :port 						->  端口名(若是标准端口,则可以省略),例如: :80
					[2.6] /multilevel_Path	->  资源的绝对路径
					[2.7] ?									->  参数分隔符
					[2.8] arg								->  参数名
					[2.9] val 							->  参数值
					[2.a] &									->  参数连接符
					[2.b] # 								->  片段分隔符
					[2.c] anchor						->  锚点名
		[3] version	即HTTP协议的版本,可以是: HTTP/1.0、HTTP/1.1和HTTP/2
		[4] header	即请求头,可以是:
					Host					->  声明请求的服务器名(若是标准端口,则可以省略端口号),
												例如 Host: en.wikipedia.org
					Content-Length			->  声明请求体的字节数,
												例如 Content-Length: 348
					Content-Type			->  声明请求体的MIME类型,
												例如 Content-Type: application/x-www-form-urlencoded
					Pragma					->  声明缓存机制(HTTP/1.0的请求头,不考虑兼容性的话可以弃用)；
												它的取值仅限no-cache(即禁用缓存),但对缓存控制的效力是最高的；
					Cache-Control			->  声明缓存机制(HTTP/1.1的请求头,用于设置缓存有效期),它对缓存控制的效力折中
												例如 Cache-Control: max-age=3600
												它的取值可以是一个或多个(自由组合),位于请求头时可以是:
													no-store			-> 禁用缓存
													no-cache 			-> 不使用缓存,直接向(原)服务器发起请求
													max-age=secs		-> 告知服务器,客户端希望收到缓存有效期为secs秒的响应
													no-transform		-> 告知服务器,客户端希望收到未变换内容的响应
					Accept					->  设置客户端能接收的响应类型,
												例如 Accept: text/plain, application/xhtml+xml
					Accept-Encoding			->  设置客户端能接收的编码方式,
												例如 Accept-Encoding: gzip, deflate
					Accept-Language			->  设置客户端能接收的自然语言(若能接收多种语言,则可以分配权重),
												例如 Accept-Language: en-US;q=0.8
					Referer					->  声明发送请求的URI(即请求来源),
												例如 Referer: http://en.wikipedia.org/wiki/Main_Page
					User-Agent				->  声明标识浏览器身份的字符串,
												例如 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0
					Cookie					->  服务器通过Set-Cookie响应头返回的内容,
												例如 Cookie: $Version=1; Skin=new;
					If-Modified-Since		->  声明之前获知的资源的最后修改时间(多用于缓存验证)
												例如 If-Modified-Since: "737060cd8c284d8af7ad3082f209582d"
												若服务器资源当前的最后修改时间与该请求头的值一致,则服务器会返回304；
												若服务器资源当前的最后修改时间与该请求头的值不一致,则服务器会返回200和新的资源；
					If-None-Match			->  声明之前获知的Etag的值(多用于缓存验证)
												例如 If-None-Match: "737060cd8c284d8af7ad3082f209582d"
												若服务器资源当前的Etag值与该请求头的值一致,则服务器会返回304；
												若服务器资源当前的Etag值与该请求头的值不一致,则服务器会返回200和新的资源；
					If-Range				->  声明之前获知的Etag的值
												例如 If-Range: "737060cd8c284d8af7ad3082f209582d"
												若服务器资源当前的Etag值与该请求头的值一致,则服务器返回客户端缺失的部分；
												若服务器资源当前的Etag值与该请求头的值不一致,则服务器返回新的资源；
					Range					->  声明仅请求资源的一部分(按字节偏移量计算,从0计起),
												例如 Range: bytes=500-599
					X-Csrf-Token			->  声明CSRFtoken(多用于防止跨站请求伪造)
												例如 x-csrf-token: i8XNjC4b8KVok4uw5RftR38Wgp2BFwql
					Accept-Charset			->  设置客户端能接收的字符集,
												例如 Accept-Charset: utf-8
					Accept-Datetime			->  设置客户端能接收的时间表示版本,
												例如 Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT
					Date					->  声明请求发送时的日期和时间,
												例如 Date: Tue, 15 Nov 1994 08:12:31 GMT
					Authorization			->  设置超文本传输协议的认证信息,
												例如 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==
					Connection				->  设置客户端优先使用的连接类型,
												HTTP/1.0实现'长连接',需要显示声明Connection: keep-alive,
												HTTP/1.1默认是'长连接'类型,除非显示声明Connection: close,
												例如 Connection: keep-alive
					From					->  声明发送请求的用户邮件地址,
												例如 From: user@example.com
					Origin					->  声明发送的是跨域请求(该声明要求服务器的响应头包含'Access-Control-Allow-Origin'),
												例如 Origin: http://www.example-social-network.com
					Upgrade					->  要求服务器升级到其他协议,
												例如 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
					Via						->  声明请求是由哪些代理发送的,
												例如 Via: 1.0 fred, 1.1 example.com (Apache/1.1)
					X-Requested-With		->  声明发送的是一个Ajax及可扩展标记语言的请求,
												例如 X-Requested-With: XMLHttpRequest
					X-Forwarded-For			->  声明请求到达服务器之前沿途的客户端或代理服务器的IP地址,
												例如 X-Forwarded-For: 129.78.138.66, 129.78.64.103
					X-Forwarded-Host		->  声明最初的请求中Host请求头的值,因为代理服务器通常会修改它,
												例如 X-Forwarded-Host: en.wikipedia.org
					X-Forwarded-Proto		->  声明最初的请求所使用的HTTP协议,因为代理服务器通常会修改它,
												例如 X-Forwarded-Proto: https

	2) 响应格式
		version code state\r\n 				->  响应行(共3部分),以'空格'分隔、'回车换行符'结尾
		header1:value1\r\n					->  响应头(共n部分),每个'头:值'对都以'回车换行符'结尾
		...
		\r\n 								->  回车换行符标(共1部分),标志着响应头的结束、响应体的开始
		body_content						->  响应体(共n部分),响应的所有数据				

		[1] version	即HTTP协议的版本,可以是: HTTP/1.0、HTTP/1.1和HTTP/2
		[2] code	即状态码(3位数字),可以是:
					100		告诉客户端之前的请求已收到,请继续发送请求(该响应是'临时响应')；
					101		告诉客户端之前的请求已了解,且服务器在返回该响应后会切换到Upgrade响应头中的协议；
					
					200		告诉客户端之前的请求已收到,且服务器已正常返回请求的资源；
					201		告诉客户端之前的请求已完成,且服务器希望客户端请求新的资源(资源的URI见该响应的Location响应头)；
					202		告诉客户端之前的请求已收到,但尚未处理(最后的结果可能拒绝,也可能处理),多用于避免客户端因得不到响应而阻塞,例如异步场景；
					204		告诉客户端之前的请求已处理,但服务器返回的响应中仅包含'最新的响应头'而没有响应体,且客户端'无需重置'之前的请求页面；
					205 	告诉客户端之前的请求已处理,但服务器返回的响应中仅包含'最新的响应头'而没有响应体,且客户端'必须重置'之前的请求页面,
							多用于表单提交后刷新页面以便用户新一次的输入；
					
					301		告诉客户端之前的请求已收到,但请求的资源已'永久迁移'到新的位置(资源的新URI见该响应的Location响应头)；
					302		告诉客户端之前的请求已收到,但请求的资源已'临时迁移'到新的位置(资源的新URI见该响应的Location响应头)；
					305		告诉客户端之前的请求已收到,但客户端需要再发送一个请求,因为请求的资源只能通过特定的代理服务器访问(代理服务器的URI见该响应的Location响应头)；

					400		告诉客户端之前的请求无法被服务器理解或者之前的请求参数有错误；
					401		告诉客户端之前的请求需要验证用户信息；
					403		告诉客户端之前的请求已被拒绝(应当在该响应中解释被拒绝的原因,否则应当返回404)；
					404		告诉客户端之前的请求的资源无法被服务器找到,且无法告知这种情况是临时的还是永久的,多用于服务器不想告知客户端请求为何被拒绝,且没有其他更好的状态码可返回时；
					405		告诉客户端被请求的资源不支持之前请求的请求方法,且服务器会返回资源支持的所有请求方法(见该响应的Allow响应头)；
					406		告诉客户端被请求的资源MIME类型与之前请求的MIME类型不匹配,且服务器会返回资源的MIME类型(见该响应的Content-Type响应头)；
					407 	告诉客户端之前的请求需要经'代理服务器'验证用户信息；
					408		告诉客户端之前的请求已超时,即客户端没有再服务器的配置时间内完成请求的发送,客户端可以随时再发送这一请求而无需进行更改；
					410		告诉客户端之前的请求的资源已永久不可用；
					411		告诉客户端之前的请求已被拒绝,因为没有Content-Length请求头；

					500		告诉客户端当前服务器出现了意想不到的情况,无法处理之前的请求；
					501		告诉客户端当前服务器不支持之前请求的某个功能；
					502		告诉客户端当前服务器扮演网关或代理服务器的角色,无法从上游服务器获取有效的响应；
					503		告诉客户端当前服务器正在临时维护或已过载,无法处理之前的请求(应当在响应中添加Retry-After响应头来声明临时处理的时间,否则应当返回500)；
					504		告诉客户端当前服务器无法及时从上游服务器(或DNS服务器)获取有效的响应；
					505		告诉客户端当前服务器不支持或拒绝支持之前的请求的HTTP协议版本；
					509		告诉客户端当前服务器达到了带宽限制(非正式状态码,但约定俗成)；
		[3] state	即状态码说明(状态码的简要说明,参见[2] code)
		[4] header 	即响应头,可以是:
					Strict-Transport-Security

					Allow 					->  声明资源支持的请求方法,
												当被请求的资源不支持该请求的请求方法时,必须在响应中声明Allow响应头来告知客户端被请求的资源支持哪些请求方法,
												例如 Allow: GET, HEAD, POST, PUT, DELETE, TRACE, OPTIONS, PATCH
					Access-Control-Allow-Origin		->  声明跨域请求允许的域名,
														例如 Access-Control-Allow-Origin: *
					Accept-Patch			->  声明服务器支持的文件格式类型,
												例如 Accept-Patch: text/example;charset=utf-8
					Pragma					->  声明缓存机制(HTTP/1.0的响应头,不考虑兼容性的话可以弃用),
												它的取值仅限no-cache(即禁用缓存),但对缓存控制的效力是最高的；
					Cache-Control			->  声明缓存机制(HTTP/1.1的响应头,用于设置缓存有效期),它对缓存控制的效力折中,
												例如 Cache-Control: max-age=3600
												它的取值可以是一个或多个(自由组合),位于响应头时可以是:
													no-store			-> 禁用缓存
													no-cache 			-> 不使用缓存,客户端应向服务器发起缓存验证的请求
													max-age=secs		-> 响应的缓存有效期为secs秒
													no-transform		-> 告知客户端缓存响应时不得变换内容
													private[='fieldname']	-> 仅限指定用户将响应中的全部或fieldname字段内容作为缓存使用
													public				-> 响应必须被缓存
					Expires					->  设置响应的缓存超时(HTTP/1.0的响应头,用于启用缓存并设置缓存有效期),
												例如 Expires: Thu, 01 Dec 1994 16:00:00 GMT
												它的取值是相对于服务器的GMT时间,无法保证客户端和服务器的时间统一；它对缓存控制的效力最低
					Last-Modified			->  声明资源的最后修改时间(多用于缓存验证),
												客户端发起缓存验证的请求时,会将该值作为If-Modified-Since请求头的值发送,
												而服务器会将资源当前的最后修改时间与上述请求头中的值比较后执行不同的操作；
												例如 Last-Modified: Fri 22 Jul 2016 01:47:00 GMT
					ETag					->  声明标识资源版本的字符串,也称'缓存令牌'(多用于缓存验证),
												客户端发起缓存验证的请求时,会将该值作为If-None-Match请求头的值发送,
												而服务器会将资源当前的Etag值与上述请求头中的值比较后执行不同的操作；
												例如 ETag: "737060cd8c284d8af7ad3082f209582d"
					Content-Encoding		->  声明响应使用的编码方式(即内容编码方式),
												例如 Content-Encoding: gzip
					Transfer-Encoding		->  声明安全传输实体所使用的编码方式(即传输编码方式),可选值为: chunked、compress、deflate、gzip、dentity,
												例如 Transfer-Encoding: chunked
					Content-Language		->  声明响应内容的自然语言,
												例如 Content-Language: da
					Content-Length			->  声明响应体的字节数,
												例如 Content-Length: 348
					Content-Type			->  声明响应内容的MIME类型,
												例如 Content-Type: text/html; charset=utf-8
													MIME类型,即多用途互联网邮件扩展(Multipurpose Internet Mail Extensions),它是SMTP协议的扩展协议,
													形如: mainType/subType; charset=coding
														text/plain					->  纯文本
														text/html         			->  HTML文档
														multipart/form-data			->  表单数据(含上传文件)
														application/x-www-form-urlencoded 	->  表单数据
														application/xhtml+xml		->  XHTML文档
														application/octet-stream	->  任意的二进制数据
														application/pdf         	->  PDF文档
														application/msword      	->  Word文档
														message           			->  E-mail消息
														image/gif          			->  GIF图片
														image/jpeg         			->  JPEG图片
														image/PNG         			->  PNG图片
														audio             			->  音频数据
														video/mpeg         			->  MPEG动画
					Date					->  声明发送响应的日期和时间,
												例如 Date: Tue, 15 Nov 1994 08:12:31 GMT
					Location				->  设置响应的重定向,
												例如 Location: http://www.w3.org/pub/WWW/People.html
					Refresh					->  设置响应的定时重定向,
												例如 Refresh: 5; url=http://www.w3.org/pub/WWW/People.html
					Server					->  声明服务器名,
												例如 Server: Apache/2.4.1 (Unix)
					Set-Cookie				->  设置返回客户端的Cookie,
												例如 Set-Cookie: UserID=JohnDoe; Max-Age=3600; Version=1
					Upgrade					->  要求客户端升级到其他协议,
												例如 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11
					Via						->  声明响应是通过什么途径发送的,
												例如 Via: 1.0 fred, 1.1 example.com (Apache/1.1)
					X-Frame-Options			->  声明针对点击劫持(ClickJacking)采取的保护措施,包括:
													deny 			->  禁止响应页面在frame中展示(即使frame位于同一域名内也不行)
													sameorigin		->  允许响应页面在同域名的frame中展示
													allow-from uri	->  允许响应页面在指定URI的frame中展示
													allowall		->  允许响应页面在任何frame中展示
												例如 X-Frame-Options: deny
					X-UA-Compatible			->  声明渲染响应页面的推荐引擎,
												例如 X-UA-Compatible: IE=EmulateIE7
													X-UA-Compatible: IE=edge
													X-UA-Compatible: Chrome=1

HTTP/2协议
===============================================
	1) HTTP/1.1协议的缺点
		* HTTP/1.1协议对同一域名有最大并发连接数的限制(通常为6~8个,具体由浏览器决定),协议这样规定的目的是为了避免服务器过载、减少网络拥堵；
		  为此,开发人员采用'域名分片'(Domain Sharding)技术来突破限制,即将原本部署在一个域上的资源现在部署在多个域(或子域)上,这样就可以同时向多个域发送请求；
		  虽然每个域最大并发连接数的限制没变,但'域名分片'变相增加了总连接数,提升了获取同等资源的速率,然而考虑到HTTP/1.1协议本身的特性,
		  每个连接都需要经历DNS解析、三次握手、建立TLS等阶段,因此增加总连接数也会带来额外的开销；
		* HTTP/1.1协议是瀑布式的加载资源,而每个连接同一时间只能处理一个'请求-响应',因此前面的'请求-响应'受阻也会影响后续'请求-响应'的处理；
		* HTTP/1.1协议每次请求都会附带请求头(即使这些请求头的内容过多、更新频率太少)；
		* HTTP/1.1协议传输的是超文本数据(可视作'明文传输'),具有一定的安全风险；
	
	2) HTTP/2协议的特点
		* HTTP/2协议是SPDY/3 draft的优化版协议；
		* HTTP/2协议传输的是'二进制帧',它将一个TCP连接分为若干个流(Stream,即每个请求对应一个流),每个流中可以传输若干消息(Message,即并行传输数据),
		  每个消息由若干最小的二进制帧(Frame,即数据以帧的形式表示)组成；
		  每一帧都由9个字节的头部和n个字节的负载部(即主体内容,取决于帧的类型)组成,其中:
		      头部 = length(24bits) + type(8bits) + flags(8bits) + R(1bits) + stream identifier(31bits)
			  [1] length	即帧的长度(24-unsigned-int,头部的9个字节头不计算在内)
			  [2] type 		即帧的类型(若为unknown,则应当忽略或弃用),共10种:
			  				TYPE 			VALUE		EXPLAIN
			  				data 			0x0			携带响应的主体内容
							headers			0x1			开启一个流或携带一个头部块内容
							priority		0x2			携带优先级(即权重)内容
							rst_stream		0x3			取消一个流或提示错误
							settings		0x4			携带连接的配置内容
							push_promise	0x5			携带服务器的推送内容(客户端可以应答rst_stream帧来拒绝推送)
							ping			0x6			检测空闲连接是否可用
							goway			0x7			请求关闭连接或提示严重错误(停止接收新的流,并妥善处理完之前的流)
							window_update	0x8			操作流量控制(作用于某个流或整个连接,仅影响data帧)
							continuation	0x9			携带后续的头部块内容
			  [3] flags		即帧的布尔标识(为帧的类型预留的标识)
			  [4] R 		即保留比特位,无特殊含义(发送时必须为0x0,接收时忽略它)
			  [5] stream identifier	即流控制标识(即sid,31-unsigned-int,客户端创建的sid必须为奇数,服务器创建的sid必须为偶数)；帧是并行传输的,所以需要该标识来保证数据的正确性；
		  更直观的说,HTTP/2协议将请求分为'头部帧'和'数据帧',请求头和响应头全部采用小写字母表示,部分常用的请求头和响应头前面加上':'表示'伪头字段',
			例如:':method: GET'、':scheme: https'等；
		* HTTP/2引入'HPACK'算法对HTTP协议的头部数据进行压缩(动态头部字典、静态头部字典、霍夫曼编码)；
		* HTTP/2支持服务器'主动推送'请求资源相关的数据,而无需像HTTP/1.0和1.1协议那样,被动地等待客户端一次次请求资源相关的数据；