一、基础知识
	1.单行注释与多行注释
		单行注释
			// 这是行注释
		多行注释
			/* 这是多行
			注释 */

二、数据类型
	1.整数
		Int
			* 自适应整数类型(在32位平台为Int32，在64位平台为Int64)
			* 声明示例 let userDefined: Int = 32
			* 常用方法
				Int(param)
					-> Int?，可选趋零整数
					* param可以是“浮点数”、“字符串”
				Int.zero
					-> 0
				Int.min
					-> Int，自适应最小整数
				Int.max
					-> Int，自适应最大整数
				Int.random(in: range_obj)
					-> Int，范围内随机整数
		
		UInt 
			* 自适应无符号整数类型(在32位平台为UInt32，在64位平台为UInt64)
			* 声明示例 let userDefined: UInt = 32
	
	2.浮点数
		Double
			* 64位浮点类型(对应高精度、大数值的需求)
			* 声明示例 let userDefined: Double = 3.2
			* 常用方法
				Double(param)
					-> Double?，可选浮点数
					* param可以是“浮点数”、“字符串”
				.rounded()
					-> Double，四舍五入浮点数
				Double.pi
					-> π
				Double.infinity
					-> 正无穷
				Double.zero
					-> 0.0
				Double.random(in: range_obj)
					-> Double，范围内随机浮点数
		
		Float
			* 32位浮点类型
			* 声明示例 let userDefined: Float = 3.2

	3.字符串
		String
			* 字符串类型
			* 声明示例 let userDefined: String = "32"
			* 常用方法
				String()
					-> ''，空字符串
				String(repeating:char/str, count:Int)
					-> String，即char/str重复Int次的字符串
				.isEmpty
					-> Bool，判断字符串是否为空
				.count
					-> Int，字符串的字符个数
				.lowercased()
					-> String，全小写的新字符串
				.uppercased()
					-> String，全大写的新字符串
				.hasPrefix(str)
					-> Bool，判断字符串是否以str开头
				.hasSuffix(str)
					-> Bool，判断字符串是否以str结尾
				.contains(char)
					-> Bool，判断字符串是否包含char
				.append(char/str)
					-> Void，向字符串尾部添加char/str
				.remove(at: String.Index)
					-> Character，删除指定位置的字符并返回它
				.insert(char, at: String.Index)
					-> 
				
三、函数
	[custom] func userDefined([_] [parm: parm_type], ...) -> return_type {
		function_body
		[return return_value]
	}
	——————————————————————————————————————————
		[@discardableResult]
			允许该函数(或方法)的调用者忽略结果，且不会产生编译错误或警告
四、结构体与类

五、常用框架及其方法
	1.import UIKit

		arc4random_uniform(X)
			-> UInt32，返回一个0~X之间(不含X)的随机整数





		let const:Double = 值
			64位浮点类型(高精度、大数值)
		let const:Float = 值
			32位浮点类型
		——————————————————————————————————————————
			[注意]:浮点值在不同进制下有不同的表示形式
			1.25e2 -> 1.25*10^2
			0xFp20 -> 15*2^20
			[注意]:浮点数是值类型
		
		Bool
			布尔类型
		——————————————————————————————————————————
			[注意]:布尔值的直接量只有true和false，但条件表达式的结果也被视作一个布尔类型的值
			[注意]:布尔值是值类型

		String
			字符串类型
			\(表达式) -> 将表达式的结果转化为字符串
			\ -> 转义符号
		Character
			字符类型
		——————————————————————————————————————————
			[注意]:字符串和字符是值类型，被操作的是原字符(串)的副本

		可选类型
			值存在或者为nil
		——————————————————————————————————————————
			[注意]:nil是一个特殊值，用于表示值的缺失。而在Objective-C中nil是一个指针(指向不存在的对象)
			[注意]:可以通过<变量名==nil>或<变量名!=nil>来判断该变量是否存在值
			[注意]:若断定可选类型的变量存在值，可以通过<变量名!>来等价表示(即可选值的强制解析)
		
		([别名1:]type1, [别名2:]type2, ...)
			元组类型
		——————————————————————————————————————————
			[注意]:元组中元素的类型可以各不相同
			[注意]:可以在定义元组时为每个元素起别名
			[注意]:元组是值类型
		
		[类型]()		      -> 空数组
		Array(repeating:重复值, count:重复次数)	-> 带默认值的数组
		[值1, 值2, ...]		  -> 带具体值的数组(前提是对应变量已声明数组类型)
			数组类型
		——————————————————————————————————————————
			[类型]:数组中所有元素的统一类型
			[注意]:利用构造器创建的数据类型
			[注意]:数组是值类型

		Set<类型>()		      -> 空集合
		[值1, 值2, ...]		  -> 带具体值的数组(前提是对应变量已声明集合类型)
		——————————————————————————————————————————
			[类型]:集合中所有元素的统一类型
			[注意]:集合是值类型
		
		[键类型:值类型]()        -> 空字典
		[键1:值1, 键2:值2, ...] -> 带具体值的字典(前提是对应变量已声明数组类型)
		——————————————————————————————————————————
			[注意]:字典是值类型
			
		([参数类型, ...])->返回值类型
			函数类型
		——————————————————————————————————————————
			[注意]:函数类型也是一种特殊的数据类型
			[注意]:返回值类型可以是Void(表示无返回值)
		
		typealias 类型别名=内置类型
		——————————————————————————————————————————
			[注意]:为内置类型起别名

	4.运算符
		=
			赋值运算符
		——————————————————————————————————————————
			[注意]:对应表达式(或语句)不返回任何值

		-
			负数（相反数）
		——————————————————————————————————————————
			[注意]:对应表达式(或语句)返回值

		+ - * / %
			四则运算符(加减乘除余)
		——————————————————————————————————————————
			[注意]:加法操作中可以连接两个字符(串)
			[注意]:余数操作中余数符号会被忽略，即a%b和a%-b结果相同
			[注意]:对应表达式(或语句)返回值

		== != > < >= <= === !==
			比较运算符
		——————————————————————————————————————————
			[===/!==]:这两个比较运算符用于判断是否引用同一对象
			[注意]:对应表达式(或语句)返回值
		
		条件表达式 ? true结果 : false结果
			三目运算符
		——————————————————————————————————————————
			[注意]:对应表达式(或语句)返回值
		
		可选变量名 ?? 默认值
			空合运算符(若可选变量存在值，则返回存在值；否则返回默认值)
		——————————————————————————————————————————
			[默认值]:默认值的类型必须与可选变量存在值的类型相同
			[注意]:对应表达式(或语句)返回值

		下界数..<上界数 下界数...上界数
			区间运算符(..<左闭右开，...左闭右闭)
		——————————————————————————————————————————
			[注意]:对应表达式(或语句)返回值

		! && ||
			逻辑运算符
		——————————————————————————————————————————
			[注意]:逻辑运算符只能操作布尔类型的对象
			[注意]:对应表达式(或语句)返回值

二、基本语法
	1.声明赋值语句
		let/var 变量名[:类型?/:类型!]=值, 变量名[:类型?/:类型!]=值, ...
		变量名 += 值
		变量名 -= 值
		变量名 *= 值
		变量名 /= 值
		——————————————————————————————————————————
			[变量名]:若值为集合，则变量名可以解包，形如:(变量名1, 变量名2, ...)=值
			[:类型?/:类型!]:可以不声明类型(系统自动判断类型)
				若额外声明?，则表示该变量为可选类型(值存在或者为nil)
				若额外声明!，则表示该变量为可选类型(值必定存在)
				类型，可以是基础类型 -> String、Int、UInt、Double、Float	
					 可以是高级类型 -> [基础类型]、Set<基础类型>、[键基础类型:值基础类型]
			[注意]:赋值操作不返回任何值，所以赋值语句无法作为条件表达式
			[注意]:组合赋值操作必须先声明了变量名

	2.可选绑定语句
		let/var 变量名=可选变量
		——————————————————————————————————————————
			[注意]:可选绑定语句整体被视作条件表达式，其结果为true或false
	
	3.For-In循环语句
		[标签名:] for 临时变量 in 遍历对象 {
			执行语句
		}
		——————————————————————————————————————————
			[临时变量]:该变量无需提前声明(系统自动隐式声明)。
				若无需使用临时变量，可以将其设为_
				若遍历对象可被解包，临时变量可以被设为(临时变量1, 临时变量2, ..)形式的元组
			[注意]:continue语句会立即停止本次循环，开始下次循环
			[注意]:break语句会立即停止并跳出最近的当前循环语句
				通过<break 标签名>可以精准跳出对应的循环语句

	4.While循环语句
		[标签名:] While 条件表达式 {
			执行语句
		}
		——————————————————————————————————————————
			[注意]:continue语句会立即停止本次循环，开始下次循环
			[注意]:break语句会立即停止并跳出最近的当前循环语句
				通过<break 标签名>可以精准跳出对应的循环语句
	
	5.Repeat-While循环语句
		[标签名:] repeat {
			执行语句
		} while 条件表达式
		——————————————————————————————————————————
			[注意]:continue语句会立即停止本次循环，开始下次循环
			[注意]:break语句会立即停止并跳出最近的当前循环语句
				通过<break 标签名>可以精准跳出对应的循环语句
	
	6.If语句
		if 条件表达式 {
			执行语句
		} else if 条件表达式 {

		} ...
		 [else {
			可选执行语句
		}]
		——————————————————————————————————————————
			[注意]:break语句会立即停止并跳出最近的控制语句
	
	7.Guard语句
		guard 条件表达式 else {
			执行语句
		}
		——————————————————————————————————————————
			[注意]:条件表达式为false是，执行else分支的语句

	8.Switch语句
		switch 匹配源 {
		case 匹配物1:
			执行语句
		case 匹配物2:
			执行语句
		...
		default:
			执行语句
		}
		——————————————————————————————————————————
			[匹配物]:允许复合匹配(逗号隔开，允许分行书写)和区间匹配
			[注意]:Switch执行完第一个匹配的case分支后就会终止switch(无需声明break语句)
			[注意]:break语句会立即停止并跳出最近的控制语句
			[注意]:匹配源可以是枚举成员
			
	9.异常语句
		do {
			try 其他语句	// 关键字try用于捕捉异常
		} catch 异常类型1 {
			异常处理语句1
		} catch 异常类型2 {
			异常处理语句2
		} ...
	
	10.断言语句(全局函数)
		assert(条件表达式, "断言声明")
		——————————————————————————————————————————
			[注意]:当条件表达式为true时，程序继续向下执行；当为false时，程序终止并显示断言声明

三、函数
	1.定义语句
		func 函数名([[参数标签] 参数名:[inout] [@escaping] 参数类型[.../=默认值], ...]) [-> 返回值类型] {
			函数体
			[return [返回值]]
		}
		——————————————————————————————————————————
			[参数标签]:若省略，则默认为参数名。若设置为_，则调用函数时无需声明参数标签
			[inout]:除基本和高级数据类型外，还有输入输出类型(必须额外声明inout)。输入输出参数必须是变量，禁止设置默认值
			[@escaping]:若参数类型为闭包函数，则必须额外声明@escaping
			[...]:在参数类型后额外声明...，表示该参数为可变参数(函数体中被视作数组)。
			[=默认值]:在参数类型后额外声明=默认值，表示该参数有默认值
			[-> ...]:允许为函数类型。若函数无返回值，则无需声明返回值类型(但函数仍返回了Void值，即空元组)
			[return ...]:允许无返回值的函数。无return语句，则无需声明[-> ...]
			[注意]:函数参数默认是常量，函数体语句无法修改传入函数的参数值
			[注意]:函数体语句中使用参数名操作参数
			[注意]:一个函数最多只能有一个可变参数

	2.调用语句
		函数名([参数标签:][&]参数值, ...])
		——————————————————————————————————————————
			[参数标签:]:通常调用函数必须使用参数标签(若定义函数时声明了参数标签则使用所声明的标签，若未声明则使用参数名，若声明为_则无需使用参数标签)
			[&]:若需要传入输入输出参数，必须在参数值前额外声明&
	
	3.闭包表达式
		{([参数名:[inout] 参数类型, ...]) -> 返回值类型 in
			函数体
		}
		——————————————————————————————————————————
			[注意]:闭包表达式相当于Python中的匿名函数
			[注意]:闭包表达式返回一个函数对象
			[注意]:闭包表达式用关键字in开启后续的函数体声明

四、类
	1.枚举
		enum 枚举名 {
			[indirect] case 成员(关联类型1[, ...])
			case 成员1[=原始值], 成员2[=原始值+1], ...
			...
		}
		——————————————————————————————————————————
			[indirect]:表示成员是可递归的
			[(关联类型1[, ...])]:整个称为对应成员的关联值
			[=原始值]:默认的原始值为0(可以自行设置)，后续成员的原始值依次递增1(枚举名.成员.rawValue可以获取对应成员的原始值)
			[注意]:成员可以有多个具体值(用逗号隔开)
			[注意]:枚举是值类型，被操作的是原字符(串)的副本
	
	2.结构体与类
		struct 结构体名 {
			[mutating] func 方法名([[参数标签] 参数名:[inout] [@escaping] 参数类型[.../=默认值], ...]) [-> 返回值类型] {
				方法体
				[return [返回值]]
			}
		}
		——————————————————————————————————————————
			[mutating]:结构体是值类型，无法修改实例属性，声明关键字mutating后可以通过方法修改
			[注意]:结构体是值类型，被操作的是原字符(串)的副本
			[注意]:几乎所有基本类型的底层都是通过结构体构造的

		[final] class 子类名[:超类名] {
			// 延迟属性和类属性
			[lazy] [static/class] let/var 属性名 [{
				// 属性观察器
				willSet {

				}
				didSet {

				}
				// 计算属性
				get {
					return 值
				}
				set[(argv)] {

				}
			}]
			// 重写属性和禁止重写属性
			override/final let/var 属性名 ...

			// 普通方法
			[static/class] func 方法名([[参数标签] 参数名:[inout] [@escaping] 参数类型[.../=默认值], ...]) [-> 返回值类型] {
				方法体
				[return [返回值]]
			}
			// 下标方法和禁止重写下标
			[override/final] subscript(index:Int) -> Int {
				get {

				}
				set(argv) {

				}
			}
			// 重写方法和禁止重写方法
			override/final func 方法名([[参数标签] 参数名:[inout] [@escaping] 参数类型[.../=默认值], ...]) [-> 返回值类型] {
				方法体
				[return [返回值]]
			}

			// 构造方法
			init([[参数标签] [参数名:参数类型]]) {
				构造体
			}
		}
		——————————————————————————————————————————
			[final]:不允许该类被继承(子类无法重写该类的任何属性和方法)
			[:超类名]:子类继承超类及超类的超类(递归)中的所有属性和方法
			[lazy]:对应延迟属性(第一次被调用时才会被赋值)，必须为变量
			[static/class]:static和class都修饰类变量或类方法，但class可以被子类重写
			[注意]:下标方法可以自定义<对象[i]>的操作，下标方法可以重载
			[注意]:构造方法可以重载
			[注意]:类是引用类型
			[注意]:全局常量(或变量)均为延迟计算
	
