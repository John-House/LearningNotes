随手记录
=============================================
	"隐式调用"魔法方法不会被__getattribute__()拦截,但"显示调用"魔法方法会被拦截,例如:
		class Test(object):
			def __getattribute__(self, name):
				print("惊动我了")
				return object.__getattribute__(self, name)

			def __call__(self):
				return "__call__"

			def __str__(self):
				return "__str__"
		
		if __name__ == "__main__":
			t = Test()
			print(t)				-> 打印"__str__"
			print(t.__str__())		-> 打印"惊动我了"
									      "__str__"
			
			print(t())				-> 打印"__call__"
			print(t.__call__())		-> 打印"惊动我了"
									      "__call__"

	如果终端显示【pip/pip3 : command not found】,那么去python的安装目录下的bin目录下寻找是否有【pip/pip3】的可执行文件,
	如果没有则寻找是否有【easy_install-版本号】的可执行文件,如果有则在终端键入【easy_install-版本号 pip】命令即可；
	本质上,Mac终端找不到命令,说明环境变量PATH未配置好(即未添加对应命令的PATH),或者说所有的环境变量PATH下都没有对应的命令


	编码格式     字节数     01序列(十进制)
	ASCII        1 		   0~127

	Latin-1      1 		   0~255    	--> 扩展了ASCII,将128~255中的每个值都对应一个重音或特殊字符

	UTF-8        1+        0~127        --> 0~127的每个字符只占1个字节
						128~2047     --> 128~2047的每个字符占2个字节,每个字节的值都位于128~255
						2048~        --> 2047以上的每个字符占3~4个字节,每个字节的值都位于128~255


	复制一份数据(无论是否有嵌套/引用结构)的话,深拷贝和浅拷贝:
		深拷贝不管外层是可变还是不可变对象,都会创建新的对象,然后看里面:如果是可变对象,深拷贝会创建新的对象；如果是不可变对象,深拷贝会引用
		浅拷贝如果外层是不可变对象,浅拷贝会引用(不再管里面是什么了)；如果外层是可变对象,浅拷贝会创建新的对象,然后不管里面是可变还是不可变对象,浅拷贝都会引用


	使用with语句时,必须搭配__enter__和__exit__两个方法使用:

		with ... as 变量名:
			xxx
			xxx

		with语句执行顺序:
			1)先执行【...】语句,并返回一个具有__enter__方法的对象
			2)再执行【返回对象】的__enter__方法
			3)再将__enter__方法的【返回值】赋给【变量名】
			4)再执行【xxx】语句
			5)最后执行【返回对象】的__exit__方法
		注意:
		__enter__和__exit__方法都是实例方法(注意self参数),
		其中,__exit__方法必须在self参数后面带上3个与异常处理相关的参数 - type, value, traceback -
		当语句出现任何异常时,都会把异常传给这3个参数。

	object和type的关系
		object是所有【继承关系】的始祖,所有类(包括type类对象)都继承自object(继父)；
		type是所有【类型实例关系】的始祖,所有类(包括type和object类对象)都创建自type(生父)；

	Web编程:
		TCP/IP -> 协议簇(cu) -> 多种协议的集合

		客户端的应用程序通过'TCP协议'与服务器的应用程序通信，
			需要知道:
				服务器的IP地址 -> 4个字节 -> 找到服务器 -> 背靠DNS(域名系统)
				服务器的端口号 -> 2个字节 -> 找到服务器对应的应用程序
					小于1024的端口为约定好的端口，具体功能可以查看'/etc/services'文件

			通信期间确保安全:
				数据包编号
				数据包校验码
				数据包应答

		‘UDP协议’:
			只保证'数据完整'，不保证'是否收到'和'数据包次序'(一个数据包不超过64kb)，几乎不花费时间在连接的建立和关闭上
			通常用于发送'短数据'(通常在1kb以下)，典型应用如:DNS(域名系统)

		TCP/IP协议，可以在'不同的物理网络硬件之间'通信，包括但不限于:以太网、端对端拨号、令牌环网络、DSL连接、移动电话、人造卫星等等


		以太网，是应用最广泛的物理传输类型，
			特点一:
				可以向本地网络中所有的主机广播内容
			
		Python提供了访问底层操作系统中Socket接口的全部方法，例如:socket模块
			回顾一下socket标准库中的'异常有哪些' ~~~
				socket.error -> 与一般I/O和通信问题有关的异常
				socket.gaierror -> 与查询地址信息有关的异常
				socket.herror -> 与其他地址错误有关的异常
				socket.timeout -> 与超时处理有关的异常
				特别关注shutdown()函数引起的异常

			socket对象.makefile(...) -> 生成socket对象对应的文件对象，因为操作'文件对象'更方便、熟悉；

		Python提供了许多底层协议对应的模块，例如:httplib模块、urllib模块等等，免去了程序员编写底层程序的工作；

		socket是网络通信的基本接口，是操作系统中'I/O系统'的延伸；它可以让'进程'和'计算机'之间进行通信；

		1）文件描述符，即一个文件或类文件的实体；扩展文件描述符结构，让操作系统支持'网络'相关的功能；
		2）socket，和文件描述符很相似，也具有一些文件描述符的方法或函数，但socket也有自己不同之处(例如，socket的建立，socket通过socket()函数完成，而文件描述符通过open()函数完成)
		3）Python提供了两种socket通信的方法:
			a) 借助socket(即socket对象)，具有.send()、.recv()等方法
			b) 借助文件描述(即文件对象)，具有.read()、.write()等方法

		客户端建立socket分为2步:
			1) 创建socket对象
				需要告诉操作系统'通信类型'(即协议类型，规定如何传输数据，例如IPv4、IPv6、IPX/SPX、AFP等等)和'协议家族'(即SOCK_STREAM对应TCP通信，SOCK_DGRAM对应UDP通信)
			2) 将该socket对象连接到远程服务器
				需要明确远程服务器的IP地址和端口号
				socket.getservbyname('协议名') -> 该函数可以根据'协议名'查询并返回对应的'标准端口号'
		服务器建议socket分为4步:
			1) 创建socket对象 
				同客户端的建立
			2) 配置socket对象
				查看setsockopt()和getsockopt()方法
			3) 绑定服务器端口
				当服务器有多个网络接口(即多个网卡)时，你需要指定好

			4) 监听可能到来的连接
				循环监听工作 ？
				等待队列中的连接数 ？ 
				Unix或类Unix系统中有一个inetd或xinetd的程序，它用于解决服务器只能为一个客户端连接服务的问题，通过将单个客户端连接的信息拷贝给自己来解决问题

		DNS(域名系统)，是一个'分布式数据库'，主要用于将'主机名'转换成'IP地址'，它存在的原因:
			1) 方便用户记忆IP地址(文本数据比纯数字数据更好记忆)
			2) 允许服务器变更IP地址时，不变更域名
			回顾socket模块中访问域名的方法或函数有哪些 ~~~
			跟进DNS的反向查询 ~~~

基本数据类型(完)
=============================================
	## Python程序由大到小:程序 > 模块 > 语句 > 表达式 > 对象
		模块 --> 后缀为.py的文件
		语句 --> 符合Python语法的一条或多条表达式
		表达式 --> 创建和操作对象的Python代码
		对象 --> 一切皆对象，遵循原则:  1.先赋值，后创建，再使用
									2.变量名指向实际的对象
									3.多个变量名可以指向同一对象，即共享引用
									4.引用计数为主，标记清楚和隔代回收为辅，进行对象的垃圾回收（GC）
									5.Python中，非0非空为真

	1）序列
		定义:按照位置偏移进行储存的一系列有序元素的合集，包括:字符串、列表和元组

		1.1）序列的基本操作
		索引操作 - 从0开始，最大至len(序列)-1，内置函数len()返回了序列的元素个数
				- 索引值可以是负数，即0 ~ len(序列)-1 等价于 -len(序列) ~ -1
				- 索引切片，即序列[a:b:c]，序列的“子集”，从a开始到b（不包括b）结束，期间间隔c

		符号操作 - 序列a + 序列b，表示两个序列的合并
				- 序列a * 数字，表示重复序列a多少次来形成新的序列

		1.2）字符串
		1.2.1）基本概念
		* 字符串是一系列字符的结合
		* 字符串具有不可变性

		1.2.2）常用操作
		* 索引 - 字符串[索引值]，即return字符串指定索引值处的字符
		* 分片 - 字符串[a:b:c]，即return原字符串中索引值从a到b(不包括b)期间间隔c的子串
		* 遍历 - for each in 字符串，即取出字符串中的每个字符，多与其他操作结合
		* 类型转换 - ord('字符')，即内置函数ord()，将字符转换成对应的ASCII码数字
					chr(数字)，即内置函数chr()，将数字转换成对应的ASCII字符
					str(内容)，即内置函数str()，将内容转换成字符串
					eval('内容')，即内置函数eval()，将内容还原
		* 格式化 - 转义，即用“\xx”表示特殊的字符，i.e:\n表示换行，\\表示单个‘\’，也常用于正则表达式中
				抑制转义，即用r'字符串'表示不转义，字符串的内容是什么就是什么，raw是“原始“的意思

				%格式化，即用   '字符串' % 实参   表示特殊规范的字符串，'字符串'中的占位符和实参的个数一一对应（多个实参时，使用元组形式）
						'字符串'中使用  %[(key值)][符号标志][总宽度][.小数位数]形参类型  作为占位符
						i.e: key值    对应形参中字典的key(注意:要用key值，所有的占位符都要用key值，实参改为字典形式)
							符号标志  - 表示左对齐（默认右对齐）
										+ 表示显示符号（显示正负号，如果有则占总宽度中的一位）
										0 表示缺位时形参是数字用0补齐，形参是字符串用空格补齐
										正数或空字符串前面加一个'空格'
							总宽度	    对应总宽度
							.小数位数 对应小数点后显示多少位
							形参类型  s 表示（友好显示的）字符串
										r 表示（非友好显示的）字符串
										d 表示（十进制的）整数
										o 表示（八进制的）整数
										x 表示（十六进制的）整数
										f 表示（十进制的）浮点数
										% 表示‘%’，类似于转义需要有个东西表示正常意义下的‘%’

				format格式化，即用   '字符串'.format(实参)   表示特殊规范的字符串，'字符串'中的占位符和实参的个数一一对应
							'字符串'中使用'{[内容字段][!转换字段][:格式字段]}'作为占位符
							i.e: 内容字段 -> 编号/key值 ,即{0/key...} {1/key1...} ... 对应后面的实参1，实参2，...
											.属性名/[索引/key] ,即{xx.属性名/[索引/key]} ...实际取后面实参的属性或索引值或key键值

									转换字段 -> r/s/a ,即调用一次 repr(内容字段结果) / str(内容字段结果) / ascii(内容字段结果) 方法

									格式字段 -> 填充 ,即填充字符(除{和}外的任意字符)
											对齐 ,即对齐标识(< 表示左对齐，大部分对象的默认对齐方式)
															(> 表示右对齐，数字的默认对齐方式)
															(^ 表示居中对齐)
															(= 表示用0填充符号之后数字本体之前的部分，仅对数字类型有效)
											符号 ,即符号标识(+ 表示正数前有+，负数前有-)
															(- 表示正数前没有，负数前有-)
															(  表示正数前有 ，负数前有-)
											#    ,即修饰标识(对于十进制整数实参，在转换成b/o/x等实际显示类型时会自动添加0b/0o/0x的前缀)
															(对于浮点数和Decimal实参，在转换成任意实际显示类型时会自动添加.的后缀)
											总宽度 ,即实际显示的总宽度
											分组 ,即分组标识(,表示千位分隔符)
															(_ 表示4位连接符)
											小数 ,即小数位数
											类型 ,即实际显示类型(s - 显示类型:字符串，实参类型:字符串)
																(c - 显示类型:Unicode字符串，实参类型:十进制整数)
																(b - 显示类型:二进制字符串，实参类型:十进制整数）
																(d - 显示类型:十进制字符串，实参类型:十进制整数)
																(o - 显示类型:八进制字符串，实参类型:十进制整数)
																(x - 显示类型:十六进制字符串，实参类型:十进制整数)
																(f - 显示类型:浮点数字符串，实参类型:浮点数) 默认小数点后6位
																(% - 显示类型:百分比字符串，实参类型:数字) 默认小数点后6位

		* 常用方法:
		str.upper()         
			--> ctype: 字符串，即全部转成大写
		str.casefold()       
			--> ctype: 字符串，即全部转成小写
		str.swapcase()       
			--> ctype: 字符串，即将'字符串'中的每个字符大写变小写，小写变大写
		str.title()          
			--> ctype: 字符串，即每个单词首字符大写
		str.capitalize()     
			--> ctype: 字符串，即整个字符串首字符大写

		str.center(总宽度[,单个填充字符])      
			--> ctype: 字符串，即将原字符串居中并保证总宽度，缺位时左右两边用填充字符补齐，默认用空格
		str.ljust(总宽度[,单个填充字符])       
			--> ctype: 字符串，即将原字符串左对齐并保证总宽度，缺位时右边用填充字符补齐，默认用空格
		str.rjust(总宽度[,单个填充字符])       
			--> ctype: 字符串，即将原字符右对齐并保证总宽度，缺位时左边用填充字符补齐，默认用空格

		str.count('子串'[,a[,b]])         
			--> ctype: 次数，即某个子串在原来的字符串从a开始到b结束【左闭右开】期间出现的次数

		str.replace('old','new'[,count]) 
			--> ctype: 字符串，即用'new'从左至右去替换原字符串的'old'，count表示替换的次数（省略表示全部替换）

		str.startswith('开头字符'[,a[,b]])   
			--> ctype: True/False，即判断[从a开始到b结束的]字符串是否是以'开头字符'开头的
		str.endswith('结尾字符'[,a[,b]])     
			--> ctype: True/False，即判断[从a开始到b结束的]字符串是否是以'结尾字符'结尾的

		str.partition(sep)               
			--> ctype: 元组，即sep为分隔标识，即根据什么字符(串)将'字符串'分割成2个部分，然后以(左半,分隔标识,右半)的元组形式返回
		str.rpartition(sep)              
			--> ctype: 元组，同上，只不过是从右边开始分隔
		str.split(sep=None,maxsplit=-1)  
			--> ctype: 列表，即sep为分隔标识,即根据什么字符(串)分割maxsplit为分割次数，生成的列表长度应该为【次数+1】
		str.rsplit(sep=None,maxsplit=-1) 
			--> ctype: 列表，即同上，区别为从后向前分割

		str.join(可迭代对象)  
			--> ctype: 字符串，即将字符串插入可迭代对象(全是字符串类型）的每个元素之间，然后返回整个字符串
		str.strip([字符合集])    
			--> ctype: 字符串，即从两头分别找第一个不存在于字符合集中的字符，这样就分别确定了字符串的头和尾，
							从头和尾的字符zi'c且位于原字符串两头的所有字符去掉，返回剩余的字符串
		str.lstrip([字符合集])   
			--> ctype: 字符串，即将存在于字符合集中且位于原字符串前头的所有字符去掉
		str.rstrip([字符合集])   
			--> ctype: 字符串，即将存在于字符合集中且位于原字符串后头的所有字符去掉，

		str.find('子串'[,a[,b]])    
			--> ctype: 索引值/-1，即某个子串在原来的字符串从a开始到b结束【左闭右开】期间第一次出现时的索引值。未找到返回-1
		str.rfind('子串'[,a[,b]])   
			--> ctype: 索引值/-1，即从后往前找
		str.index('子串'[,a[,b]])   
			--> ctype: 索引值，即未找到时raise ValueError
		str.rindex('子串'[,a[,b]])  
			--> ctype: 索引值，即从后往前找，未找到raise ValueError

		str.isalpha()       
			--> ctype: True/False，即判断'字符串'中的所有字符(至少有一个字符)是否都是字母
		str.isdigit()        
			--> ctype: True/False，即判断'字符串'中的所有字符(至少有一个字符)是否都是数字
		str.isalnum()        
			--> ctype: True/False，即判断'字符串'中的所有字符(至少有一个字符)是否都是字母或数字
		str.isspace()        
			--> ctype: True/False，即判断'字符串'中的所有字符(至少有一个字符)是否都是空白字符
		str.isidentifier()   
			--> ctype: True/False，即判断'字符串'是否是一个合理的标识符
		str.isupper()        
			--> ctype: True/False，即判断'字符串'中的所有字符是否都是大写
		str.islower()        
			--> ctype: True/False，即判断'字符串'中的所有字符是否都是小写
		str.istitle()        
			--> ctype: True/False，即判断'字符串'中的单词(至少有一个字符)是否都是首字符大写

		str.encode('字符编码', errors='strict')   
			--> ctype: 字节对象，即将字符串按照指定的代号编码成字节对象，
			--> errors ,即表示出现编码错误时的操作:strict -> 默认值，按照严格编码格式进行；ignore -> 若出现畸形字符，则忽略


		1.3）列表
		元素 in 列表 --> ctype: 真/假 --> 列表中有元素
		元素 not in 列表 --> ctype: 真/假 --> 列表中没有元素
		列表A + 列表B --> ctype: 列表 --> 直接用“+”操作符表示合并
		列表 * n --> ctype: 列表 --> 列表重复n次后形成新列表
		列表[a:b:c] --> ctype: 列表 --> a:起始，b:终止，c:间隔(默认c=1)
			列表[::-1] --> ctype: 列表 --> 即倒序一个列表
			列表[:] --> ctype: 列表 --> 即copy一个列表

		len(列表) --> ctype: 列表长度值 --> 即列表中的元素个数
		max(列表) --> ctype: 列表最大值 --> 即列表中的最大值
		min(列表) --> ctype: 列表最小值 --> 即列表中的最小值

		a) 增
		list.append(元素) 
			--> ctype: None --> 即向列表末尾添加新的元素，在原处修改
		list.extend(新列表) 
			--> ctype: None --> 即向列表末尾添加新的列表，在原处修改
		list.insert(索引,新元素) 
			--> ctype: None --> 即向列表指定索引处添加新的元素，在原处修改


		b) 删
		del 列表[索引] --> ctype: None --> 即从列表中截取索引处的元素，在原处修改
		list.remove(元素) --> ctype: None --> 即从列表中删除指定的元素，在原处修改
		list.pop([索引]) --> ctype: 元素 --> 即从列表中截取索引处的元素，默认截取末尾，在原处修改
		list.clear() --> ctype: 空列表 --> 即清空列表，在原处修改

		c) 查
		list.count(元素) --> ctype: 次数值 --> 即某个元素在列表中出现的次数
		list.index(元素,[a,b]) --> ctype: 索引 --> 即列表从a到b期间元素第一次出现处的索引值

		d) 修
		list.sort(key=None,reverse=False) --> ctype: None --> 即升序排序列表，在原处修改(建议使用内置函数sorted())
		list.reverse() --> ctype: None --> 即倒序列表，在原处修改
		list.copy() --> ctype: 新列表 --> 即copy一份列表

		e) 创建列表的方法
		列表 = [a,b,c,...] --> 直接赋值法
		列表 = [表达式 for i in range(x)] --> 列表生成式法
		列表 = list(可迭代对象) --> 函数生成法
			list.extend(列表)
			list.append(元素)
		列表[a:b:c] --> 切片生成法

		1.4）元组
		元素 in 元组 --> ctype: 真/假 --> 元组中有元素
		元素 not in 元组 --> ctype: 真/假 --> 元组中没有元素
		元组A + 元组B --> ctype: 元组 --> 直接用“+”操作符表示合并
		元组 * n --> ctype: 元组 --> 元组重复n次后形成新列表
		元组[a:b:c] --> ctype: 元组 --> a:起始，b:终止,c:间隔(默认c=1)
			元组[::-1] --> ctype: 元组 --> 即倒序一个元组
			元组[:] --> ctype: 元组 --> 即copy一份元组

		len(元组) --> ctype: 元组长度值 --> 即元组中的元素个数
		max(元组) --> ctype: 元组最大值 --> 即元组中的最大值
		min(元组) --> ctype: 元组最小值 --> 即元组中的最小值

		c) 查
		tuple.count(元素) --> ctype: 次数值 --> 即某个元素在元组中出现的次数
		tuple.index(元素,[a,b]) --> ctype: 索引 --> 即元组从a到b期间元素第一次出现处的索引值

	2）映射
		定义:按照键值映射储存的一系列无序元素的合集，包括字典
		2.1) 字典
		key in 字典 --> ctype: 真/假 --> 即字典中有key键
		key not in 字典 --> ctype: 真/假 --> 即字典中没有key键

		len(字典) --> ctype: 字典项数 --> 即字典中的键值对个数
		字典[key] --> ctype: 字典键值 --> 即key键对应的值

		a) 增
		字典[key] = value --> ctype: None --> 即字典的赋值语句
		dict.update(其他字典/2个2个一组的可迭代对象) --> ctype: None --> 即将字典与其他字典合并，在原处修改，只能传1个参数
																(重复的键值对保留一份，key值相同的以实参的values为准)

		b) 删
		del 字典[key] --> ctype: None --> 即字典的删除语句
		dict.pop(key[,default]) --> ctype: 键值 --> 即如果key存在，截取key对应的键值；如果key不存在，返回default，如果未指定default，则抛出KeyError异常
			dict.popitem() --> ctype: 键值对 --> 即截取末尾的一个键值对
		dict.clear() --> ctype: 空字典 --> 即清空字典

		c) 查
		dict.get(key[,default=None]) --> ctype: 键值 --> 即获取对应key的键值，如果key不存在则返回default值（default默认为None）
		dict.setdefault(key[,default=None]) --> ctype: 键值 --> 即获取对应key的键值，如果key不存在则添加key:default的键值对

		d) 修
		dict.copy() --> ctype: 新字典 --> 即拷贝一份字典
		dict.items() --> ctype: dict_items可迭代对象 --> 即将字典中的键值对以类元组的形式展示
		dict.keys() --> ctype: dict_keys可迭代对象 --> 即将字典中的所有键以类列表的形式展示
		dict.values() --> ctype: dict_values可迭代对象 --> 即将字典中的所有值以类列表的形式展示

		e) 创建字典的方法
		字典 = {a:b,c:d,e:f,...} --> 直接赋值法
		字典 = {表达式 for i in range(x)} --> 字典生成法
		字典 = dict(a=b,c=d,e=f,...) --> 函数生成法
			字典 = dict(zip(可迭代对象,可迭代对象))
			字典 = dict([(a,b),(c,d),(e,f)])
			dict.fromkeys(序列[,value]) --> 类方法生成字典，所有的key值都对应同一个values值

	3）集合
		定义:唯一的一系列无序元素的合集，包括Set和frzonset
		3.1）Set
		元素 in 集合 --> ctype: 真/假 --> 即集合中有元素
		元素 not in 集合 --> ctype: 真/假 --> 即集合中没有元素

		len(集合) --> ctype: 集合长度值 --> 即集合中的元素个数

		a) 增
		set.add(元素) --> ctype: None --> 即向集合中添加一个元素
		set.union(*其他集合) --> ctype: 新集合 --> 即合并一个或多个集合
			集合 | 其他集合 | ...
		set.update(*其他集合) --> ctype: None --> 即并集合并一个或多个集合，在原处修改
			集合 |= other | ...
		set.intersection_update(*其他集合) --> ctype: None --> 即交集合并一个或多个集合
			集合 &= other & ...
		set.difference_update(*其他集合) --> ctype: None --> 即差集合并一个或多个集合
			集合 -= other | ...
		set.symmetric_difference_update(其他集合) --> ctype: None --> 即异或集合并一个集合（其他集合中有但集合中没有的加进来，其他集合中有但集合中也有的删除掉）
			集合 ^= other

		b) 删
		set.remove(元素) --> ctype: None --> 即从集合中删除指定的元素，元素不存在则raise KeyError
		set.discard(元素) --> ctype: None --> 即从集合中删除指定的元素
		set.pop() --> ctype: 元素 --> 即截取集合中任意一个元素（集合没有顺序，所以不能传入索引参数），集合为空则raise KeyError
		set.clear() --> ctype: 空集合 --> 即清空集合

		d) 修
		set.copy() --> ctype: 新集合 --> 即拷贝一份集合
		set.isdisjoint(其他集合) --> ctype: True/False --> 即如果集合与其他集合不相交（没有任何相同的元素），则返回True
		set.issubset(其他集合) --> ctype: True/False --> 即如果集合是其他集合或其他集合的子集，则返回True
			集合 <= other
		set.issuperset(其他集合) --> ctype: True/False --> 即如果集合是其他集合或其他集合的父集，则返回True
			集合 >= other
		set.intersection(*其他集合) --> ctype: 新集合 --> 即取集合与一个或多个集合的交集，并返回
			集合 & other & ...
		set.difference(*其他集合) --> ctype: 新集合 --> 即取集合与一个或多个集合的差集，并返回
			集合 - other - ...
		set.symmetric_difference(其他集合) --> ctype: 新集合 --> 即新集合中的每个元素要么在集合中，要么在其他集合中，不会存在于它们的交集中
			集合 ^ other

	4）数组
		类型相同的一系列有序元素的合集
		import array

		array.typecodes
			--> ctpye: 字符串，即'bBuhHiIlLqQfd'，数组中所有typecode标识符的集合

		array.array(typecode[,initializer])
			--> ctype: 数组对象
			--> typecode ,即表示数组元素类型的字符串，包括:
				'b'	-- int     -- 有符号char  -- 1 bytes
				'B'	-- int     -- 无符号char  -- 1 bytes

				'u'	-- Unicode -- Py_UNICODE -- 2 bytes
				'h'	-- int     -- 有符号short	 -- 2 bytes
				'H'	-- int     -- 无符号short	 -- 2 bytes
				'i'	-- int     -- 有符号int   -- 2 bytes
				'I'	-- int     -- 无符号int   -- 2 bytes

				'l'	-- int     -- 有符号long  -- 4 bytes
				'L'	-- int     -- 无符号long	 -- 4 bytes
				'f'	-- float   -- float      -- 4 bytes

				'd'	-- float   -- double     -- 8 bytes
			--> initializer ,即iterable，表示数组初始化的数据

			基本信息)
			--> .typecode
					--> ctype: 字符，即返回当前数组的元素类型
			--> .itemsize
					--> ctype: 字节，即返回当前数组的每个元素内部存储时所占的字节数
			--> .buffer_info()
					--> ctype: 元组，即返回(物理地址,数组长度)，物理地址是当前数组的内存地址，元素个数是当前数组的元素个数

			增)
			--> .append(元素)
					--> ctype: None，即向数组尾部添加一个'类型相同的'元素
			--> .extend(iterable)
					--> ctpye: None，即向数组尾部添加'类型相同的'可迭代对象（也可以是array)
			--> .insert(索引,元素)
					--> ctype: None，即向数组指定的索引处添加一个'类型相同的'元素

			删)
			--> .pop([索引=-1])
					--> ctype: value，即截取数组指定索引处的元素（默认截取最后一个元素）
			--> .remove(元素)
					--> ctype: None，即删除数组中第一个'元素'

			查)
			--> .count(元素)
					--> ctype: 数字，即返回数组中'元素'的个数
			--> .index(元素)
					--> ctype: 数字，即返回数组中第一个'元素'所对应的索引值

			修）
			--> .reverse()
					--> ctpye: None，即将数组倒置


pip命令大全(完)
=============================================
	pip3 install [-I] 包名[==版本号]	 # 安装(或重新安装)最新版本(或指定版本的包
	pip3 install -r 含后缀的文件名		  # 安装指定文件中的所有包
	pip3 install -f 包所在的路径或URL     # 安装指定位置的包
	pip3 install -U 包名                # 升级已安装的包

	------------------------------
	pip3 uninstall 包名                 # 卸载包
	pip3 uninstall -r 含后缀的文件名      # 卸载指定文件中的所有包

	------------------------------
	pip3 freeze [> 含后缀的文件名]        # 按照"包名==版本号"格式,将所有已安装的包显示至标准输出(或重定向至指定文件)

	------------------------------
	pip3 list                           # 按照"包名  版本号"的格式显示所有已安装的包
	pip3 list -o                        # 显示所有过时的包,格式为"包名 (Current:版本号 Latest:版本号)"

	------------------------------
	pip3 search 查询字                   # 搜索有关"查询字"的包

	------------------------------
	pip3 show 包名                       # 显示包的基本信息
	pip3 show -f 包名                    # 显示包的详细信息


Git命令大全(待定)
=============================================
	· Git基础知识
		1) VCS(Version Control System,即版本控制系统)的演进:本地VCS -> 集中式VCS -> 分布式VCS；
		   本地VCS,无法与其他计算机做交互,只适合"单打独斗"的项目开发；
		   集中式VCS,虽然能做到多计算机协作开发,但资源和风险过渡集中,当被集中的计算机(即存放版本文件的计算机)发生故障时,所有其他的计算机将陷入"停工"状态；
		   分布式VCS,将被集中的计算机(即存放版本文件的计算机)在所有其他的计算机上各"完整拷贝"一份,即增加了本地操作的自由度,也降低了"停工"风险；
		2) Git对文件版本的记录,是以"提交操作"为节点进行的"整体快照",而其他VCS工具更多的是以"任意文件的更新"为节点进行的"单体差异存储"； 
		3) Git在存储任何数据之前都会借助SHA-1哈希算法计算校验和,并以哈希值作为对应数据的引用,这意味着不可能在Git不知情时更改任何文件内容或目录内容；
		4) Git中文件的状态及存放目录；
			未追踪状态(Untracked),对应那些"未被纳入版本控制"的全新文件,位于工作目录(Working Directory)中；
			已追踪状态(tracked),对应那些"已被纳入版本控制"的文件:
				已修改状态(Modified),对应那些"已修改但未暂存"的文件,位于工作目录(Working Directory,术语:Working Tree)中；
				已暂存状态(Staged),对应那些"已暂存但未提交"的文件,位于暂存区(Staging Area,,术语:Stage Tree)中；
				已提交状态(Committed),对应那些"已提交"(或者说"未修改", Unmodified)的文件,位于仓库(Repository,术语:Repository Tree)中；
			-------------------------
			工作目录(Working Directory),从仓库中提取用于进一步开发的某版本文件所存放的地方,以及存放尚未纳入版本控制的全新文件的地方；
			暂存区(Staging Area),完成进一步的开发后,将已修改或未被纳入版本控制的文件从工作目录存放到该地方,以便统一提交至仓库；
			仓库(Repository),保存项目的元数据和对象数据库的地方；
		5) .git目录下的文件及功能
			每次初始化仓库,都会创建一个.git隐藏目录,该目录下的文件实现了Git绝大部分的功能:
				最基本的.git目录
					|-- hooks/
						  |-- ... 			--> 各种客户端或服务端的钩子脚本文件
					|-- info/
						  |-- exclude		-->	全局性排除文件,不希望记录在.gitignore文件中的内容可以记录在该文件中(与.gitignore文件互补来记录仓库中未被追踪的文件)	
					|-- objects/			--> 保存所有数据内容的文件
					|-- refs/				--> 保存分支指针信息的文件
					|-- config				--> 仅对当前仓库有效的配置文件
					|-- description			--> 仅供GitWeb程序使用
					|-- HEAD				--> 保存当前分支指针信息的文件
					|-- index				--> 保存暂存区信息的文件
		6) Git中生成一个仓库有2种途径:a) 本地初始化空仓库,然后添加被追踪的文件；b) 直接"克隆"一个远程仓库至本地；
	
	· Git的环境配置
		Git中使用"gitconfig"文件配置环境,也可以使用命令"动态配置":
			# 根据配置范围内它分为3个级别并对应3个不同的目录；
			# 就近原则:对同一配置项,配置范围小的文件会覆盖配置范围大的
			/usr/local/etc/gitconfig 	-> 系统级配置文件(适用于所有用户的所有仓库配置)
			~/.gitconfig 				-> 用户级配置文件(适用于当前用户的所有仓库配置)
			仓库目录/.git/config 	  	 -> 仓库级配置文件(适用于当前仓库的配置)

		Git中每次提交都需要申明"用户名"和"邮箱地址":
			# 若命令行操作附带--global选项则表示全局申明,即仅需一次；
			# 若想针对不同的项目使用不同的申明,则在对应项目目录下使用不附带--global的申明；
			git config [--global] user.name "用户名"
			git config [--global] user.email 邮箱地址
		
		Git中其他的配置声明:
			# 修改Git中需要文本输入时默认使用的编辑器
			git config [--global] core.editor 文本编辑器名
			# 为原生的Git命令自定义合适的别名
			git config --global alias.别名 命令名

		Git中审查当前的已配置项:
			# 如下的命令行操作结果中可能有重复的变量名,这是从不同范围的config文件中读取的结果,而生效的配置项是同名中的最后一个；
			git config --list

			# 如下的命令行操作可以查看指定的配置项
			git config <某配置名>

		Git中配置无需纳入版本控制的文件(例如,log文件、临时文件等)
			1) 新建.gitignore文件
				touch .gitignore  
			
			2) 使用glob模式编写内容(glob模式,即简化的shell正则)
				· 所有以"#"开头的行或者是空行均为注释
				· 所有匹配glob模式的文件都会被版本控制忽略
					以"/"开头	只在当前目录下匹配,防止到子目录下递归匹配
					以"/"结尾	匹配前文所术目录下的所有文件
					"**"       匹配0个或多个中间目录

					"*"	       匹配0或多个任意字符
					?		   匹配任意1个字符
					[...]	   匹配任意1个括号内的字符
					[.-..]     匹配"."到".."之间的任意1个字符
					!...       匹配"..."以外的所有文件或目录
					
	· Git的分支系统
		Git的分支系统主要由"提交对象"、"分支指针"和"当前分支指针"组成:
			1) 提交对象
				· 每次提交操作(即git commit命令)都会产生一个提交对象,其核心属性是"父提交对象的引用"和"树对象的引用":
					"树对象",即已暂存的文件或目录集合(即"整体快照"集合),包括所有子目录(确切地说是对应目录的SHA-1哈希算法校验和)和每个子目录下的每个文件
					(确切地说是对应文件的数据对象,即blob对象)；
					"父提交对象",即上一次提交操作产生的提交对象(若是第一次提交操作,则父提交对象的引用为空)；
				· 示意图:
							提交对象
					|----------------------|
					|    commit 大小	    |
					|      tree 树对象的引用 |
					| 	 parent 父对象的引用 |
					|    author 作者名      |
					| committer 提交者名    |
					|----------------------|
			
			2) 分支指针
				· 狭义上,Git分支就是指"分支指针",创建新的分支就是创建新的"分支指针"；
				· "分支指针"指向某个提交对象,重点是指向该提交对象中包含目录校验和的"树对象"；
				· 初始化创建的分支(即默认分支)为"master"；
				· 不同的分支指针可以指向不同的提交对象,也可以指向相同的提交对象,即分支之间互相独立；
				· 示意图:						
														   分支3
														   	 |
															\|/
					提交对象a  <------  提交对象b  <------  提交对象c
										 /|\			    /|\
										  |				     |
										分支2			   master
			3) 当前分支指针
				· 为标记当前使用的分支,需要额外借助名为"head"的指针,它指向哪个"分支指针",哪个就是当前分支,因此切换分支仅仅是简单地改变"head"指针而已；
				· 示意图:
														   分支3
														   	 |
															\|/
					提交对象a  <------  提交对象b  <------  提交对象c
										 /|\			    /|\
										  |				     |
										分支2			   master
														    /|\
															 |
														    head
		
		Git的分支合并
			1) 若当前分支与待合并分支属于"上下游"关系,则合并时将当前分支的"分支指针"向前移动至待合并分支处即可；
			2) git merge命令合并:若当前分支与待合并分支属于"分叉"关系,则合并时Git会将"当前分支"、"待合并分支"和"分叉前的最后快照"做三方合并(若出现冲突,会提示用户去解决),示意图如下:
				合并前:
												     当前分支
														|
								分叉前的最后快照	  	  \|/
				提交对象a  <------  提交对象b  <------  提交对象c
									 /|\
				 					  |------  提交对象d  <------  提交对象e
														 			/|\
																	 |
																  待合并分支
				==========================================================================
				合并后:
								    									  	   当前分支
																				  |
								分叉前的最后快照	  	  						    \|/
				提交对象a  <------  提交对象b  <------  提交对象c  <-------------  提交对象f
									 /|\ 										  |
									  |------  提交对象d  <------  提交对象e  <------|
														 			/|\
																	 |
																 待合并分支
			3) git rebase命令合并:若当前分支与待变基分支属于"分叉"关系,则合并时Git先找到并临时保存"当前分支"相对于"分叉前的最后快照"的差异内容,
			   然后将"当前分支"的指针指向"待变基分支",然后将保存的差异内容应用至"待变基分支",最后将重新指向后的"当前分支"指针向前移动至应用了差异内容的"待变基分支",
			   示意图如下:
				合并前:
													 当前分支
														|
								分叉前的最后快照	  	  \|/
				提交对象a  <------  提交对象b  <------  提交对象c
									 /|\
				 					  |------  提交对象d  <------  提交对象e
														 			/|\
																	 |
																  待变基分支
				==========================================================================
				合并中:
								分叉前的最后快照	  	  			当前分支			   
				提交对象a  <------  提交对象b  <------  提交对象c        |
									 /|\ 							\|/			 
									  |------  提交对象d  <------  提交对象e
														 			/|\
																	 |
																 待变基分支

								分叉前的最后快照	  	  			 当前分支			   
				提交对象a  <------  提交对象b  <------  提交对象c        |
									 /|\ 							\|/			 
									  |------  提交对象d  <------  提交对象e  <------  提交对象f
																				   	   /|\
																						|
																					待变基分支
				==========================================================================
				合并后:
								分叉前的最后快照	  	  							    当前分支			   
				提交对象a  <------  提交对象b  <------  提交对象c                           |
									 /|\ 							                   \|/			 
									  |------  提交对象d  <------  提交对象e  <------  提交对象f
																				   	   /|\
																						|
																					待变基分支

	· Git的命令行操作
		# Git基本信息
			git --version
				--> 显示当前的Git版本,形如:"git version xx.xx.xx"；

		# Git配置文件
			/usr/local/etc/gitconfig 	
				-> 系统级配置文件(适用于所有用户的所有仓库配置)
			
			~/.gitconfig 				
				-> 用户级配置文件(适用于当前用户的所有仓库配置)
			
			仓库目录/.git/config 	  	 
				-> 仓库级配置文件(适用于当前仓库的配置)
			
			git config --file 自定义配置文件路径
				--> 使用"自定义配置文件路径",而不再是变量GIT_CONFIG对应的配置文件；

			git config --list 
				--> 显示"各级配置文件"中的所有"配置项"信息(所以可能出现多个名相同但值不同的配置项)；

			git config --system key value
				--> 动态设置"系统级配置项"(若是写操作,还会将该设置写入‘系统级配置文件’中)；
					例如: git config --system user.name "John House"
			
			git config --global key value
				--> 动态设置"用户级配置项"(若是写操作,还会将该设置写入‘用户级配置文件’中)；
					例如: git config --global user.name "John House"
			
			git config --local key value
				--> 动态设置"仓库级配置项"(若是写操作,还会将该设置写入‘仓库级配置文件’中)；
					例如: git config --local user.name "John House"
					
			git config --edit [--global / --system]
				--> 打开默认编辑器修改"仓库级配置文件"；
				--> --global / --system ,即修改"用户级配置文件"或"系统级配置文件",而不再是"仓库级配置文件"；
			
		# Git核心操作
			git clone 仓库URL [本地目录] [-o 引用名] [-b 分支名]
			--> 将指定仓库克隆至"当前目录"(默认),即在本地创建一个"远程跟踪分支"origin(默认)；
				该目录就对应一个"仓库",其中包括".git目录"(对应仓库组件)和"各种文件"(对应指定仓库的数据文件)；
				该命令是一条组合命令,它等价于:
					1) 在当前目录下创建新目录并切换至该目录
					2) 执行"git init"命令初始化仓库
					3) 执行"git remote add origin 仓库URL"命令获取指定仓库
					4) 执行"git fetch origin"命令将指定仓库的内容抓取至本地
					5) 执行"git checkout"命令。。。。。。。
			--> 仓库URL ,即待克隆的仓库地址,它可以是:
					1) http[s]://域名/仓库路径名/
					2) ssh://[用户名@]域名/仓库路径名/
					3) git://域名/仓库路径名/
					4) ftp[s]://域名/仓库路径名/
			--> 本地目录 ,即将指定仓库克隆至"本地目录"(可以是相对路径),而不再是"当前目录"；
			--> -o 引用名 ,即修改指定仓库在本地的"引用名",而不再是默认的"origin"；
			--> -b 分支名 ,即修改指定仓库在本地的"分支名",而不再是默认的"指定仓库的当前分支"；
		
		git init
			--> 将"当前目录"初始化为一个"仓库",其中仅包括".git目录"(对应仓库组件)；
				该命令仅对应初始化操作,后续可以加入文件以便对其追踪并开启版本控制；
		
		git add 文件名 [-f]
			--> 将"文件名"放入"暂存区"(若该文件未被纳入VCS,则纳入后再放入"暂存区")；
				前提:1) 执行该命令时,当前目录位于"仓库"中,2) "文件名"全都位于"仓库"中；
			--> -f ,即强制将"文件名"放入/加入"暂存区"/"VCS",即使它(们)位于exclude或.gitignore文件中；
		
		git reset 文件名
			--> 取消对"文件名"的暂存；

		git mv [-f] [-k] 源文件路径 [...] 目的文件路径
			--> 将"源文件"移动(兼重命名)至"目的文件",成功后更新"暂存区"； 
				前提:1) 执行该命令时,当前目录位于"仓库"中,2) "源文件"全都位于"仓库"中,3) "目的文件"位于"仓库"中且"存在"；
			--> -f ,即强制将"源文件"移动(兼重命名)至"目的文件",即使"目的文件"已存在；
			--> -k ,即命令执行期间,忽略产生错误的移动(错误可能来自"源文件"不存在,Git没有移动"源文件"的权限、"目的文件"已存在等等)；
			--> [...] ,即若"目的文件"是一个目录,则允许[...]移动一个或多个"源文件"； 

		git rm [-f / --cached] [-r] 文件名 ...
			--> 删除一个或多个"文件名"；
			--> -f / --cached ,即-f表示从"仓库"中物理删除一个或多个文件,--cached表示从"暂存区"中逻辑删除一个或多个文件(这些文件被视作"未被追踪的文件")；
			--> -r ,即递归性地移除；

		git status [-s]
			--> 显示"当前分支名"和"当前目录下所有文件的状态"；
			--> -s ,即仅显示状态信息,用"两个字符"表示(前一个字符表示"暂存区文件的状态",后一个字符表示"工作区文件的状态"),
					每个字符的含义是:
					! 	-> 表示"被忽略"
					? 	-> 表示"未追踪"
						-> 表示"未修改"
					M 	-> 表示"已修改"
					A	-> 表示"已加入"
					D 	-> 表示"已删除"
					R 	-> 表示"重命名"
					C 	-> 表示"复制的"
					U	-> 表示"已更新但未合并"
					
					?? -> 表示未被追踪的文件
					M  -> 表示已修改并放入暂存区的文件
					 M -> 表示已修改并未放入暂存区的文件
					MM -> 表示已修改并放入暂存区后又被修改的文件
					A  -> 表示新放入暂存区的文件

		git commit [-a] [--amend] [-m "提交说明" -m ...]
			--> 提交"暂存区"的文件(即构建"整体快照",任何未暂存的文件只能等待下次提交)；
			--> -a ,即将纳入VCS的所有文件暂存后提交,包括"已修改"和"已删除"的；
			--> --amend ,即修正上一次提交,换言之,上一次提交作废,并且从上一次提交至今,执行的其他操作(例如,将新的文件放入暂存区等)都将随本次提交生效；
			--> [-m ...],即附上本次提交的说明,允许存在多个"-m ...",它们最终会被拼接成完整的提交说明；
					若省略"-m ...",则Git会打开变量core.editor对应的"文本编辑器"供用户输入提交说明；
					提交说明模板:
						修改的摘要
						(空行)
						修改的详情介绍 + 介绍较多时必要的换行
						(空行)
							-/* 分点叙述的内容(前缀可以是"-"或"*")
							(空行)
							-/* 分点叙述的内容(前缀可以是"-"或"*")
							(空行)
							-/* 分点叙述的内容(前缀可以是"-"或"*")
							(空行)
		
		git tag [-l "标签模板"] [标签名 / -a 标签名 [-m "标签说明"]] [提交对象的部分或完整校验和]
			--> 显示所有的标签；Git中的标签分为"轻量标签"(lightweight)和"附注标签"(annotated):
				轻量标签,即对应提交对象的引用(永远不会改变)；
				附注标签,即包含各种额外信息的完整对象(推荐)；
			--> -l "标签模板" ,即显示匹配模板的标签；
			--> [标签名...] ,即打上"轻量标签"或"附注标签"(带-a,还可以选择性地附上标签说明)；
			--> [提交对象的部分或完整校验和] ,即为之前的提交补上标签(需指定[标签名...])；
			
		git stash [subcmd [...]]
			--> 临时储存当前工作区和暂存区的状态(该操作会撤销所有的修改、删除暂存区的所有文件,即回滚至最近一次的提交状态)；
				栈存名形如:stash@{n},最新的栈存保存在refs/stash文件中,早一点的则保存在该文件的回滚流(即reflog)中；
			--> subcmd ,即该操作的子命令,常见的有(全称):
					git stash list 
						->  显示当前的所有'栈存'；
							若栈存设有对应的说明,则形如: stash@{n}: On 分支名: 栈存说明
							若栈存没有对应的说明,则形如: stash@{n}: WIP on 分支名: 提交对象哈希值 提交对象说明
					
					git stash push 
						->  将所有的修改储存至一个新'栈存'(同时撤销所有的修改、删除暂存区的所有文件,即回滚至最近一次的提交状态)
							-m "msg"		,即为新'栈存'附上说明内容；
							-k 				,即已暂存的文件原样保留(不会被删除)；
							-u 				,即未被追踪的文件也被储存至新'栈存'(同时会因回滚而被全部清除)； 
							filename ... 	,即只将一个或多个指定文件储存至新'栈存'(同时根据文件原状态或撤销修改,或被删除)；
				
					git stash apply [--index] [栈存名/栈存说明]
						->  将最新栈存中的工作区应用至当前工作区；
							--index ,即同时应用最新栈存中的暂存区；
					git stash pop [--index] [栈存名] 
						->  同git stash apply,但该操作额外从栈存队列中删除该栈存；
					
					git drop [栈存名]
						->  清除最新的栈存(或指定栈存)；
					git stash clear
						->  清除所有'栈存'；
					
					git stash show [栈存名]
						->  显示最新栈存(或指定栈存)的储存内容与回滚后的内容之间的区别；
					
					git stash create 
						->  创建一个栈存(即提交对象)并返回提交对象的名字,但不储存至refs命名空间；该操作多用于脚本中；
					git stash store
						->  将一个(git stash create创建的)栈存储存至refs命名空间；该操作多用于脚本中；

		git branch [-a] [-r] [--list "模板"] [分支名 / -d 分支名]
			--> 显示当前目录下的所有分支信息("*"前缀对应"当前分支")；
			--> -a ,即显示当前目录下的所有分支和纳入VCS的所有远程分支信息；
			--> -r ,即显示纳入VCS的所有远程分支信息；
			--> --list "模板" ,即显示符合模板的分支信息；
			--> 分支名 / -d 分支名 ,即"新建分支"或"删除分支"；
		
		git checkout [-b] 分支名
			--> 切换至"分支名"；
			--> -b ,即新建"分支名"并切换至它；

		git merge 待合并分支
			--> 将指定的分支合并至当前分支；

		git rebase 待变基分支
			--> 变基合并；
				注意:不要对在你的仓库外有副本的分支执行变基

		git diff [--staged/--cached]
			--> 显示当前目录下所有"未暂存"的文件的改动(与最近一次暂存的自己比较,而不是与最近一次提交的自己比较)；
			--> [--staged/--cached]选项,可以查看所有"已暂存"的文件的改动(与最近一次提交的自己比较)；

		git log [-p] [-数字] [-stat] [--pretty=格式字符串] [--graph] [--author=xx] [--committer=xx]
				[--before="xxxx-xx-xx"] [--after="xxxx-xx-xx"]
			--> 按照提交时间,从新到旧列出当前目录下所有文件的提交记录(最近的提交排在最上面)；
			--> [-p]选项,可以额外显示每次提交的内容差异,以及提交简介字符串；
			--> [-数字]选项,可以指定显示最近"数字"次的提交记录；
			--> [-stat]选项,可以额外显示每次提交的统计信息；
			--> [--pretty=格式字符串],可以按照自定义的格式显示提交记录:
					%H		提交对象(commit)的完整哈希字串
					%h		提交对象的简短哈希字串
					%T		树对象(tree)的完整哈希字串
					%t		树对象的简短哈希字串
					%P		父对象(parent)的完整哈希字串
					%p		父对象的简短哈希字串
					%an		作者(author)的名字
					%ae		作者的电子邮件地址
					%ad		作者修订日期(可以用 --date= 选项定制格式)
					%ar		作者修订日期,按多久以前的方式显示
					%cn		提交者(committer)的名字
					%ce		提交者的电子邮件地址
					%cd		提交日期
					%cr		提交日期,按多久以前的方式显示
					%s		提交简介
			--> [--graph]选项,可以额外显示分支合并信息；
			--> [--author=xx]选项,可以仅显示指定作者的提交记录；
			--> [--committer=xx]选项,可以仅显示指定提交者的提交记录；
			--> [--before="xxxx-xx-xx"]选项,可以仅显示指定时间之前的提交记录；
			--> [--after="xxxx-xx-xx"]选项,可以仅显示指定时间之后的提交记录；

		git remote [-v]
			--> 显示当前目录下所有的远程仓库信息；
			--> [-v]选项,仅显示用于读写远程仓库的"引用名",以及远程仓库对应的URL；
		
		git remote show 引用名
			--> 显示指定的远程仓库信息；
		
		git remote add 引用名 远程仓库的url
			--> 在当前目录下添加一个新的远程仓库,并为其指定便于后续操作的"引用名"(即"引用名"和"远程仓库的URL"在使用时是等价的)；
		
		git remote rename 引用名 新引用名
			--> 修改指定的远程仓库的引用名；
		
		git remote rm 引用名
			--> 移除指定的远程仓库；
		
		git fetch 引用名
			--> 获取"引用名"对应的远程仓库中的所有"新数据"至本地仓库,同时更新远程分支的"分支指针"；
				Git使用特殊引用名"origin"来对应clone操作的远程仓库；

		git pull 引用名
			--> 获取"引用名"对应的远程仓库中的所有"新数据"至本地仓库,并与当前分支合并,同时更新远程分支的"分支指针"；
				Git使用特殊引用名"origin"来对应clone操作的远程仓库；

		git push 引用名 分支名 [标签名 / --tags]
			--> 将"分支名"对应的"已提交内容"推送至"引用名"对应的远程仓库；
				注意:如果本次推送之前,其他人已经对远程仓库推送或修改,则应该先将远程仓库获取至本地后与你的工作合并,然后再执行本次推送；
			--> 标签名 / --tags ,即将指定标签或所有的标签推送至远程仓库(默认不会推送标签以便协作者共享它们)；


设计模式(待定)
=============================================

	1.定义
		设计模式,即在【代码设计】和【组织结构】方面,业界公认的【优化方案】,它们往往强调【解决问题】,而略过【实现细节】。

	2.针对对象创建的模式
		工厂模式
		-> 核心思想: 统一对象创建的入口,根据不同的实现要求和特点,在内部创建不同的对象,其过程往往涉及委托和类及方法的重绑定等。
		-> 主要优势: a) 简化创建对象的流程,便于对象的跟踪；
	                b) 将对象创建和对象适用解耦,便于代码的维护；
		-> 延伸: 抽象工厂模式
		   当使用工厂模式时,如果对象创建的入口仍然较多,则需要在上层进一步封装,以确立对象创建的核心入口；

		建造者模式
		-> 核心思想: 创建指挥类和建造类,将构造和表现分离,适用于多步骤较复杂的对象创建,必要时可以使用内部类实现链式创建。
		-> 主要优势: a) 每个步骤节点的表现要求各不相同,便于对象创建和内容表现的解耦；

		原型模式
		-> 核心思想: 借助深拷贝和浅拷贝实现任意时间节点上的副本创建。

		享元模式
		-> 核心思想: 借助共享单元实现性能和空间上的优化。

	3.针对实体关系的模式
		适配器模式
		-> 核心思想: 创建包装类,借助其魔法字典将方法或属性接口映射至实际调用的方法或属性,必要时可以使用属性拦截实现委托代理。
		-> 主要优势: a) 在不修改源代码的基础上实现实体之间的兼容；

		修饰器模式
		-> 核心思想: 借助修饰器实现动态扩展。(实现功能扩展的其他途径有:1.修改源代码,2.使用继承,3.使用组合 )
		-> 主要优势: a) 规避继承带来的静态扩展和复用性低的缺点；
	                b) 功能扩展的热插拔；

		外观模式
		-> 核心思想: 创建包装类,统一功能接口,简化客户端的操作。

		MVC模式
		-> 核心思想: 遵循关注点分离原则(SoC原则),将数据访问、业务逻辑和表示反馈等部分解耦


异常处理(完)
=============================================

	1.语法规范
		try:
			...

		except Exception/单个异常/(异常1,异常2, ...) [as 变量名]:  # "变量名"指向了前面的"Exception/单个异常/(异常1,异常2, ...)"
			...
		[except Exception/单个异常/(异常1,异常2, ...) [as 变量名]:
			...]
		[except Exception/单个异常/(异常1,异常2, ...) [as 变量名]:
			...]

		[else:
			...]

		[finally:
			...]

	2.基本说明
		a) 异常可以用作错误处理、事件通知、控制流程、特殊处理和终止行为等；
		b) 产生异常后,如果异常未被except语句捕获,则会依次向上抛出,直至顶层显式打印；
		c) 嵌套异常的执行流程,每层的finally语句一定会被执行,嵌套异常只是高级的跳转语句；
		c) try语句     用于监听是否产生异常；

           except语句  用于依次匹配对应的异常并做相应处理；
	           			  Exception           -> 表示匹配所有的异常
	           			  单个异常              -> 表示匹配指定的异常
	           			  (异常1,异常2, ...)   -> 表示匹配(...)中的任意异常

           else语句    用于未产生异常时执行的代码；

           finally语句 用于绝对执行的代码(无论异常是否产生)；

           raise语句   用于主动产生异常(raise后面跟的一定是异常类实例；即使跟的是异常类名,也会自动转换成异常类实例)；
           				  raise 异常类名 [from 其他异常类名]        -> 默认且常用的情形,from ...用于携带其他的异常(在当前异常之前抛出)
           				  raise 异常类名(value) [from 其他异常类名] -> 用于自定义异常的值(即堆栈跟踪的提示信息),from ...用于携带其他的异常(在当前异常之前抛出)
           				  raise                                 -> 用于抛出最近产生的异常

           assert语句  用于条件式产生异常(assert后面跟的表达式结果为False,则产生异常(value为堆栈跟踪的提示信息)
           				  assert 表达式, value


元类(待定)
=============================================

	1.基本概念
		a) 对象的"类型"是指这个对象是由谁创建的,"谁"创建了对象谁就是这个对象的"类型",内置函数type(...)可以返回任意对象的"类型"；
		b) 类是类型,类型也是类(前半句强调类可以创建对象,后半句强调类是type子类创建的对象)；
		c) 所有未指定元类的"类对象",其"类型"都是type；所有指定了元类的"类对象",其"类型"是自己的"元类"；
        d) type是一个类型,也是一个对象(即type对象的"类型"是type),扩展c)说是type对象创建了所有未指定元类的"类对象"；
		e) 元类必须是type的子类；
		f) 声明了元类的类的子类会继承这个声明；

	2.语法糖
		a) 所有未指定元类的"类对象"在class语句声明的末尾,内部执行了以下代码:
           class A(object):
               pass
		   # 将类名进行重绑定,指向了【type对象调用后】的返回值,调用时参数的意义如下:
		     classname -> "A"即类名,superclasses -> (object, )即继承关系元组,attrdict -> {}即类的属性/方法字典,return -> 名为"A"的对象即类对象A
             A = type(classname, superclasses, attrdict)

        b) 所有指定了元类的"类对象"在class语句声明的末尾,内部执行了以下代码:
           class A(metaclass=xx):
               pass
           # 将类名进行重绑定,指向了【xx对象调用后】的返回值,调用时参数的意义同上:
             A = xx(classname, superclasses, attrdict)

        c) type对象调用的本质
           调用type对象,本质上是调用type对象的"类型"(即type类型)中的__call__方法；
           而type类型的__call__方法中定义了:
               type.__new__(cls, clsname, superclasses, attrdict)    -> 负责创建对象
               type.__init__(cls, classname, superclasses, attrdict) -> 负责初始化对象

           举一反三,调用xx对象,本质上是调用xx对象的"类型"中的__call__方法；

           举一反三,type/xx(),只是因为type/xx是对象,所以它们被调用会转向调用__call__方法；
                              如果type/xx是函数或其他,则它们会调用函数；
                              本质上是对【可调用对象】的调用；


魔法属性/方法(待定)
=============================================

	__dict__ --> 通过字典形式储存了类对象或实例对象的所有属性,
			     是函数dir(类对象或实例对象)返回值(列表)的子集

	__slots__ --> 通过列表形式储存了实例对象的所有可用属性(无法动态添加),
	              同时,在实例化过程中阻止了(实例对象的)__dict__属性的创建
	              原理上,__slots__属性类似于类属性,而每个实例对象都存在一个__dict__属性,
	              这样减少了内存消耗,实例化的性能也得到了提升

	__new__(cls, [...]) --> 类实例化时,类对象最先调用的方法
					 --> cls指类名,...指传给__init__方法的参数

	__init__(self, [...]) --> 类实例化时,类对象紧接着调用的方法
					     --> self指刚__new__出来的实例对象,...指传给实例对象的参数

	__del__(self) --> 实例对象被垃圾回收(GC)时调用的方法
				  --> self指实例对象

	__call__(self) --> 实例对象直接被调用时调用的方法
	               --> self指实例对象

	__str__(self) --> 实例对象直接被打印时调用的方法,以友好方式显示,适配终端环境
				  --> self指实例对象
	__repr__(self) --> 实例对象直接被打印时调用的方法,以非友好方式显示,适配所有环境
				   --> self指实例对象

	__getattr__(self, name) --> 实例对象调用某个属性,属性不存在时调用的方法
	                       --> self指实例对象,name指属性名

	__getattribute__(self, name) --> 实例对象调用某个属性,属性存在时调用的方法
	     						--> self指实例对象,name指属性名

	__setattr__(self, name, value) --> 实例对象修改某个属性,属性存在时调用的方法
								 --> self指实例对象,name指属性名,value指新值

	__delattr__(self, name) --> 实例对象删除某个属性,属性存在时调用的方法
						   --> self指实例对象,name指属性名


迭代器和生成器(完)
=============================================

	1) 可迭代对象
		非严格地说,"可迭代对象"和"迭代器对象"的概念可以通用；
		
		严格地说,"可迭代对象"是支持"迭代协议"(实现了__iter__()方法,该方法返回一个"迭代器对象")或者"序列协议"(实现了__getitem__()方法)的集合类对象；
		更通俗地讲,"可迭代对象"是能够作为内置函数iter()第一个参数的对象；
	
	2) 迭代器对象
		"迭代器对象",是实现了__iter__()方法(该方法与上文的__iter__()方法在层次上有所不同,该方法返回"迭代器对象"自身,作用于"for ... in声明")
		和__next__()方法(该方法返回下一个值,作用于"迭代协议")的对象；
		
		"迭代协议",是指"对于具有__next__()方法的对象,在每次调用__next__()方法后都会返回一个值,当无值可以返回时就会抛出StopIteration异常"的约定；

		"iter(...)",是一个内置函数,它会返回第一个参数(即某个"可迭代对象")所对应的"迭代器对象",
		这个"迭代器对象"是单迭代器类型(迭代位置共享)还是多迭代器类型(迭代位置不共享),取决于它是不是"参数对象"自身(若是,则为单迭代器类型)。
		可以确定的是,生成器对象一定是单迭代器类型；
	
	3) 生成器对象
		"生成器对象",是便捷实现了__iter__()方法和__next__()方法的对象,因此它肯定是"迭代器对象"；
		
		"生成器对象",分为"生成器表达式对象"和"生成器函数对象"；
			a) 生成器表达式,必须用"("和")"包裹,形如: 
				(...)
			b) 生成器函数,必须内含yield关键字,形如: 
				def func(...): 
					...
					yield xx
					...

		"生成器对象",具有.send(value) / .throw(type[, value[, traceback]])两个流程控制方法(注意:如果有"子生成器",则这两个方法优先作用于"子生成器")；
			.send(...)方法,将value赋值给"yield ..."表达式,然后返回生成器对象中的下一个值(返回值的前提是: 赋值操作正常完成)
			.throw(...)方法,将type异常传进生成器对象,并在它当前的暂停处抛出,然后返回生成器对象中的下一个值
			(返回值的前提是: 生成器对象中有异常捕获处理或没有其他的异常抛出,否则会直接抛出传进去的type异常)
		
		"生成器对象",必须yield一个值(return值都不行),否则抛出StopIteration异常；
		
		"生成器对象",可以通过"next(生成器对象) / 生成器对象.__next__() / 生成器对象.send(None/value)"等方法来启动一次
		(其中,.send()方法首次启动生成器时必须传入None)；
		
		生成器函数中,可以有多个"yield xx"表达式,也可以通过"yield from 子生成器函数"表达式来嵌套其他的生成器函数；
		
		生成器函数中,"yield xx"表达式的值默认为None,可以通过"生成器对象.send(value)"来给"yield xx"表达式赋值,等价于"value = yield xx"；
		
		生成器函数中,"yield from 其他生成器函数"表达式的值默认为None,可以通过"其他生成器函数的return值"来给"yield from 子生成器函数"表达式赋值,
		等价于"return值 = yield from 子生成器函数"；


模块分发(完)
=============================================

	1.准备模块包(如果想构建"命名空间包",则无需在包目录下添加__init__.py)

	2.创建setup.py(在模块包的同级目录下,用于设置模块包的相关信息)
		from distutils.core import setup

		setup(
			name = "xx", 
			version = "xx", 
			author = "xx", 
			author_email = "xx", 
			maintainer = "xx", 
			maintainer_email = "xx", 
			url = "xx", 
			download_url = "xx", 
			packages = ["xx", "xx.x", ...], 
			py_modules = ["xx", "xx.x", ...]
		)

	3.创建MANIFEST.in(在模块包的同级目录下,用于设置包含在该模块包中的非源码文件)
		include *.xx 			--> 希望包含所有的(即*)后缀名为xx的文件 		--> 一般有README.txt
		recursive-include xxx 	--> 希望包含xxx目录下的所有文件(即递归包含)	--> 一般有Doc目录,Example目录

	4.在终端中进入模块包的同级目录,并执行:
		python3 setup.py sdist  --> python 3.x
		python setup.py sdist   --> python 2.x

	5.结果会根据不同的操作平台生成不同格式的压缩文件
		将该文件上传即可


Built-In(完)
=============================================

	abs(数字)
		--> ctype: 数字,即返回传入数字(整数/浮点数/复数)的绝对值

	ord("字符")
		--> ctype: 十进制整数,即返回字符所对应的Unicode数字

	chr(十进制整数)
		--> ctype: 字符,即返回十进制整数所对应的Unicode字符

	all(iterable)
		--> ctype: True/False ,即若可迭代对象的真假值全为True,则返回True；否则返回False
	                           特例:若可迭代对象为空,则返回True；

	any(iterable)
		--> ctype: True/False ,即若可迭代对象的真假值至少一个为True,则返回True；否则返回False

	ascii(对象)
		--> ctype: 调用对象的repr()方法并返回其结果,若结果中包含非Ascii字符,则使用\x, \u或\U字符表示；

	str(对象)
	str(字节对象, encoding="UTF-8", errors="strict")
		--> ctype: 字符串 ,即调用对象的__str__()方法,如果对象没有__str__()方法,则调用__repr__()方法,如果也没有,则返回""空字符串；
		  				  将字节对象按照encoding解码成字符串,如果遇到解码格式错误,则按照errors参数操作；

	bytes("字符串"[, encoding[, errors]])
		--> ctype: 字节对象,即将字符串按照指定编码编码成字节对象；若出现编码格式错误,则按照errors参数操作；

	bin(十进制整数)
		--> ctype: 字符串,即将十进制整数换算成二进制,并以字符串的形式(保留符号)返回,形如:"0baaa"或"-0baaa"

	oct(十进制整数)
		--> ctype: 字符串,即将十进制整数换算成八进制,并以字符串的形式(保留符号)返回,形如:"0oaaa"或"-0oaaa"

	hex(十进制整数)
		--> ctype: 字符串,即将十进制整数换算成十六进制,并以字符串的形式(保留符号)返回,形如:"0xaaa"或"-0xaaa"

	int(x[, base=10])
		--> ctype: 十进制整数
		--> x ,若x为十进制整数或浮点数,则返回十进制整数(对于浮点数,永远舍去小数部分)；
		       若x为字符串,则将x视作字符串形式的base进制数,并将其值转换成十进制后返回；
		--> base ,默认将x视作字符串形式的十进制整数；若x是字符串形式的其他进制整数,则需要声明该进制是什么,例如:base=2, 8, 16

	bool([对象])
		--> ctype: True/False,即返回对象的真假值；若不传参数,则返回False；bool是int的子类；

	callable(对象)
		--> ctype: True/False,即检查对象是否可被调用；若可被调用,则返回True(但实际调用时可能失败)；否则返回False；

	hasattr(对象, "属性名")
		--> ctype: True/False,即检查对象是否具有指定的属性

	delattr(对象, "属性名")
		--> ctype: None,即删除对象的指定属性,等价于del 对象.属性名

	getattr(对象, "属性名"[, default])
		--> ctype: 属性值/default值/异常,即返回对象的指定属性；若该属性不存在,则返回default值；若default值未设置,则raise AttributeError异常；

	setattr(对象, "属性名",属性值)
		--> 添加某个对象的某个属性,值为xxx

	dict(mapping/iterable, **kwargs)
		--> ctype: 字典,即将映射对象a=b, c=d, ...或可迭代对象[(a, b), (c, d), ...]转换成字典对象；
		--> 类似的,list() tuple() set()

	dir(对象)
		--> ctype: 内嵌字符串列表,即返回对象中所有的属性名(按照a-z的顺序排序)

	divmod(a, b)
		--> ctype: 元组,即返回a除以b的除数及余数,形如(a//b, a%b)
		--> 真除法"/"一定返回浮点数；
		    地板除"//",只要2个数有一个是浮点数,就返回浮点数；
		    求余"%",只要2个数有一个是浮点数,就返回浮点数；

	id(对象)
		--> ctype: 整数,即返回某个对象在内存中的物理地址,即identity值

	input([提示字符])
		--> ctype: 字符串,即在控制台打印出提示字符后,接收用户输入的值

	isinstance(对象,类名)
		--> ctype: True/False,即若某个对象是某个类的实例,则返回True；否则返回False
		--> 类名 ,可以是int/float/str/list/tuple/dict/set 或者 (类名,类名, ...)

	issubclass(类名A,类名B)
		--> ctype: True/False,即若类名A是类名B或类名B的子类,则返回True；否则返回False

	iter(iterable/callable[, sentinel])
		--> ctype: 迭代器对象,即将对象包装成迭代器对象并返回；
		           若iter()方法只有1个参数,则第一个参数必须是iterable；
		--> sentinel ,即StopIteration异常的标志,仅限于iter()方法提供了第二个参数(即sentinel参数)的情况；
		              这种情况下,第一个参数必须是callable；
		              本质上,返回的迭代器对象每次调用__next__()方法时,会去调用callable(不带任何参数)并将结果值返回(作为迭代的结果)；
		              若该结果值为sentinel参数值,则raise 即StopIteration异常,标志着迭代结束；

	open(file, mode="r", buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)
		--> ctype: 文件对象,即如果文件无法打开,raise OSError异常；
		--> file ,类路径对象,即指定文件的路径(绝对路径或当前的相对路径)
		--> mode ,打开模式,即"rt"  --> 文本(默认)只读(默认)
							"r+t" --> 文本读写
							"rb"  --> 二进制只读
							"r+b" --> 二进制读写
		                    "wt"  --> 文本只写
		                    "w+t" --> 文本读写
		                    "wb"  --> 二进制只写
		                    "w+b" --> 二进制读写
		                    "xt"  --> 文本新建(若文件已存在,则打开失败)
		                    "xb"  --> 二进制新建
		                    "at"  --> 文本追加
		                    "ab"  --> 二进制追加
		--> buffering ,缓存方式,即0      --> 关闭缓存(仅限"b"模式)
		                         1      --> 行缓存(仅限"t"模式)
		                         正整数  --> 块缓存
		                         -1     --> 自适应缓存(针对二进制文件,开启块缓存,通常是4096或8192字节块；
		                         	                 针对文本文件,如果与终端或其他设备连接,则开启行缓存；否则开启块缓存,同二进制文件)
		--> errors ,即"strict"  --> 出现编码/解码格式错误,raise ValueError异常
	                  "ignore"  --> 出现编码/解码格式错误,忽略
	                  ...       其他不常用
	    --> newline ,换行的工作方式(仅限于"t"模式)；
	                当从流中读取(即输入)时,若newline=None,则允许流中的行以"\n" "\r" 或"\r\n"结尾,且在返还给调用者时统一转换成"\n"；
	                                    若newline="",则允许流中的行以"\n" "\r" 或"\r\n"结尾,但在返还时不会统一转换；
					当向流中写入(即输出)时,若newline=None,则所有"\n"转换成当前系统默认的行分隔符；
					                    若newline=""或"\n",则不发生任何转换；
					                    若newline=任何合法字符,则所有"\n"转换成该合法字符；

	len(序列/容器)
		--> 返回序列的长度/容器的个数；

	max(可迭代对象/多个参数)
		--> ctype: 最大值

	min(可迭代对象/多个参数)
		--> ctype: 最小值

	map(函数名,可迭代对象1,可迭代对象2, ...)
		--> ctype: 迭代器对象,即取出可迭代对象中的每个元素分别传入函数后,所有的返回结果组成的迭代器；
		                     如果有多个可迭代对象,则并行取出元素传入函数(直至元素最少的可迭代对象取完为止)

	filter(函数名,可迭代对象)
		--> ctype: 迭代器对象,即取出可迭代对象中的每个元素分别传入函数后(若函数的返回值为True,则保留传入的元素；否则抛弃),过滤后的元素组成的迭代器；

	zip(可迭代对象1,可迭代对象2, ...)
		--> ctype: 迭代器对象,即将一个或多个可迭代对象的每个元素依次取出生成的迭代器；如果有多个可迭代对象,则以元组聚合取出的元素(直至元素最少的可迭代对象取完为止)；

	enumerate(可迭代对象[, start=0])
		--> ctype: 迭代器对象,即为可迭代对象的每个元素配置一个索引,索引的开始值可以设置(默认为0)；
		                     迭代呈现的形式:(索引,迭代元素), (索引,迭代元素), ...

	import functools
	functools.reduce(函数名,可迭代对象, [初始值])
		--> ctype: 值(如果有初始值的话,初始值会被加到可迭代对象的最开始,其他正常参与函数的执行)

	range(a, b, c)
		--> ctype: range对象,a:起始, b:结束, c:间隔；range对象生成的序列是不可变的

	sorted(可迭代对象, key=None, reverse=False) --> return 新可迭代对象(从小到大),
												key表示按照什么规则排列,key=函数名:
											   (即仅接收一个参数的函数,用于从每个元素中提取一个用于比较的关键字)
												reverse表示是否方向排列

	reversed(序列)
		--> ctype: 迭代器,即将序列中的元素倒置(不是排序)后生成的迭代器

	sum(可迭代对象[, start])
		--> ctype: 总值(可迭代对象通常是数字,起始位置可省略,默认为0)

	round(number[, ndigits])
		--> ctype: 数字,即将数字四舍五入(朝最近的偶数)后返回；
		                如果ndigits省略或为None,则返回整数；其他情况,返回值与number类型相同
		--> ndigits ,即浮点数四舍五入到小数点后第几位

	pow(x, y[, z])
		--> ctype: 数字,即x的y次方然后对z取余,即(x ** y) % z

	eval("表达式", globals=None, locals=None)
		--> return 表达式的值

	print(*objects, sep=" ", end="\n", file=sys.stdout, flush=False)
		--> ctype: None,即将一个或多个对象打印至文本流,注意*objects之后的参数都是keyword-only参数；
		--> sep ,字符串,即多个对象之间的分隔符；
		--> end ,字符串,即本次打印的结尾符；
		--> file ,即具有.write(string)方法的对象；

	super([type[, object-or-type]])
		--> ctype: 代理对象,即该方法的两个参数均可省略,这种情况仅限在"类定义"中使用；
				   super()和getattr()均遵循MRO(方法解析顺序表)的顺序搜索,只不过super不搜索自己,而getattr搜索自己；
		--> type ,即类名,用于确定type自己在MRO中的索引位置,从而计算出代理对象在MRO中的索引位置(即type的索引位置+1)；
		--> object-or-type ,即type类 / type类的子类 / type的实例对象,用于确定MRO的内容；
		

import virtualenv(待定)
=============================================

	· virtualenv,是用于创建独立的Python运行环境的第三方库,终端命令"virtualenv [options] 总目录路径名"可以在指定路径(绝对路径或相对路径都行)的总目录下搭建最基本的环境,其中包括:
	  总目录
	  	|-- bin目录 			 	  // 包含各种可执行脚本文件
		|  	|-- 各种可执行文件 		  	// pythonx.x、pip、pipx.x、wheel、easy_install等等
		|
		|-- include目录  			  // 包含各种构建虚拟环境的库文件
		|	|-- pythonx.xm目录
		|		|-- 各种C语言代码
		|
		|-- lib目录 				  // 包含各种构建虚拟环境的库文件
		|	|-- pythonx.x目录
		|		|-- 各种包和模块	  	// 包含site-packages等
		|
		|-- pip-selfcheck.json文件
	  * 在虚拟Python环境中安装的第三方库,都位于"总目录/lib/pythonx.x/site-packages"下
	  * 搭建了虚拟Python环境后,使用pip等命令需要额外声明执行路径,例如:"pip3"要变成"总目录路径/bin/pip3",
	  	在.py文件的头部声明中也需要修改,例如:"#! /usr/bin/python"要变成"#! 总目录路径/bin/python"
	  * 使用(即激活)指定的虚拟Python环境,命令"source 总目录路径/bin/activate"(即通过执行activate脚本来实现),
	  	退出已进入的虚拟Python环境,命令"deactivate",
	  	移除已进入的虚拟Python环境:1. 先退出已进入的虚拟环境；2. 物理删除相关目录,例如:rm -r 总目录路径


import webbrowser(完)
=============================================
	webbrowser.open(url, new=0, autoraise=True)
		--> ctype: True,即使用'默认浏览器'展示url对应的网页；
		--> url ,即被打开的网页URL；
		--> new ,即若new=0,网页在同一窗口打开(如果可以)；若new=1,网页在新的窗口打开(如果可以)；若new=2,网页在新的标签页打开(如果可以)； 

		webbrowser.open_new(url)
			--> ctype: True,即使用'默认浏览器'在新的窗口打开url网页(如果不可以,则等效于webbrowser.open(...))
		
		webbrowser.open_new_tab(url)
			--> ctype: True,即使用'默认浏览器'在新的标签页打开url网页(如果不可以,则等效于webbrowser.open(...))
		
		webbrowser.register(name, constructor, instance=None, *, preferred=False)
			--> ctype: None,即注册新的浏览器类型及其控制器对象；
			--> name ,即新浏览器类型对应的TypeName(注册后可以用作webbrowser.get(...)中的using参数)；
			--> constructor ,即创建控制器对象的类名(若instance=None,则自动调用该参数且不传入任何参数来实例化一个控制器对象)； 
			--> instance ,即直接提供对应的控制器对象(若提供,则constructor参数可以为None)；

		webbrowser.get(using=None)
			--> ctype: controller_obj,即返回using参数对应类型的浏览器对应的控制器对象；
			--> using ,即对应浏览器类型的字符串,常见的有:
					TypeName 			ClassName
					'mozilla'		->  由Mozilla('mozilla')类创建对应的控制器对象
					'firefox'		->  由Mozilla('mozilla')类创建对应的控制器对象
					'netscape'		->  由Mozilla('netscape')类创建对应的控制器对象
					'opera'			->  由Opera()类创建对应的控制器对象
					'macosx'		->  由MacOSX('default')类创建对应的控制器对象
					'safari'		->  由MacOSX('safari')类创建对应的控制器对象
					'google-chrome'	->  由Chrome('google-chrome')类创建对应的控制器对象
					'chrome'		->  由Chrome('chrome')类创建对应的控制器对象
					'chromium'		->  由Chrome('chromium')类创建对应的控制器对象
					'windows-default'	-> 由WindowsDefault类创建对应的控制器对象

			controller_obj.open(url, new=0, autoraise=True)
				--> ctype: True,即使用controller_obj对应的浏览器展示url对应的网页；
			
			controller_obj.open_new(url)
				--> ctype: True,即使用controller_obj对应的浏览器在新的窗口打开url网页(如果不可以,则等效于webbrowser.open(...))

			controller_obj.open_new_tab(url)
				--> ctype: True,使用controller_obj对应的浏览器在新的标签页打开url网页(如果不可以,则等效于webbrowser.open(...))
			

import logging(待定)
=============================================
	logging.basicConfig(**kwargs)
		--> ctype: None,即logging系统的基本配置(也是默认配置)；
				   若没有特殊声明时,上述.debug()/.info()/..等全局函数都会自动调用该函数；
		--> kwargs ,即通过关键字参数修改logging系统的基本配置,可以是:
				filename='filepath'			->  指定日志文件的保存路径(该文件对应一个FileHandler对象)
				filemode='a'				->  指定以何种文件模式打开filename(默认为'a')
				level='WARNING'				->  指定'root'Logger对象的日志等级(默认为'WARNING')
				format='common_fmt'			->  指定普通内容的日志格式
				datefmt='date_fmt'			->  指定日期内容的日志格式
				style='%'					->  指定主体中使用何种模式的占位符(默认为'%')
				stream=StreamHandler_obj	->  指定StreamHandler对象(与filename参数互斥)
				handlers=iter_obj			->  指定一个可迭代对象,内含一个或多个Handler对象(被添加至'root'Logger对象中)

	logging.getLogger(name=None)
		--> ctype: Logger_obj,即创建名为name的Logger对象(默认返回'root'Logger对象)；
		--> name ,即string,Logger对象的名字(可以是'多层级'的,以'.'分隔)；
	
	logging.debug(msg, *args, **kwargs)
		--> ctype: None,即创建一个主体为msg、日志等级为DEBUG的消息后,交由'root'Logger对象处理；
		--> msg ,即消息的主体内容；
		--> args ,即msg中占位符对应的实际参数；
		--> kwargs ,即为新建的消息指定额外的元数据,可选关键字参数有3个:
				exc_info=False/(type, value, traceback) -> 即消息中的异常信息
				stack_info=False/True 					-> 即消息中是否添加栈追踪信息(默认为False)
				extra={'xx':'xx', ...}					-> 即消息的额外属性(多用于自定义消息对象)
	
	logging.info(msg, *args, **kwargs)
		--> ctype: None,即创建一个主体为msg、日志等级为INFO的消息后,交由'root'Logger对象处理；
	
	logging.warning(msg, *args, **kwargs)
		--> ctype: None,即创建一个主体为msg、日志等级为WARNING的消息后,交由'root'Logger对象处理；
	
	logging.error(msg, *args, **kwargs)
		--> ctype: None,即创建一个主体为msg、日志等级为ERROR的消息后,交由'root'Logger对象处理；

	logging.critical(msg, *args, **kwargs)
		--> ctype: None,即创建一个主体为msg、日志等级为CRITICAL的消息后,交由'root'Logger对象处理；
	
	logging.log(level, msg, *args, **kwargs)
		--> ctype: None,即创建一个主体为msg、日志等级为level的消息后,交由'root'Logger对象处理；
		--> level ,即表示日志等级的数字；

	logging.disable(lvl=CRITICAL)
		--> ctype: None,即将所有Logger对象的日志等级设为lvl(多用于临时性的操作)；
				   该方法不是真的修改每个Logger对象的日志等级,而是让日志等级低于lvl的Logger对象无法正常开启logging日志； 

	logging.shutdown()
		--> ctype: None,即通知logging系统有序关闭；
	
	logging系统的核心组件
	---------------------------------------------
	日志等级
		即'字符串常量'(logging系统的运行关键,核心概念有字符串)
		日志等级应用于'消息'、'记录器'、'处理器'等多个logging系统的组件中；
		它相当于门槛,当某个组件的日志等级达到或超过下一个流程组件的日志等级时,流程处理才会继续；
		字符串
			日志等级的常用表现形式就是字符串,可以是: NOTSET < DEBUG < INFO < WARNING < ERROR < CRITICAL < custom_level
									用数字表示就是: 0 		< 10 	< 20   < 30  	 < 40	 < 50 		< custom
									用语言表述就是: NOTSET	  -> 未设置日志等级
												 DEBUG 		-> 希望logging系统记录详细的信息(多用于调试)
												 INFO		-> 希望logging系统记录正常的信息
												 WARNING	-> 希望logging系统记录意料之外的具有潜在风险的信息(运转仍然正常)
												 ERROR		-> 希望logging系统记录错误的信息(部分功能无法正常运转)
												 CRITICAL	-> 希望logging系统记录严重错误的信息(无法正常运转)
	
	消息
		即'LogRecord对象'(logging系统的处理标的,核心概念有消息主体和日志等级)
		'LogRecord对象'可以被手动创建,但大多数情况下都是被'Logger对象'自动创建；
		消息主体
			每个'消息'都夹杂着描述性文本,用于具体说明'消息'的内容；
		日志等级
			见上文
		
		class logging.LogRecord(name, level, pathname, lineno, msg, args, exc_info, func=None, sinfo=None)
			--> ctype: logrecord_obj,即消息对象；
			--> name ,即Logger对象的名字,用于标识消息被哪个记录器处理；
				level ,即数字形式的日志等级；
				pathname ,即保存本次logging日志的文件的绝对路径；
				lineno ,即(在日志文件中)本次日志写入的开始行数；
				msg ,即消息主体(可以使用内置变量作为占位符)；
				args ,即消息主体中占位符对应的实际参数；
				exc_info ,即异常元组信息；
				func ,即开启本次logging日志的函数名或方法名；
				sinfo ,即栈调用信息(从当前线程的栈开始,到开启本次logging日志的地方结束)；
			
			.getMessage()
				--> ctype: string,即返回当前LogRecord对象中的主体内容；

			.asctime
				--> ctype: string,即消息的创建时间,实际输出如:'2003-07-08 16:49:45.896'
							对应占位符 %(asctime)s
			
			.created
				--> ctype: string,即消息的创建时间,实际输出如:'1533433514.268708'
							对应占位符 %(created)f
			
			.levelname 
				--> ctype: string,即消息的日志等级(字符串形式),实际输出如: 'DEBUG'/'INFO'/'WARNING'/'ERROR'/'CRITICAL'
							对应占位符 %(levelname)s
			
			.levelno
				--> ctype: int,即消息的日志等级(数字形式),实际输出如:10/20/30/40/50
							对应占位符 %(levelno)s
			
			.message 
				--> ctype: string,即消息的主体
							对应占位符 %(message)s

			.name 
				--> ctype: string,即处理该消息的Logger对象的名字
							对应占位符 %(name)s
			
			.funcName 
				--> ctype: 即开启本次logging日志的函数名或方法名
							对应占位符 %(funcName)s

			.pathname 
				--> ctype: string,即保存本次logging日志的文件的绝对路径,实际输出如:'/xx/xx/xx.ext'
							对应占位符 %(pathname)s  
			
			.filename 
				--> ctype: string,即开启本次logging日志的文件名,实际输出如: 'xx.ext'
							对应占位符 %(filename)s
			
			.module 
				--> ctype: string,即开启本次logging日志的模块名(即不含后缀的filename),实际输出如: 'xx'
							对应占位符 %(module)s

			.process 
				--> ctype: int,即开启本次logging日志的进程ID
							对应占位符 %(process)d
							
			.processName 
				--> ctype: string,即开启本次logging日志的进程名
							对应占位符 %(processName)s

			.thread 
				--> ctype: int,即开启本次logging日志的线程ID
							对应占位符 %(thread)d

			.threadName 
				--> ctype: string,即开启本次logging日志的线程名
							对应占位符 %(threadName)s

	记录器	
		即'Logger对象'(logging系统的运行入口,核心概念有名字、层级传递和有效日志等级)；
		每个'Logger对象'都对应一个日志等级,当且仅当'消息'的日志等级等于或超过'Logger对象'的日志等级时,该'Logger对象'才会接收处理该'消息'；
		'Logger对象'有3个主要作用: 1) 提供开启logging日志的接口(即.debug()/.info()/...等方法)；
								2) 配合日志等级和过滤器进行选择性logging；
								3) 通过'父子关系'将消息传递给前辈Logger对象；
		名字
			每个'Logger对象'都对应一个名字,这个名字表示谁在记录消息；
			这个名字可以是'多层级'的(即存在'父子关系'),例如: 对于foo.bar.temp这个记录器,我们说foo.bar和foo.bar.temp都是foo的后辈记录器；
		层级传递
			由于'Logger对象'具有父子关系,当后辈记录器接收处理'消息'时,它们会将'消息'一并传递给所有的前辈记录器；
			新创建的'Logger对象'默认开启这一功能；若想禁用它,可以将其.propagate属性设置为False；
		有效日志等级
			每个'Logger对象'都对应一个日志等级,但这个日志等级不一定源自自身,也可以继承自前辈记录器；
			新创建的'Logger对象'的日志等级为NOTSET；若后续不为其显示指定日志等级,则它会继承父辈记录器的日志等级(若父辈也为NOTSET,则继承自父辈的父辈,这样一直向上寻找)；
			由于root记录器是所有记录器的前辈,且root记录器的日志等级固定为WARNING,所以任何'Logger对象'都隐式具有日志等级；
		
		class logging.Logger()
			--> ctype: logger_obj,即通常不直接借助该类实例化Logger对象；
			
			.name
				--> ctype: string,即返回当前Logger对象的名字；
			
			.parent
				--> ctype: logger_obj,即返回当前Logger对象的父辈Logger对象；

			.level
				--> ctype: int,即返回当前Logger对象的日志等级(数字形式)； 

			.propagate 
				--> ctype: True/False,即是否开启当前Logger对象的层级传递(默认为True)；
			
			.setLevel(level)
				--> ctype: None,即设置当前Logger对象的日志等级；
				--> level ,即日志等级,可以是NOTSET/DEBUG/INFO/WARNING/ERROR/CRITICAL/custom_level；
			
			.getEffectiveLevel()
				--> ctype: string,即返回当前Logger对象的有效日志等级(这意味着允许通过'父子关系'返回)；
			
			.getChild(suffix)
				--> ctype: Logger_obj,即根据后缀名返回当前Logger对象的某个后辈Logger对象；
				--> suffix ,即string,例如: foo_obj.getChild('bar.zoo') == logging.getLogger('foo.bar.zoo')；
			
			.debug(msg, *args, **kwargs)
				--> ctype: None,即创建一个主体为msg、日志等级为DEBUG的消息后,交由当前Logger对象处理；
				--> msg ,即消息的主体内容；
				--> args ,即msg中占位符对应的实际参数；
				--> kwargs ,即为新建的消息指定额外的元数据,可选关键字参数有3个:
						exc_info=False/(type, value, traceback) -> 即消息中的异常信息
						stack_info=False/True 					-> 即消息中是否添加栈追踪信息(默认为False)
						extra={'xx':'xx', ...}					-> 即消息的额外属性(多用于自定义消息对象)
	
			.info(msg, *args, **kwargs)
				--> ctype: None,即创建一个主体为msg、日志等级为INFO的消息后,交由当前Logger对象处理；
			
			.warning(msg, *args, **kwargs)
				--> ctype: None,即创建一个主体为msg、日志等级为WARNING的消息后,交由当前Logger对象处理；
			
			.error(msg, *args, **kwargs)
				--> ctype: None,即创建一个主体为msg、日志等级为ERROR的消息后,交由当前Logger对象处理；

			.critical(msg, *args, **kwargs)
				--> ctype: None,即创建一个主体为msg、日志等级为CRITICAL的消息后,交由当前Logger对象处理；
			
			.log(lvl, msg, *args, **kwargs)
				--> ctype: None,即创建一个主体为msg、日志等级为lvl的消息后,交由当前Logger对象处理；
			
			.addFilter(filter)
				--> ctype: None,即向当前Logger对象中添加filter过滤器；
				--> filter ,即待添加的过滤器对象；
			
			.removeFilter(filter)
				--> ctype: None,即从当前Logger对象中移除filter过滤器；
				--> filter ,即待移除的过滤器对象；
			
			.filter(record)
				--> ctype: True/False,即将record消息放入已添加的过滤器中；若过滤器会处理它,则返回True；
				该方法将record消息轮流放入多个过滤器中,直到其中一个返回False(届时终止处理record消息)；只有都不返回False,才会将record消息交给已添加的处理器；

			.addHandler(hdlr)
				--> ctype: None,即向当前Logger对象中添加hdlr处理器；
				--> hdlr ,即待添加的处理器对象；
			
			.removeHandler(hdlr)
				--> ctype: None,即从当前Logger对象中移除hdlr处理器；
				--> hdlr ,即待移除的处理器对象；
			
			.handle(record)
				--> ctype: True/False,,即将record消息放入当前Logger对象及其前辈Logger对象的处理器中；若处理器会处理它,则返回True；
				该方法将record消息轮流放入多个处理器中,直到其中一个返回False(届时终止处理record消息)；

			.makeRecord(name, lvl, fn, lno, msg, args, exc_info, func=None, extra=None, sinfo=None)
				--> ctype: logrecord_obj,即Logger对象就是根据该工厂函数创建的消息；
	
	处理器
		即'Handler对象'(logging系统的主要执行者,其核心概念有日志等级)；
		一个'Logger对象'中允许添加多个'Handler对象',每个'Handler对象'也都对应一个日志等级,
		当且仅当'消息'的日志等级等于或超过'Handler对象'的日志等级时,该'Handler对象'才会接收处理该'消息'；
		
		class logging.Handler()
			--> ctype: handler_obj,即通常不直接借助该类实例化handler对象；
					   Handler类有许多的子类,例如: StreamHandler类、FileHandler类、SocketHandler类等等；

			...

	格式器
		即'Formatter对象'(logging系统的规范输出)

		class logging.Formatter(fmt=None, datefmt=None, style='%')
			--> ctype: formatter_obj,即返回一个格式化输出logging日志的格式器对象；
			--> fmt ,即string,消息主体中常规内容的格式(默认为'%(message)s')； 
			--> datefmt ,即string,消息主体中日期内容的格式(默认为'%Y-%m-%d %H:%M:%S,uuu' uuu是微秒部分)；

			.format(record)
				--> ctype: string,即根据实例化的格式规范输出record消息；
	
	过滤器
		即'Filter对象'(logging系统的流程控制)

		class logging.Filter(name='')
			--> ctype: filter_obj,即返回一个过滤器对象(它依附于名为name的Logger对象及其所有后辈Logger对象)；
						所谓依附,即是说该过滤器允许'name'Logger对象及其后辈Logger对象将消息放入自己；
			--> name ,即依附的Logger对象的名字(默认依附于任何Logger对象)；

			.filter(record)
				--> ctype: 0/非0,即当前Filter对象是否会处理record消息(不会处理则返回0,会处理则返回非0)；

	logging系统的配置
		logging系统有3种配置方式:
			1) 使用每个对象的配置方法显示配置；
			2) 准备一个配置文件,并使用logging.config.fileConfig(...)方法读取配置；
			3) 准备一个字典对象,并使用logging.config.dictConfig(...)方法读取字典中的配置；

		...

import unittest(待定)
=============================================

	· unittest模块,与其他语言的单元测试框架功能相同,它的设计灵感源自JUnit；
	
	· unittest模块,具有4个核心概念:
		test fixture 	-> 测试设备,即一个或多个单元测试中准备及相关清理工作所构成的运行环境；广义上,一个test case就是一个test fixture；
		test case 		-> 测试实例,即独立的测试单元,包括一个或多个测试方法；
		test suite  	-> 测试套件,即多个test case或test suite的集合；
		test runner 	-> 测试执行者,即汇总测试结果并输出给用户的组件；
	
	· test case
		· 一个test case即是一个unittest.TestCase类的实例对象,在生产环境中通常创建unittest.TestCase子类的实例对象来实现自定义的test case；
		· 为此,用户需要在unittest.TestCase子类中编写各种"test_"开头的测试方法(带self参数,属类的实例方法)),并在测试方法中调用assert***()系列方法来断言测试结果；
		示例:
			import unittest

			class MyCustomTest(unittest.TestCase):
				def setUp(self):
					...

				def test_firstMethod(self):
					self.assert***()
				
				def test_secondMethod(self):
					self.assert***()

				...
				
				def tearDown(self):
					...

			a) assert***()系列方法也属类的实例方法,通过self调用；
			b) 多个测试方法之间的调用顺序由方法名的a-z顺序决定；
			c) 若本次测试fail,则抛出附带解释信息的异常,所属的test case被视作failure,产生的其他异常被视作error；
			d) 每个测试方法运行前都会自动调用一次setUp()实例方法来进行准备工作,但若setUp()实例方法中抛出异常,则本次测试被视作存在error,测试方法不会被执行；
			e) 若setUp()实例方法成功执行,则tearDown()一定会被执行(无论测试方法是否被执行)；
			f) 每个测试方法运行前也都会调用一次__init__()实例方法；
			g) 若想跳过一个或多个测试方法,或者事先指定会failure的测试方法,可以使用装饰器(condition为条件表达式,reason为解释跳过原因的字符串):
			   @unittest.skip(reason)
			   def test_被跳过的测试方法(self):
			       ...

			   @unittest.skipIf(condition, reason)
			   def test_被跳过的测试方法(self):
			       ...

			   @unittest.skipUnless(condition, reason)
			   def test_被跳过的测试方法(self):
			       ...

			   @unittest.expectedFailure(reason)
			   def test_被跳过的测试方法(self):
			       ...
			h) 若多个测试方法之间只有参数或极小部分的区别,为了避免重复造轮子,可以使用.subTest()的上下文技术,示例:
			   class MyCustomTest(unittest.TestCase):
				   def test_even(self):
					   # 测试0~5是否全都是偶数
				   	   for i in range(0, 6):
				           with self.subTest(num=i):
						       self.assertEqual(num % 2, 0)

		· class unittest.TestCase(methodName="runTest")
			--> TestCase类,即逻辑上的测试单元,通常被其他类所继承用于自定义test case；
			--> methodName ,即每个TestCase类的实例都会执行的方法,默认为"runTest",绝大多数情况下用户无需修改该参数,也无需重写默认的runTest方法；

			.setUp()
				--> ctype: None,即定义test fixture中的准备工作,在每个测试方法执行前被调用；
					除AssertionError和SkipTest外,该方法抛出的所有异常均被视作error而不是failure；
			
			.tearDown()
				--> ctype: None,即定义test fixture中测试方法调用后的工作,当且仅当.setUp()方法成功后会被调用(换言之,即使测试方法抛出异常,
					只要.setUp()方法成功,该方法仍然会被调用),调用时机在每个测试方法执行后；
					除AssertionError和SkipTest外,该方法抛出的所有异常均被视作error而不是failure；

			.run(result=None)
				--> ctype: None,即执行测试单元,并将结果汇总至result参数指向的TestResult对象中；与直接调用TestCase类的实例对象效果一样；
				--> result ,即接收结果的TestResult对象；若该参数为None或省略,则自动调用.defaultTestResult()方法创建一个临时的TestResult对象；
			
			.debug()
				--> ctype: None,即执行测试单元,但不汇总结果(允许向用户传递测试中的异常信息)；

			.skipTest(reason)
				--> ctype: None,即在测试方法或.setUp()方法中调用该方法,用于跳过所在的测试方法；

			.subTest(msg=None, **params)
				--> ctype: None,即调用该方法形成一个上下文对象,用于进行子测试(见上文的h)；

			### assert***()系列方法,用于判断测试是否fail ###
			.assertEqual(first, second, msg=None)
			.assertNotEqual(fisrt, second, msg=None)

			.assertTrue(expr, msg=None)
			.assertFalse(expr, msg=None)

			.assertIs(first, second, msg=None)
			.assertIsNot(first, second, msg=None)

			.assertIn(first, second, msg=None)
			.assertNotIn(first, second, msg=None)

		  	.assertIsInstance(obj, cls, msg=None)
		  	.assertNotIsInstance(obj, cls, msg=None)

			.assertRaises(exception, callable, *args, **kwds)
			.assertRaises(exception, msg=None)

			.assertRaisesRegex(exception, regex, callable, *args, **kwds)
			.assertRaisesRegex(exception, regex, msg=None)

			.assertWarns(warning, callable, *args, **kwds)
			.assertWarns(warning, msg=None)

			.assertWarnsRegex(warning, regex, callable, *args, **kwds)
			.assertWarnsRegex(warning, regex, msg=None)

			.assertLogs(logger=None, level=None)

			.assertAlmostEqual(first, second, places=7, msg=None, delta=None)
			.assertNotAlmostEqual(first, second, places=7, msg=None, delta=None)

			.assertGreater(first, second, msg=None)
			.assertGreaterEqual(first, second, msg=None)¶
			
			.assertLess(first, second, msg=None)
			.assertLessEqual(first, second, msg=None)

			.assertRegex(text, regex, msg=None)
			.assertNotRegex(text, regex, msg=None)

			.assertCountEqual(first, second, msg=None)

			.assertMultiLineEqual(first, second, msg=None)

			.assertSequenceEqual(first, second, msg=None, seq_type=None)

			.assertListEqual(first, second, msg=None)
			
			.assertTupleEqual(first, second, msg=None)

			.assertDictEqual(first, second, msg=None)

			.assertSetEqual(first, second, msg=None)¶

	· test suite
		· 一个test suite即是一个unittest.TestSuite类的实例对象,在生产环境中通常会将多个test case添加至一个test suite中集中测试；
		· 允许将多个test case和一个test suite定义在同一模块中,但推荐将它们定义在不同的模块中；
		class unittest.TestSuite(tests=())
			--> TestSuite类,即多个test case或test suite的集合,一个test runner可以通过一个TestSuite类的实例对象执行多个测试
				(本质上,与迭代TestSuite类的实例对象,test runner执行每次迭代返回的测试一样)
			--> tests ,即初始化,将多个test case或test suite预先置入集合中(默认集合可以为空,稍后再添加测试)；

			.addTest(test)
				--> ctype: None,即添加一个test case或test suite；
			
			.addTests(tests)
				--> ctype: None,即添加一组(即可迭代对象)test case或test suite；

			.countTestCases()
				--> ctype: 数字,即返回当前TestSuite中添加的所有测试个数；
	
	· test runner 
		class unittest.TextTestRunner(stream=None, descriptions=True, verbosity=1, failfast=False, buffer=False, resultclass=None, warnings=None, *, tb_locals=False)
			--> 一个将测试结果输出至指定流的test runner,默认输出显示DeprecationWarning, PendingDeprecationWarning, ResourceWarning和ImportWarning等信息；
			--> stream ,即若为None,则默认输出至sys.stderr(即标准错误流)；
			--> verbosity ,即输出显示的详细程度,由简至详依次为0 < 1 < 2；

			.run(test)
				--> ctype: TextTestResult_obj(即result.TestResult的子类),即接收一个TestCase或TestSuite实例对象,执行其中的测试并将结果输出；
		
		class unittest.TestResult
			--> 即汇总测试结果的类(是unittest包中result.TestResult的快捷方式),它具有以下(常见的)属性:
			
			.errors
				--> ctype: 内嵌元组的列表,即每个内嵌的元组都表示抛出"事先未知异常"的测试,都拥有2个元素:TestCase对象 和 traceback字符串；
			
			.failures
				--> ctype: 内嵌元组的列表,即每个内嵌的元组都表示fail的测试,都拥有2个元素:TestCase对象 和 traceback字符串；
			
			.expectedFailures
				--> ctype: 内嵌元组的列表,即每个内嵌的元组都表示"事先预知要fail"的测试,都拥有2个元素:TestCase对象 和 traceback字符串；

			.skipped
				--> ctype: 内嵌元组的列表,即每个内嵌的元组都表示被跳过的测试,都拥有2个元素:TestCase对象 和 被跳过原因字符串；

	. unittest.main(module="__main__", defaultTest=None, argv=None, testRunner=None, testLoader=unittest.defaultTestLoader, exit=True, verbosity=1, failfast=None, catchbreak=None, buffer=None, warnings=None)
		--> ctype: TestProgram对象(具有.result属性,用于储存测试结果),即命令行风格的函数,用于便捷地执行测试(最简单的用法,if __name__=="__main__": unittest.main())；
		--> defaultTest ,即若"argv参数"中未声明,则该参数表示被执行的"单个测试名"或"内嵌多个测试名的可迭代对象"；
						 若"argv参数"中未声明且该参数未指定或为None,则执行"module参数"中的所有测试；
		--> argv ,即第一个元素为程序名的列表(若argv=None,则等效于argv=sys.argv)；
		--> testRunner ,即test runner类名或类的实例对象；
		--> testLoader ,即TestLoader类的实例对象,默认为defaultTestLoader类的实例对象；
		--> exit ,即若为True,则输出结果后直接退出Python,即使后面还有代码；若为False,则继续执行unittest.main(...)后面的代码；
		--> verbosity ,即结果显示的详细程度,由简至详依次为0 < 1 < 2；


import keyword(完)
=============================================
	keyword.iskeyword(s)
		--> ctype: True/False,即判断字符串s是不是Python中的关键字；

	keyword.kwlist
		--> ctype: 列表,即返回Python中的关键字列表；


import subprocess(待定)
=============================================
	subprocess模块用于创建新的进程,并连接该进程的"标准输入"管道、"标准输出"管道和"标准错误"管道,以及获取对应的退出状态。

	subprocess.run(args, *, stdin=None, input=None, stdout=None, stderr=None, 
		capture_output=False, shell=False, cwd=None, timeout=None, check=False, encoding=None, errors=None, text=None, env=None)
		--> ctype: CompletedProcess对象,即执行args参数对应的命令。官方推荐优先使用该方法,在特殊情况下,再考虑底层的Popen接口。
		--> args ,即推荐"命令参数组成的序列"(例如:内嵌字符串的列表),这样可以避免空格、转义和引号等在命令中发生歧义的问题。
				  也可以是单个"字符串",但要求shell=True或者该字符串表示的是不带任何参数的命令。
		--> * ,即表示后续的所有参数都是keyword-only参数,必须以"关键字参数"的形式传入；
		--> stdin ,即表示标准输入,它的值可以是:
				   	None 	 			表示标准输入不启用重定向
				   	file object			表示标准输入重定向至该文件对象
					fd			 		表示标准输入重定向至该文件描述符对应的文件对象
					subprocess.PIPE 	表示标准输入重定向至新建的子管道
					subprocess.DEVNULL	表示标准输入重定向至os.devnull对应的文件:POSIX系统下是"/dev/null",Windows系统下是"nul"
		--> input ,即必须是字节对象或字符串对象,等价于stdin=subprocess.PIPE,并忽略stdin参数的值；
		--> stdout ,即表示标准输出,它的可能值同stdin；
		--> stderr ,即表示标准错误,它的可能值同stdin,且额外可以是subprocess.STDOUT(即标准错误遵循标准输出的值)
		--> capture_output ,即若capture_output=True,则捕获标准输出和标准错误信息,
						    等价于stdout=subprocess.PIPE和stderr=subprocess.PIPE,并忽略stdout和stderr参数的值；
		--> shell ,即默认不使用shell执行args参数对应的命令(因为Python自己也实现了部分类shell的功能)；
				   若shell=True,则使用shell执行args参数对应的命令；
		--> cwd ,即路径字符串或类路径对象,若声明,则.run(...)方法执行前会更改当前工作目录；
		--> timeout ,即若该时间过了,执行命令的进程会被"kill"(发送KILL信号),当该进程终止后,抛出TimeoutExpired异常；
		--> check ,即若check=True,则进程的退出状态非0时,抛出CalledProcessError异常。
				   异常对象.cmd 			-> ctype: 被执行的命令内容
				   异常对象.creturncode		-> ctype: 命令的退出状态
				   异常对象.stdout			-> ctype: 标准输出信息,若未None,则.run(...)方法未开启捕获
				   异常对象.stderr			-> ctype: 标准输出信息,若未None,则.run(...)方法未开启捕获
		--> text ,即默认使用字节流操作标准输入、标准输出和标准错误；
				  若text=True,则三者以"文本模式"操作(编码格式和错误操作按照encoding参数和errors参数进行)
		
	Class subprocess.CompletedProcess
		--> 即CompletedProcess对象,.run(...)方法的返回值,该对象中储存了部分信息；

		对象.args
			--> ctype: "内嵌字符串的序列"或"字符串",即被执行的命令内容(具体取决于.run(...)中args参数的值)；
		
		对象.returncode
			--> ctype: 0/负整数,即命令的退出状态,若为0,则表示命令成功执行；若为负整数,则表示命令的实际退出状态为其绝对值；

		对象.stdout
			--> ctype: None/字节对象/字符串对象,即捕获的标准输出信息,若为None,则表示.run(...)方法未开启捕获；
		
		对象.stderr
			--> ctype: None/字节对象/字符串对象,即捕获的标准错误信息,若为None,则表示.run(...)方法未开启捕获；

	Class subprocess.Popen(args, bufsize=-1, executable=None, stdin=None, stdout=None, stderr=None, preexec_fn=None, close_fds=True, shell=False, cwd=None, env=None, universal_newlines=False, startupinfo=None, creationflags=0, restore_signals=True, start_new_session=False, pass_fds=(), *, encoding=None, errors=None, text=None)
		--> 即Popen对象(高级管道对象),实现.run(...)方法的底层核心,具有更多的灵活性,可以处理.run(...)方法处理不了的个别情况；


import asyncio(待定)
=============================================
	事件循环(即event loop)是asyncio模块的核心。
	class asyncio.AbstractEventLoop
		--> 事件循环的抽象基类(非线程安全类)
	
	class asyncio.BaseEventLoop
		--> 事件循环的具体实现类,是AbstractEventLoop的子类,但不推荐直接使用它(即在业务代码中子类化它)
	
	asyncio.get_event_loop() 	
		--> ctype: 事件循环对象/异常,即返回"当前上下文"中的"事件循环"对象(换言之,如果在某个协程中调用该方法,将返回正在运行的事件循环对象)；
				   如果"当前上下文"中没有事件循环对象,也无法按照当前的全局事件循环配置创建一个,则抛出异常；
				   该方法是asyncio.get_event_loop_policy().get_event_loop()的shortcut；

	asyncio.set_event_loop(loop)
		--> ctype: None,即将"当前上下文"中的"事件循环"对象设置为loop对象；
				   该方法是asyncio.get_event_loop_policy().set_event_loop(loop)的shortcut；
		--> loop ,即其他的"事件循环"对象；
	
	asyncio.new_event_loop()
		--> ctype: 事件循环对象,即返回新建的"事件循环"对象(按照当前的全局事件循环配置)
				   该方法是asyncio.get_event_loop_policy().new_event_loop()的shortcut；
		
		// 开启、终止和关闭事件循环
		eloop对象.run_forever()
			--> ctype: None,即开启对应的"事件循环","调用者所在线程阻塞",直到调用.stop()让该函数返回；

		eloop对象.run_until_complete(future)
			--> ctype: Future对象结果/异常,即开启对应的"事件循环",直到Future对象执行完毕；
			--> future ,即协程对象/Future对象,如果是协程对象,它会被包装成Future对象传入；

		eloop对象.stop()
			--> ctype: None,即终止对应的"事件循环"； 

		eloop对象.close()
			--> ctype: None,即关闭对应的"事件循环",该方法不可逆,会彻底结束"事件循环"(包括取消回调函数、清空队列、关闭执行器等)；

		// 检测事件循环的状态
		eloop对象.is_running()
			--> ctype: True/False,即检测对应的"事件循环"是否正在运行；

		eloop对象.is_closed()
			--> ctype: True/False,即检测对应的"事件循环"是否已经关闭；

		// 设置回调函数
		Handle对象,即class asyncio.Handle,它具有.cancel()方法,用于取消callback的调用(若callback已经被调用或取消,则.cancel()无实际意义)；

		eloop对象.call_soon(callback, *args)
			--> ctype: Handle对象,即(非线程安全地)注册回调函数,回调函数会在"事件循环轮循一遍所有的Task对象后,且该方法已返回"的前提下被调用,
					   回调函数会按照"先进先出"的注册顺序依次被"调用一次"；
			--> callback ,即回调函数,推荐使用functools.partial(callback, args1, args2, ...)函数包装callback,以便传入"位置参数"或"关键字参数"；
			--> args ,即传入callback的参数(不推荐该方式)；
	
		eloop对象.call_soon_threadsafe(callback, *args)
			--> ctype: Handle对象,即(线程安全地)注册回调函数；

		eloop对象.call_later(delay, callback, *args)
			--> ctype: Handle对象,即(在asyncio自定的计时规则下)delay秒后,调用callback；
			--> delay ,整型/浮点型,即延迟的秒数；
			--> callback ,即回调函数,推荐使用functools.partial(callback, args1, args2, ...)函数包装callback,以便传入"位置参数"或"关键字参数"；
			--> args ,即传入callback的参数(不推荐该方式)；

		eloop对象.call_at(when, callback, *args)
			--> ctype: Handle对象,即(在asyncio自定的计时规则下)when时刻,调用callback；
			--> when ,整型/浮点型,即调用callback的时刻(通常借助"eloop对象.time()"函数设置为"相对时刻")；
			--> callback ,即回调函数,推荐使用functools.partial(callback, args1, args2, ...)函数包装callback,以便传入"位置参数"或"关键字参数"；
			--> args ,即传入callback的参数(不推荐该方式)；
		
		eloop对象.time()
			--> ctype: 浮点型,即返回asyncio自定计时规则下的当前时间戳；

		** Task对象(即asyncio.Task)是Future对象(即asyncio.Future)的子类,
		   二者无本质上的区别,Task对象被注册进"事件循环"执行,Future对象是Task对象中协程对象的执行结果；
		// 创建Future对象
		eloop对象.create_future()
			--> ctype: Future对象,即asyncio.Future对象；

		// 创建并注册Task对象
		eloop对象.create_task(coro)
			--> ctype: Task对象,即将协程对象coro包装进一个Future对象,然后以Task对象的形式注册进"事件循环"并返回；

		asyncio.ensure_future(coro_or_future)
			--> ctype: Task对象,即将协程对象(被包装进Future对象)或Future对象,以Task对象的形式注册进"事件循环"并返回；
		
		asyncio.gather(*coros_or_futures, loop=None, return_exceptions=False)
			--> ctype: 内嵌Future对象结果的列表,即将一个或多个协程对象(被包装进Future对象)或Future对象,以Task对象的形式注册进"事件循环"； 
					   所有Future对象(含被包装的协程对象)共享一个事件循环；
			--> return_exceptions ,即如果为True,则任何Future对象抛出的异常都会被视作结果添加至列表中返回；
		
		asyncio.run_coroutine_threadsafe(coro, loop)
			--> ctype: Future对象,即将协程对象coro注册进指定的事件循环loop,并返回对应的Future对象；
					   * 多用于多线程的"事件循环"
		
		class asyncio.Task(coro, *, loop=None)
			--> Task对象,即asyncio.Future对象的子类对象,
						 1) 如果Task对象中的协程对象正在await一个Future对象(含被包装的协程对象),则该协程对象会被"搁置",
						    程序流"跳转"去执行其他Task对象中的协程对象,直到该协程对象await的Future对象执行完毕,才会继续执行该协程对象；
						 2) "事件循环"同一时间只能执行一个Task对象,在某个Tash对象被"搁置"时,事件循环会去执行其他的Task对象、(事件循环的)回调函数或IO操作；
						 3) 如果取消正在执行的Task对象,则在事件循环下一次回到该Task对象时,会抛出asyncio.CancelledError异常,并传递给该Task对象中的协程对象
						 	(若该协程对象正在await一个Future对象,这会导致该Future对象也被取消)；
						 4) Task对象有4种状态(本质上是Future对象有4种状态):pending(待定)、running(运行中)、finished(执行完毕)和cacelled(取消)；
			
			Task对象.cancel()
				--> ctype: None,即取消Task对象；
			
			Task对象.cancelled()
				--> ctype: True/False,即检测对应的Task对象是否被取消；
			
			Task对象.done()
				--> ctype: True/False,即检测对应的Task对象是否执行完毕；

			Task对象.result()
				--> ctype: 协程对象的结果/CancelledError异常/InvalidStateError异常,即
						   若Task对象执行完毕,则返回该Task对象中的协程对象的结果；
						   若Task对象被取消,则抛出CancelledError异常；
						   若Task对象尚未执行完毕,则抛出InvalidStateError异常；
			
			Task对象.exception()
				--> ctype: 协程对象抛出的异常/CancelledError异常/InvalidStateError异常,即
						   若Task对象中的协程对象抛出异常,则返回该异常；
						   若Task对象被取消,则返回被抛出的CancelledError异常；
						   若Task对象尚未执行完毕,则返回被抛出的InvalidStateError异常；

			Task对象.add_done_callback(callback, *, context=None)
				--> ctype: None,即向对应的Task对象添加一个回调函数callback(该回调函数会在Task对象执行完毕后执行),推荐仅在低级业务代码中使用；
						   可以使用functools.partial(callback, args1, args2, ...)函数包装callback,以便传入"位置参数"或"关键字参数",
						   但注意: 这样的话,callback函数中除了定义args1, args2, ...等参数外,还必须"在最后"额外定义一个参数(建议为"self")；

			Task对象.remove_done_callback(callback)
				--> ctype: None,即取消回调函数callback,推荐仅在低级业务代码中使用；

			Task.all_tasks(loop=None)
				--> ctype: Task对象集合,即类方法,返回事件循环loop中的所有Task对象；
				--> loop ,即默认返回当前事件循环中的所有Task对象；
			
			Task.current_task(loop=None)
				--> ctype: Task对象/None,即类方法,返回事件循环loop中正在执行的Task对象；
				--> loop ,即默认返回当前事件循环中正在执行的Task对象；
				
	协程对象
		协程对象,是调用"协程函数"后返回的对象；
		协程函数,是"async def"关键字定义的函数,或者装饰了"@asyncio.coroutine"的生成器函数；
		// 协程函数不会因被调用而执行,执行它的常见方式有两种:
			1) 在其他"正在执行"的协程函数中,作为"await表达式"的一部分,例如:await 协程函数(...)/Future对象；
			2) 被包装成Task对象或Future对象,并注册进‘正在运行’的事件循环；

		// 检测协程对象和协程函数
		asyncio.iscoroutine(obj)
			--> ctype: True/False,即检测obj是否是协程对象；
		
		asyncio.iscoroutinefunction(func)
			--> ctype: True/False,即检测func是否是协程函数；
		
		// 内置的协程对象
		asyncio.sleep(delay, result=None, *, loop=None)
			--> ctype: None/result参数,即创建一个在delay秒后执行完毕的"协程函数"；
			--> result ,即该协程执行完成后返回的值；
		
		asyncio.shield(arg, *, loop=None)
			--> ctype: None,即"保护式地"等待单个协程对象(被包装进Future对象)或Future对象arg执行完毕；
					   "保护式地",是指即使取消arg,也不会取消事件循环中该arg对应的Task,但是该函数的调用者仍会收到抛出的CancelledError异常；
			--> arg ,即单个协程对象/Future对象；

		asyncio.wait_for(fut, timeout, *, loop=None)
			--> ctype: fut结果,即等待单个协程对象(被包装进Future对象)或Future对象fut执行完毕的"协程函数",期间调用者所在线程阻塞；
			--> fut ,即单个协程对象/Future对象；
			--> timeout,即整型/浮点型,若超过timeout秒后,该函数取消fut并抛出asyncio.TimeoutError异常；若timeout=None,则一直阻塞并等待fut执行完毕；

		asyncio.wait(futures, *, loop=None, timeout=None, return_when=asyncio.ALL_COMPLETED)
			--> ctype: (执行完毕的Future对象集合,待定的Future对象集合),即等待futures中所有协程对象(被包装进Future对象)和Future对象执行完毕的"协程函数",
					   期间调用者所在线程阻塞；
			--> futures ,即序列,内嵌有协程对象或Future对象；
			--> timeout ,即整型/浮点型,超时设置(超过该时间后,该函数强制返回),默认一直等待、无强制返回；
			--> return_when ,即模块常量,设置该函数返回的条件,可以是:
							asyncio.FIRST_COMPLETED		当任何Future对象(含被包装的协程对象)执行完毕或取消后返回
							asyncio.FIRST_EXCEPTION		当任何Future对象(含被包装的协程对象)抛出异常后返回
							asyncio.ALL_COMPLETED		当所有Future对象(含被包装的协程对象)执行完毕或取消后返回
	协程队列
		协程队列,即没有配置timeout的队列；

		class asyncio.Queue(maxsize=0, *, loop=None)
			--> ctype: 先进先出异步队列的构造类；
			--> maxsize ,即队列的最大容量；若为0或负数,则表示容量无限；

		class asyncio.LifoQueue(maxsize=0, *, loop=None)
			--> ctype: 后进先出异步队列的构造类；
			--> maxsize ,即队列的最大容量；若为0或负数,则表示容量无限；

		class asyncio.PriorityQueue(maxsize=0, *, loop=None)
			--> ctype: 优先级异步队列的构造类；取出时,优先取出"最低优先级"的元素,添加时,以(优先数,元素)形式添加；
			--> maxsize ,即队列的最大容量；若为0或负数,则表示容量无限；

			async_qe.maxsize
				--> ctype: int,即类属性,返回异步队列的最大容量值；

			async_qe.qsize()
				--> ctype: int,即返回异步队列中的元素个数；

			async_qe.empty()
				--> ctype: True/False,即判断队列是否为空；

			async_qe.full()
				--> ctype: True/False,即判断队列是否满了；

			# 协程对象
			async_qe.get()
				--> ctype: item/阻塞,即从队列中取出元素,若队列为空,则阻塞；
			
			async_qe.get_nowait()
				--> ctype: item/asyncio.QueueEmpty异常,即从队列中取出元素,若队列为空,则raise asyncio.QueueEmpty；

			# 协程对象
			async_qe.put(item)
				--> ctype: None/阻塞,即向队列中添加元素,若队列已满,则阻塞；
			
			async_qe.put_nowait(item)
				--> ctype: None/asyncio.QueueFull异常,即向队列中添加元素,若队列已满,则raise asyncio.QueueFull；

			async_qe.task_done()
				--> ctype: None,即通常从异步队列中取出元素后调用,用于提示队列已完成取出的元素；

			# 协程对象
			async_qe.join()
				--> ctype: 阻塞/None,即当队列中仍有未完成的元素时,该方法阻塞；
						   每次向队列中添加元素后,未完成数 + 1；
					       每次从队列中取出元素并调用.task_done()后,未完成数 - 1；


import time(完)
=============================================
	· Epoch(即<纪元元年>)的值在各大系统平台有所差异,如Unix平台是January 1, 1970, 00:00:00 (UTC)；
	  用户可以调用time.gmtime(0)来获取当前系统的Epoch值；
	· UTC(即<世界标准时间>或<协调世界时>),为协调英文缩写CUT和法文缩写TUC最后统一为UTC,它又称为GMT(即<格林威治平均时间>)；
	· DST(即<夏令时>或<夏时制>),由各地区的法律自行规定并可以发生改变；

	time.time()
		--> ctype: 浮点数,即返回从Epoch开始至今的秒数(常说的Unix时间戳)；

	---------------------------
	time.localtime([secs])
		--> ctype: struct_time对象,即根据secs秒数返回tm_isdst属性自适应的struct_time对象；
				   若参数secs为None或省略,则自动调用time.time()方法返回secs秒数；
		
		time.gmtime([secs])
			--> ctype: struct_time对象,即根据secs秒数返回tm_isdst属性总为0的struct_time对象；
					若参数secs为None或省略,则自动调用time.time()方法返回secs秒数；
	
	time.mktime(t)
		--> ctype: 秒数,即将参数t(元组直接量或struct_time对象)转换成从Epoch开始至今的秒数；是time.localtime()的逆运算；

	---------------------------
	time.ctime([secs])
		--> ctype: 字符串,形如:"Sun Jun 20 23:21:05 1993"；
				   即将secs秒数转换成固定格式的字符串；
		--> secs ,即从Epoch至今的总秒数；若为None或省略,则自动调用time.time()返回secs秒数；

	time.asctime([t])
		--> ctype: 字符串,形如:"Sun Jun 20 23:21:05 1993"；
			       即将参数t(元组直接量或struct_time对象)转换成固定格式的字符串；
		--> t ,即表示时间的元组或struct_time对象；若省略,则自动调用time.localtime()返回t；

	---------------------------
	class time.struct_time(...)
		--> ctype: struct_time对象(继承自tuple),是一种表示时间的对象(使用命名元组来实现)；通常不直接实例化,而是通过其他方法获取；

		struct_time对象.tm_year  /  struct_time对象[0]
			--> ctype: 数字,表示年份,例如:1993；

		struct_time对象.tm_mon   /  struct_time对象[1]
			--> ctype: 数字,表示月份,范围1~12；

		struct_time对象.tm_mday  /  struct_time对象[2]
			--> ctype: 数字,表示日,范围1~31；

		struct_time对象.tm_hour  /  struct_time对象[3]
			--> ctype: 数字,表示小时,范围0~23；

		struct_time对象.tm_min   /  struct_time对象[4]
			--> ctype: 数字,表示分钟,范围0~59；

		struct_time对象.tm_sec   /  struct_time对象[5]
			--> ctype: 数字,表示秒数,范围0~61；

		struct_time对象.tm_wday  /  struct_time对象[6]
			--> ctype: 数字,表示星期,范围0~6,0为Monday；

		struct_time对象.tm_yday  /  struct_time对象[7]
			--> ctype: 数字,表示天数,范围1~366；

		struct_time对象.tm_isdst / struct_time对象[8]
			--> ctype: 0/1/-1,表示是否采用夏令时；若为0,则不采用；若为1,则采用；若为-1,则表示不知道；

	time.strptime(string[, format])
		--> ctype: struct_time对象,即将string按照format格式转换成struct_time对象并返回；
		--> string ,即待解析的字符串,形如"xx xx xx xx",数据位置与format格式一一对应；
					若它无法被解析或内容有余,则raise ValueError；
					若它内容有缺,则按照右侧默认值解析(1900, 1, 1, 0, 0, 0, 0, 1, -1),默认值顺序与struct_time对象属性对应；
		--> format ,即转换格式(详见下文),默认为"%a %b %d %H:%M:%S %Y"(形如:"Sun Jun 20 23:21:05 1993")；

	time.strftime(format[, t])
		--> ctype: 字符串,即将参数t(元组直接量或struct_time对象)按照format格式转换成字符串并返回；
		--> format ,字符串,即转换格式,可以是:
				%Y -> 四位年,形如:"2018"
				%y -> 二位年,形如:"18",范围00~99

				%B -> 当前月份英文全拼,形如:"August"
				%b -> 当前月份英文缩写,形如:"Aug"
				%m -> 月份数字,形如:"08",范围01~12

				%d -> 日,形如:"29",范围01~31
				%j -> 年计日,形如:"241",范围001~366

				%H -> 24制小时,形如:"16",范围00~23
				%I -> 12制小时,形如:"04",范围01~12

				%M -> 分钟,形如:"23",范围00~59

				%S -> 秒数,形如:"38",范围00~61

				%P -> 当地上午/下午,形如:"A",范围"A"或"P"

				%W -> 年计周数(周一为一周的第一天),形如:"35",范围00~53
				%U -> 年计周数(周日为一周的第一天),形如:"34",范围00~53

				%A -> 当地星期英文全拼,形如:"Wednesday"
				%a -> 当地星期英文缩写,形如:"Wed"
				%w -> 星期数字,形如:"0",范围0~6(0为星期天)

				%c -> 当地日期和时间,形如:"Wed Aug 29 16:23:38 2018"
				%x -> 当地日期,形如:"08/29/18"
				%X -> 当地时间,形如:"16:23:38"

				%z -> 时区偏移数字,形如:"+0800",范围-23:59~+23:59(即-HHMM~+HHMM)
				%Z -> 时区偏移字符,形如:"CST"(即中部标准时间)

				%% -> %的转义
		--> t ,即若省略,则自动调用time.localtime()返回t；

	---------------------------
	time.sleep(secs)
		--> ctype: None,即让当前线程延迟执行secs秒(实际延迟的时间可能比参数值大或小)；
		--> secs ,即延迟的秒数,数值可以是整型也可以是浮点型；


import hashlib(待定)
=============================================

	hashlib.algorithms_guaranteed
		--> ctype: set,即所有平台都支持的hash算法；
	
	hashlib.algorithms_available
		--> ctype: set,即当前解释器下支持的hash算法；

	hashlib.funcname()
		--> ctype: hash对象,即根据"funcname"返回对应算法的hash对象；
					funcname包括但不限于: 
					1) Python内置
						md5
						sha1、sha224、sha256、sha384、sha512
						blake2b、blake2s
					2) OpenSSL库中
						sha3_224、sha3_256、sha3_384、sha3_512
						shake_128、shake_256

		hash.digest_size
			--> ctype: 字节数,即hash对象结果的字节数；
		
		hash.block_size
			--> ctype: 字节数,即hash对象内部加密时使用的字节块数；
		
		hash.update(bytes)
			--> ctype: None,即将"字节数据"添加进hash对象中；
						注意: 每个hash对象都是有状态的,它会累计所有.update()的数据；
		hash.digest()
			--> ctype: bytes,即以"字节"形式返回hash对象中"累计添加"的数据的摘要；
		
		hash.hexdigest()
			--> ctype: string,即以"16进制字符串"形式返回hash对象中"累计添加"的数据的摘要；
		
		hash.copy()
			--> ctype: new-hash,即拷贝一份hash对象；


import selectors(完)
=============================================

	selectors.EVENT_READ
		--> ctype: 类常量,表示"等待读取数据的事件"；

	selectors.EVENT_WRITE
		--> ctype: 类常量,表示"等待写入数据的事件"；

	class selectors.BaseSelector
		--> ctype: 多路复用的基类,其子类有: 
				selectors.SelectSelector
				selectors.PollSelector
				selectors.EpollSelector
				selectors.DevpollSelector
				selectors.KqueueSelector

	class selectors.SelectorKey
		--> ctype: 命名元组类,即该类的实例对象sel_key,将"fileobj对象"与"fileobj对象"相关的"文件描述符"、"等待的事件"和"附带的数据"等关联起来；
		
		sel_key.fileobj
			--> ctype: fileobj对象,即"文件对象"或"socket对象"(或任何具有.fileno()方法的对象)；
		
		sel_key.fd
			--> ctype: int,即文件描述符对象；
		
		sel_key.events
			--> ctype: int,即等待的事件类型(1表示EVENT_READ,2表示EVENT_WRITE)；
		
		sel_key.data
			--> ctype: object,即附带的数据对象；

	class selectors.DefaultSelector
		--> ctype: 自适应selector类型的类,即该类会根据当前平台自动变为上述的子类之一；
				该类的实例对象sel具有以下方法；

		sel.register(fileobj, events, data=None)
			--> ctype: sel_key对象/ValueError/KeyError,即向sel对象中注册fileobj对象,并监听与fileobj对象有关的events类型事件；
					该方法将传入的"fileobj对象"和"data对象"包装成"sel_key对象"并返回,提供了操作"fileobj对象"和"附带的数据对象"的接口；
					注意: 若fileobj或events的传入值无效,则raise ValueError；若fileobj已经注册进sel对象,则raise KeyError；
			--> fileobj ,即"文件对象"或"socket对象"(或任何具有.fileno()方法的对象)；
			--> events ,即fileobj对象等待的事件类型,值为"selectors.EVENT_READ"或"selectors.EVENT_WRITE"；
			--> data ,即包装进sel_key对象中的"附带的数据对象"；
		
		sel.unregister(fileobj)
			--> ctype: None,即从sel对象中移除fileobj对象,并取消与之相关的监听；

		sel.modify(fileobj, events, data=None)
			--> ctype: sel_key对象/ValueError/KeyError,即修改sel对象中已注册的fileobj对象的相关信息；
					若fileobj或events的传入值无效,则raise ValueError；
					若fileobj未注册进sel对象,则raise KeyError；

		sel.get_key(fileobj)
			--> ctype: sel_key对象,即返回sel对象中已注册的fileobj对象对应的sel_key对象；
		
		sel.get_map()
			--> ctype: 可迭代对象,即返回记录了sel对象中已注册的fileobj对象及其sel_key对象的映射对象,
					迭代结果形如: {fileobj_1: sel_key对象, fileobj_2: sel_key对象2, ...}

		sel.select(timeout=None)
			--> ctype: 阻塞/2-list,即若sel对象中所有已注册的fileobj对象都未准备好(即未等到events事件到来),则一直阻塞；
					若声明timeout为正数,则仅阻塞timeout秒；若声明timeout为0或负数,则该方法立即返回；
					该方法的返回值,形如: [(sel_key1, events1), (sel_key2, events2), ...]；
		
		sel.close()
			--> ctype: 即关闭sel对象；


import urllib.parse as up(完)
=============================================
	up.urlparse(urlstring, scheme="", allow_fragments=True)
		--> ctype: ParseResult对象(tuple子类的实例对象),即将url字符串解析成6个显式部分；
				   urlstring的结构形如:"scheme://netloc/path；params?query#fragment"
		           结果形如:ParseResult(
		               scheme="",     -> 协议,若未声明,则为""(空)；
		               netloc="",     -> 域名,即"主机名:端口号",若未声明"//"(用于标识域名的分隔符),则为""(空)；
		               path="",       -> 文件路径,通常以"/"开头；若存在"%",它不会被转义；
		               					 若存在多个"/"或"文件后缀名",它们都会被包括在内；若未声明,则为""(空)；
		               params="",     -> 参数,若未声明"；"(用于标识参数的分割符),则为""(空)；
		               query="", 	  -> 查询字符串,"?"和"#"之间(不包含?和#)的内容,若存在多个查询参数,则"&"会被包括在内；若未声明,则为""(空)；
		               fragment="")   -> 片段标识符,即锚点,"#"之后(不包含#)的内容；若未声明,则为""(空)；
		--> scheme ,即指定urlstring中未声明协议时的默认值,默认为""(空)；
		--> allow_fragment ,即是否识别片段标识符；若为False,则结果中fragment永远为""；

		ParseResult对象.scheme / ParseResult对象[0]
			--> ctype: 字符串,即只读属性,表示协议；

		ParseResult对象.netloc / ParseResult对象[1]
			--> ctype: 字符串,即只读属性,表示域名；

		ParseResult对象.path / ParseResult对象[2]
			--> ctype: 字符串,即只读属性,表示文件路径；

		ParseResult对象.params / ParseResult对象[3]
		 	--> ctype: 字符串,即只读属性,表示参数；

		ParseResult对象.query / ParseResult对象[4]
			--> ctype: 字符串,即只读属性,表示查询字符串；

		ParseResult对象.fragment / ParseResult对象[5]
			--> ctype: 字符串,即只读属性,表示片段标识符；

	up.urlunparse(parts)
		--> ctype: 字符串,借助parts中的6个元素构造urlstring；
		--> parts ,即可迭代对象,元素顺序很重要,若无内容,必须显式指定为""(空)；
		           表示协议的元素,可以不指定":"
		           表示域名的元素,可以不指定"//"
		           表示文件路径的元素,可以不指定最开头的"/"
		           表示查询字符串的元素,可以不指定"?"
		           表示片段标识符的元素,可以不指定"#"

	up.quote(string, safe="/", encoding=None, errors=None)
		--> ctype: 字符串,即将urlstring中的非字母、数字、"_"、"."、"-"、"~"字符进行"百分号编码"；
		--> string ,可以是字符串对象,也可以是字节对象；若未字节对象,等价于up.quote_from_bytes(		    string.encode(encoding, errors), safe="/")；
		--> safe ,即除上述字符外,额外指定不需要进行编码的字符,默认"/"也不会进行"百分号编码"；
		--> encoding ,即默认为"utf-8",碰到非ASCII字符时如何处理,即指定str.encode()方法中的encoding参数；
		--> errors ,即默认为"strict",碰到非ASCII字符时如何处理,即指定str.encode()方法中的erros参数；

	up.quote_plus(string, safe="", encoding=None, errors=None)
		--> ctype: 字符串,即同上,只不过urlstring中的 (空格)会被"百分号编码"成指定符号"+"；
		                        safe参数为空,"/"也会被"百分号编码"；

	up.unquote(string, encoding="utf-8", errors="replace")
		--> ctype: 字符串,即逆操作,将"百分号编码"后的urlstring转换成原始的；
		--> string ,注意这里只能是字符串对象；

	up.unquote_plus(string, encoding="utf-8", errors="replace")
		--> ctype: 字符串,即同上只不过urlstring中的"+"会被转换成原始的 (空格)；
		--> string ,注意这里只能是字符串对象；

	up.unquote_to_bytes(string)
		--> ctype: 字节对象,即同上上；
		--> string ,可以是字符串对象,也可以是字节对象；

	up.parse_qs(qs, keep_blank_values=False, strict_parsing=False, encoding="utf-8", errors="replace")
		--> ctype: 字典,即将qs查询字符串("?"之后的内容)转换成字典；
		                形如:"kw=中国&ab=dce" ==> {"ab": ["dce"], "kw": ["中国"]}
		                     "kw=%2f&ab=dce" ==> {"ab": ["dce"], "kw": ["/"]}

	up.parse_qsl(qs, keep_blank_values=False, strict_parsing=False, encoding="utf-8", errors="replace")
		--> ctype: 列表,即将qs查询字符串("?"之后的内容)转换成内嵌元组的列表；
						形如:"kw=中国&ab=dce" ==> [("kw", "中国"), ("ab", "dce")]
		                     "kw=%2f&ab=dce" ==> [("kw", "/"), ("ab", "dce")]

	up.urlencode(query, doseq=False, safe="", encoding=None, errors=None, quote_via=quote_plus)
		--> ctype: 字符串,即将字符串字典或两两一组的字符串序列"百分号编码"成字符串；
						 形如:{"key1": "value1", "key2": "value2"}     ==> "key1=value1&key2=value2"；
						 	  [("key1", "value1"), ("key2", "value2")] ==> "key1=value1&key2=value2"
		                 若作用于POST请求,例如urlopen()方法,则将结果字符串应该被进一步转换成字节对象；


import weakref(完)
=============================================

	· 弱引用是对目标对象的一个引用,但不会增加目标对象的引用计数；
	· 弱引用的主要作用是缓存实例或者保持对大型对象的跟踪,消除循环引用带来的潜在问题；
    · 大部分的对象都能被弱引用,除了内置类型:list和dict(它们的子类可以),tuple、string和int(即使是它们的子类也不可以)等；

	weakref.ref(object[, callback])
		--> ctype: 弱引用对象,即创建object的弱引用对象；
		           注意1: 调用.ref()的返回值将返回object,若object被垃圾收集,则.ref()返回None；
		           注意2: .ref()方法可以"绑定"同一个object多次,若"绑定"时设置了callback,则按照先后顺序依次执行这些callback；
		--> callback ,即回调函数,若设置了callback且不为None,则当object被垃圾收集(即状态变为finalized)时,
		              自动调用callback函数(该函数将"弱引用对象"作为唯一的参数执行)；

	class weakref.finalize(obj, func, *args, **kwargs)
		--> ctype: 类的实例对象,即obj对象所对应的"完成对象"(可以被调用)；
				   1) 只要obj对象"未被垃圾收集"且完成对象"未被调用",则"完成对象"的状态就是alive(即活着的)；
				   2) 当完成对象是"活着的"时候,对其调用等价于调用func(*args, **kwargs)并返回结果,同时状态变成"死着的"；
				   	  当完成对象是"死着的"时候,对其调用直接返回None；
				   3) 程序结束时,所有剩余的"活着的"完成对象会被依次调用(但是,最先创建的会在最后被调用)；本质上,是看"完成对象.atexit"这个可写的属性是否为True,若为True,则被调用；
				
				完成对象.alive
					--> ctype: True/False,即完成对象是否活着
				
				完成对象.atexit
					--> ctype: True/False,即与程序结束时完成对象的调用有关,该属性可写；
				
				完成对象.peek()
					--> ctype: 元组/None,即若完成对象是"活着的",则返回(obj, func, args, kwargs)；若完成对象是"死着的",则返回None
				
				完成对象.detach()
					--> ctype: 元组/None,即若完成对象是"活着的",则将其状态变成"死着的"并返回(obj, func, args, kwargs)；若完成对象是"死着的",则返回None
								注意: 该方法可用于"手动注销"完成对象；

	weakref.WeakMethod(method)
		--> ctype: 弱引用对象,即创建实例方法method的弱引用对象；
				   注意1: 调用.WeakMethod()的返回值将返回method对象,调用该method对象等同于平时调用method方法,
				   注意2: 若method所属的实例被垃圾收集或method方法执行完毕,则.WeakMethod()返回None；

	weakref.proxy(object[, callback])
		--> ctype: object的代理对象,即通过弱引用"复制"一份object,一般用于代替原object作用于各种上下文环境中；
		--> callback ,即回调函数,若设置了callback且不为None,则当object被垃圾收集(即状态变为finalized)时,
		              自动调用callback函数(该函数将"object的代理对象"作为唯一的参数执行)；

	weakref.getweakrefs(object)
		--> ctype: 列表,即包含object所有弱引用对象和代理对象的列表；

	weakref.getweakrefcount(object)
		--> ctype: 整数,即object所有弱引用对象和代理对象的个数；

	weakref.WeakKeyDictionary([dict])
		--> ctype: 弱引用键字典,即该字典中任意key的引用计数归0后,整个键值对就会被清除；

		弱引用键字典.keyrefs()
			--> ctype: 迭代器,即返回包含弱引用键字典中所有key的迭代器；

	weakref.WeakValueDictionary([dict])
		--> ctype: 弱引用值字典,即该字典中任何value的引用计数归0后,整个键值对就会被清除；

		弱引用值字典.valuerefs()
			--> ctype: 迭代器,即返回包含弱引用值字典中所有value的迭代器；

	weakref.WeakSet([elements])
		--> ctype: 弱引用集合,即该集合中任意元素的引用计数归0后,该元素被清除；


import socket(完)
=============================================
	* 一个"主机名"可以对应多个"IP地址",但一个"IP地址"只能对应一个"主机名"
	* 一个"IP地址"可以对应多个"域名",但一个"域名"只能对应一个"IP地址"
	
	socket.getfqdn([name])
		--> ctype: 字符串,即默认返回本机的"完整主机名"； 

	socket.gethostbyname("主机名")
		--> ctype: IPv4字符串,即返回对应"主机"的IPv4地址；
	
	socket.gethostbyaddr("IP地址")
		--> ctype: (主机名,别名列表, IP地址列表),即返回对应"IP地址"的相关信息:
					主机名,即该"IP地址"对应的主机名；
					主机别名列表,即该"IP地址"对应的所有其他主机名；
					IP地址列表,即该"IP地址"对应的主机上的所有其他IP地址；

	socket.getservbyname("协议名")
		--> ctype: Int,即返回"协议名"对应的端口号；
		
	socket.getservbyport(端口号)
		--> ctype: 字符串,即返回"端口号"对应的协议名；

	socket.inet_pton(地址族, "IP地址")
		--> ctype: bytes对象,即将IPv4或IPv6地址转换成4字节(即32位)的字节对象并返回；
		--> 地址族 ,即socket模块常量,可以是:socket.AF_INET、socket.AF_INET6；

		socket.inet_aton("IP地址")
			--> ctype: bytes对象,即将"点分四组"的IPv4地址转换成4字节(即32位)的字节对象并返回；
	
	socket.inet_ntop(地址族, "字节对象")
		--> ctype: 字符串,即将4字节(即32位)的字节对象转换成IPv4或IPv6地址并返回；
		--> 地址族 ,即socket模块常量,可以是:socket.AF_INET、socket.AF_INET6；

		socket.inet_ntoa("字节对象")
			--> ctype: 字符串,即将4字节(即32位)的字节对象转换成"点分四组"的IPv4地址字符串并返回；

	socket.socket(family=socket.AF_INET, type=socket.SOCK_STREAM, proto=0, fileno=None)
		--> ctpye: 套接字对象,即创建一个无法被继承的socket对象(适用于with语句,默认为阻塞模式)；
		--> family ,即套接字的地址族,默认是AF_INET,可以是:AF_INET6, AF_UNIX, AF_CAN, AF_RDS；
		--> type ,即套接字的类型,默认是SOCK_STREAM,可以是:SOCK_DGRAM, RAW, RDM, SEQPACKET, SOCK_CLOEXEC, SOCK_NONBLOCK；
		--> fileno ,即文件描述符,若通过文件描述符创建socket对象,系统会自动检测并赋值给family、type和proto参数
					(反过来说,可以忽略fileno参数并显式赋值这些参数,从而创建socket对象)；


		socket对象.family
		socket对象.type
		socket对象.proto
			--> ctype: 字符串 ,即socket对象的只读属性:地址族、类型、协议名；


		socket对象.bind(address)
			--> ctype: None ,即将当前的socket对象绑定到指定的地址族；
			--> address ,即地址族信息:若是AF_INET  -> ("主机名"/"IP地址",端口号)
									   AF_INET6 -> ("主机名"/"IP地址",端口号, flowinfo, scopeid)

		socket对象.connect(address)
			--> ctype: None ,即远程连接指定的地址族

		socket对象.accept()
			--> ctype: (subconn, address) ,即当前的socket对象接收来自绑定地址族的连接；
			           subconn ,即用于后续.send和.recv的新socket对象
			           address ,即请求连接方的地址族(元组形式)

		socket对象.close()
			--> ctype: None ,即关闭socket对象

		socket对象.shutdown(how)
			--> ctype: None ,即关闭socket对象的连接(.close()方法会释放相关的资源,但不会立即关闭连接)

		socket对象.dup()
			--> ctype: socket对象 ,即拷贝一份当前的socket对象

		socket对象.fileno()
			--> ctype: 整数 ,即返回当前的socket对象的文件描述符(如果是-1,则表示返回失败)

		socket对象.listen([backlog])
			--> ctype: None ,即允许当前的socket对象接收连接(即开启监听)
			--> backlog ,即系统允许当前的socket对象未接收的最大连接请求数；
			             backlog一定不小于0,如果小于0,也会被调整为0；如果未指定,系统自动设置为合理值；

		socket对象.recv(bufsize[, flags])
			--> ctype: 字节对象 ,即当前的socket对象接收的数据；
			--> bufsize ,即当前的socket对象每次接收的最大字节数；

		socket对象.recvfrom(bufsize[, flags])
			--> ctype: (字节对象, address) ,即当前的socket对象接收的数据和发送方的地址族；

		socket对象.send(bytes[, flags])
			--> ctype: 字节数 ,即当前的socket对象将bytes数据发送至已连接的socket对象；
			--> bytes ,即待发送的数据；

		socket对象.sendto(bytes, flags, address)
			--> ctype: 字节数 ,即当前的socket对象将bytes数据发送至指定地址族的socket对象；
			                  注意:这意味着当前的socket对象未连接至任何socket对象；

		socket对象.setblocking(flag)
			--> ctype: None ,即设置当前的socket对象的阻塞模式；
			                 如果flag=True,当前的socket对象为阻塞模式；如果flag=False,当前的socket对象为非阻塞模式；
			           等价于 .setblocking(True)  === .settimeout(None)
			                 .setblocking(False) === .settimeout(0.0)

		socket对象.getblocking()
			--> ctype: True/False ,即检查当前的socket对象是否处于堵塞模式(如果是,返回True；否则返回False)

		socket对象.settimeout(value)
			--> ctype: None/timeout异常 ,即为当前的socket对象后续的操作设置超时时间；
		    --> value ,非负浮点数/None ,如果value为非负浮点数,则当前socket对象的后续操作在value秒内未完成,就会raise tiemout异常；
		    						   如果value为None,则当前的socket对象被设置为阻塞模式；
		    						   如果value为0.0,则当前的socket对象被设置为非阻塞模式；

		socket对象.gettimeout()
			--> ctype: 浮点数/None ,即返回当前的socket对象的超时时间,如果未设置,则返回None；


import uuid(完)
=============================================

	UUID,即通用唯一识别码,是指在某台机器上生成的数字,它保证对在同一时空中的所有机器都是唯一的；
	UUID,有version 1、version 3、version 4和version 5等四个版本；

	uuid.UUID(hex=None, bytes=None, bytes_le=None, fields=None, int=None, version=None, *, is_safe=SafeUUID.unknown)
		--> ctype: uuid对象,即创建uuid对象的标准类,但一般不通过实例化该类来创建uuid对象,而是通过其他函数；
				   实例化时必须提供hex, bytes, bytes_le, fields, int中的一个参数；
		--> hex ,即32个十六进制字符的字符串；
		--> bytes ,即16个大端字节序的字节；
		--> bytes_le ,即16个小端字节序的字节；
		--> fields ,即内嵌6个整数的元组,形如:(time_low, time_mid, time_hi_version, clock_seq_hi_variant, clock_seq_low, node)；
		--> int ,即二进制表示共128位的整数；

		uuid对象.hex
			--> ctype: 字符串,即对应当前uuid对象的32个十六进制字符的字符串；

		uuid对象.bytes
			--> ctype: 字符串,即对应当前uuid对象的16个字节的字符串；

		uuid对象.bytes_le
			--> ctype: 字符串,即对应当前uuid对象的16个字节的字符串；

		uuid对象.fields
			--> ctype: 元组,即二进制表示为(32位, 16位, 16位, 8位, 8位, 48位)；

		uuid对象.int
			--> ctype: 整数,即对应当前uuid对象的二进制表示共128位的整数；

		uuid对象.version
			--> ctype: 整数,即对应当前uuid对象的版本

	uuid.uuid1(node=None, clock_seq=None)
		--> ctype: uuid对象,即根据主机ID、序列号和当前时间创建一个version 1的uuid对象；
		--> node ,即主机ID,若未提供,则自动调用uuid.getnode()函数获取当前机器的Mac地址(二进制表示共48位的正整数)；
		--> clock_seq ,即序列号,若未提供,则自动生成一个14位的随机序列号；

	uuid.uuid4()
		--> ctype: uuid对象,即随机的uuid对象

	uuid.uuid3(namespace, name)
		--> ctype: uuid对象,即根据标识符和name参数的MD5摘要值创建一个version 3的uuid对象；
		--> namespace ,即可选: uuid.NAMESPACE_DNS  ,则name对应一个完整域名的字符串；
		                      uuid.NAMESPACE_URL  ,则name对应一个URL字符串；
		                      uuid.NAMESPACE_OID  ,则name对应一个物联网域名的字符串；
		                      uuid.NAMESPACE_X500 ,则name对应一个DER格式的X.500或文本格式的字符串；

	uuid.uuid5(namespace, name)
		--> ctype: uuid对象,即根据标识符和name参数的SHA-1摘要值创建一个version 5的uuid对象；
		--> namespace ,即可选: uuid.NAMESPACE_DNS  ,则name对应一个完整域名的字符串；
		                      uuid.NAMESPACE_URL  ,则name对应一个URL字符串；
		                      uuid.NAMESPACE_OID  ,则name对应一个物联网域名的字符串；
		                      uuid.NAMESPACE_X500 ,则name对应一个DER格式的X.500或文本格式的字符串；


import heapq(完)
=============================================

	heapq.heapify(x)
		--> ctype: None,即将列表x转换成堆队列结构,堆队列的特点:
						1) 堆队列中的每个父节点的值都小于或等于任意一个子节点的值；
						2) 堆队列中的最小元素永远是"heap[0]"(即堆顶元素)；
						3) 堆队列采用最小索引为0的结构(与Python中的表示方法契合)；
						4) 堆队列的截取方法返回最小的元素；
						5) 空列表[]也被视作一个堆队列；

	heapq.heappush(heap, item)
		--> ctype: None,即向堆队列中添加元素item,并保证结果仍是堆队列
	
	heapq.heappop(heap)
		--> ctype: 元素,即从堆队列中【截取最小】的元素,并保证结果仍是堆队列；
		                如果堆队列为空,则raise IndexError异常；
		                如果只是访问最小的元素,可以尝试"堆队列名[0]"；

	heapq.heappushpop(heap, item)
		--> ctype: 元素,即向堆队列中添加元素item,并保证结果仍是堆队列,然后截取最小的元素；

	heapq.heapreplace(heap, item)
		--> ctype: 元素,即截取最小的元素,然后向堆队列中添加元素item,并保证结果仍是堆队列；
		                因为是先截取,所以如果堆队列为空,则raise IndexError异常；

	heapq.nlargest(n, iterable, key=None)
		--> ctype: 列表,即从iterable中返回n个最大的元素；
		                如果传入了key参数,则按照key来排序出最大的n个元素；

	heapq.nsmallest(n, iterable, key=None)
		--> ctype: 列表,即从iterable中返回n个最小的元素；
					    如果传入了key参数,则按照key来排序出最小的n个元素；


import qrcode
=============================================

	· 二维码(2-dimensional bar code),又称二维条码,是一种借助特定的几何图形按一定的规律在平面上排列从而记录数据的工具；
	· 二维码按原理可以分为"堆叠式/行排式"或"矩阵式":
		"堆叠式/行排式"即一维码的延伸,常见的码制有"PDF417"、"Code 49"、"Code 16K"等；
		"矩阵式"常见的码制有"QR Code"、"Data Matrix"、"Code One"等；
	· 由于"QR Code"码制的矩阵式二维码使用的十分广泛,QR Code(即Quick Response Code,快速响应码)逐渐成为二维码的代称；
		QR Code,按照边长分为40个尺寸:version1 -> 边长21,即21 * 21的矩阵；version40 -> 边长177,即177 * 177的矩阵(尺寸每增加一级,边长增加4)；
	
	# 命令行操作
		qr "数据内容" > 二维码生成路径名.PNG
			--> 在指定路径下生成记录了"数据内容"的PNG图片；
	
	# 程序中操作
		import qrcode

		qrcode.make(data=None, **kwargs)
			--> ctype: PILImage对象,即qrcode.main.make()的快捷方式,用于生成QR Code图片,
					   本质上:1) 生成QRCode对象,2) 调用对象.add_data()方法,3) 调用对象.make_image()方法；
			--> data ,字符串,即最好是字节对象,若不是也会被内部转换；
			--> **kwargs ,可选参数,用于传入QRCode类中进行实例对象的初始化；

		qrcode.QRCode(version=None, error_correction=constants.ERROR_CORRECT_M, box_size=10, border=4, image_factory=None, mask_pattern=None)
			--> class qrcode.main.QRCode 的快捷方式,用于创建QRCode对象:
			--> version ,整型,即定义QR Code的版本,可选范围为1~40；
			--> error_correction ,即纠错等级  qrcode.constants.ERROR_CORRECT_L / 1  -> 可纠错7%码字
											qrcode.constants.ERROR_CORRECT_M / 0  -> 可纠错15%码字
											qrcode.constants.ERROR_CORRECT_Q / 3  -> 可纠错20%码字
											qrcode.constants.ERROR_CORRECT_H / 2  -> 可纠错30%码字
			--> box_size ,整型,即QR Code中每个方块的像素大小；
			--> border ,整型,即QR Code的边缘大小；
		
			.add_data(data, optimize=20)
				--> ctype: None,即向QR Code中添加数据；
				--> data ,字符串,即最好是字节对象,若不是也会被内部转换；
				--> optimize ,整型,即将data数据划分成多块,以便优化QR Code的大小；若该参数为0,则不进行优化；

			.clear()
				--> ctype: None,即重置/清除QR Code中的数据；

			.best_fit(start=None)
				--> ctype: 整型,即返回QR Code中适配当前数据且尺寸最小的version；
			
			.make_image(image_factory=None, **kwargs)
				--> ctype: PILImage对象,即默认返回PIL库的图片对象；
				--> image_factory ,若为None,则底层使用PIL库生成图片对象；
				--> **kwargs ,用于调整图片对象的可选参数(必须是以下变量名,必须是关键字参数)有:
						back_color="xx"  xx为文本内容的颜色,表示QR Code的背景色
						fill_color="xx"  xx为文本内容的颜色,表示QR Code的填充色
			
			.print_tty(out=None)
				--> ctype: None,即若out为None,则在标准输出中显示TTY颜色的QR Code；
			
			.print_ascii(out=None, tty=False, invert=False)
				--> ctype: None,即若out为None,则在标准输出中显示ASCII字符的QR Code；
				--> tty ,即是否使用TTY颜色,若为True,则强制invert也为True；
				--> invert ,即若为False(默认),则ASCII字符显示透明；若为True,则显示非透明；
			
			.get_matrix()
				--> ctype: 多维数组,即将QR Code以多维数组的形式返回,数组元素均为True/False；	


from PIL import Image(完)
=============================================

	Image.Image()
		--> ctype: Image对象 ,即创建一个Image实例对象,
		           一般很少直接调用这个方法获取Image对象,更多是使用Image对象中的各种方法；

		.filename
			--> ctype: 字符串,即返回当前的Image对象的名字

		.format
			--> ctype: 字符串/None,即返回当前的Image对象的格式(若是PIL库自己的工厂函数生成的或者其他方法生成的,则返回None)

		.mode
			--> ctype: 字符串,即返回当前的Image对象的mode

		.size
			--> ctype: (width, height),即返回当前的Image对象的尺寸(单位:像素)
		.width
		.height


		.getbbox()
			--> ctype: (左,上,右,下)即返回当前的Image对象的尺寸(用坐标表示)

		.getbands()
			--> ctype: (x, ...)即返回当前的Image对象的通道名字(有几个通道,返回几个名字)

		.getdata(band=None)
			--> ctype: 序列对象 ,即返回当前的Image对象的所有通道的像素值(使用元组保存)；
			           使用list(序列对象)使序列对象具有可读性,形如:[(r, g, b), (r, g, b), ...],这些像素值是一行接一行的显示；
			--> band ,即指定返回当前的Image对象的指定通过的像素值

		.getpixel(xy)
			--> ctype: 整数 ,即返回当前的Image对象的指定坐标处的像素值
			--> xy , (x1, y1)即指定坐标位置

		.histogram(mask=None, extrema=None)
			--> ctype: 列表 ,即统计并返回当前的Image对象的所有通道的每阶像素值的总数,例如:RGB的图片,则是[r1, ..., r256, g1, ..., g256, b1, ..., b256]
			--> mask ,即如果提供了mask,只统计mask中非0区域(而不是整个Image对象)的所有通道的每阶像素值的总数

		.crop(box=None)
			--> ctype: Image对象 ,即裁剪当前的Image对象,并返回裁剪后的Image对象
			--> box , (左,上,右,下)即设置裁剪的矩形区域

		.resize(size, resample=0, box=None)
			--> ctype: Image对象 ,即调整当前的Image对象,并返回调整后的Image对象
			--> size , (width, height)即调整后的尺寸
			--> resample , Filters对象

		.rotate(angle, resample=0, expand=0, center=None, translate=None)
			--> ctype: Image对象 ,即旋转当前的Image对象,并返回旋转后的Image对象；
			           旋转操作涉及外层图片(即原图片区域,默认为黑色,尺寸等于原图片)以及内层图片(即旋转后的图片区域)2个概念；
			--> angle ,整数 即【顺时针计算】的旋转度数
			--> resample , Filters对象
			--> expand , True/False 即旋转后内层图片可能有部分区域溢出外层图片,该参数影响溢出部分的处理；
			           若为True,则外层图片(原图片区域)自动扩展顺应内层图片(旋转后的图片)；若为False或省略,则不自动扩展顺应
			--> center , (x1, y1)即旋转的中心点,默认为当前的Image对象的中心点

		.transpose(method)
			--> ctype: Image对象,即将当前的Image对象翻转或旋转后,返回调整后的Image对象
			--> method ,即决定如何操作:PIL.Image.FLIP_LEFT_RIGHT
							         PIL.Image.FLIP_TOP_BOTTOM
							         PIL.Image.ROTATE_90
							         PIL.Image.ROTATE_180
							         PIL.Image.ROTATE_270
							         PIL.Image.TRANSPOSE
							         PIL.Image.TRANSVERSE

		.split()
			--> ctype: (通道, ...),即将当前的Image对象的所有通道分别生成一个Image对象副本,并以元组形式返回；
			           例如,RGB图片会返回(r通道的Image对象, g通道的Image对象, b通道的Image对象)

		.getchannel(channel)
			--> ctype: Image对象(mode为"L"),即将当前的Image对象的指定通道生成一个Image对象副本,并返回它
			--> channel ,即指定通道,可以是:索引形式(例如,RGB的R通道为0；也可以是:字符串形式(例如,RGBA的A通道为"A")

		.filter(filter)
			--> ctype: Image对象,即将当前的Image对象适用滤波器(特效)后,返回修改后的Image对象
			--> filter , PIL.ImageFilter.BLUR                     --> 模糊
										.GaussianBlur(radius=xx)  --> 高斯模糊(参数:模糊半径)
										.SHARPEN                  --> 锐化
			                            .CONTOUR                  --> 轮廓勾勒、去色、泛白
			                            .DETAIL 	              --> 降噪
			                            .EDGE_ENHANCE             --> 边界增强
			                            .EDGE_ENHANCE_MORE        --> 深度边界增强
			                            .SMOOTH                   --> 像素平滑
			                            .SMOOTH_MORE              --> 深度像素平滑
			                            .EMBOSS                   --> 浮雕、灰板
			                            .FIND_EDGES               --> 轮廓勾勒、黑板
			                            ...

		.copy()
			--> ctype: Image对象 ,即拷贝当前的Image对象

		.paste(im, box=None, mask=None)
			--> ctype: None ,即将im对象粘贴入当前的Image对象(im位于Image对象上层)
			--> im ,即被粘贴的Image对象 或 像素值(表示被粘贴的是纯色图片；单个像素值用于确定第一个通道的颜色；多个像素值例如RGB,则使用(r, g, b)来确定颜色)
			--> box , (x1, y1)即im对象的左上角被粘贴至指定坐标处；默认为(0, 0)；
			         (x1, Image对象)如果第2个参数是Image对象,则默认(0, 0)同时该参数对象被当做mask
			--> mask ,即遮罩对象(im将被粘贴入该遮罩对象的区域)

		.save(fp, format=None, **params)
			--> ctype: None ,即按照指定格式保存当前的Image对象
			--> fp ,字符串/文件对象,即图片名或文件对象；若是字符串,则必须声明后缀名；若是文件对象,则必须指定format参数；
			--> format ,即图片格式,支持读写的常见格式:BMP EPS GIF ICO IM JPEG PNG TIFF
			                      支持只读的常见格式:BLP PSD TGA IMT
			                      支持只写的常见格式:PALM PDF XVThumbnails

		.tobytes(encoder_name="raw", *args)
			--> ctype: 字节对象,即将当前的Image对象输出为指定编码的字节对象

		.show(title=None, command=None)
			--> ctype: None ,即显示当前的Image对象(多用于测试)

	Image.new(mode, size, color=0)
		--> ctype: Image对象 ,即创建一张图片
		--> mode ,新创建图片的模式:
		          1     1位像素,黑和白,每个字节储存1个像素
		          L     8位像素,黑和白
		          P     8位像素,使用颜色版映射至其他mode
		          RGB   24位像素,真彩色
		          RGBA  32位像素,带透明度的真彩色
		          CMYK  32位像素,颜色分离
		          YCbCr 24位像素,彩色视频格式,JPEG
		          LAB   24位像素,L - 亮度,a - 洋红至绿色的范围,b - 黄色至蓝色的范围
		          HSV   24位像素,H - 色调,S - 饱和度,V - 明度
		          I     32位有符号整数像素
		          F     32位浮点数像素
		--> size , (width, height)即用元组创建图片的尺寸
		--> color ,图片的颜色(默认黑色),参数值: 单通道模式 - 1个整数或浮点数
										      多通道模式 - 元组形式,每个通道对应1个整数或浮点数
										      标准颜色名 - 字符串

	Image.open(fp, mode="r")
		--> ctype: Image对象 ,即打开指定路径下的图片,并将其作为对象返回；若图片不存在或无法打开,则raise IOError异常
		--> fp ,路径字符串/文件对象(必须实现read(), seek()和tell()方法)/pathlib.Path对象
		--> mode ,能且只能是"r"(二进制)模式

from PIL import ImageFont(完)
=============================================

	ImageFont.load(filename)
		--> ctype: Font对象,即加载指定的位图字体文件,并返回对应的对象

	ImageFont.load_path(filename)
		--> ctype: Font对象,即加载指定路径下的位图字体文件,并返回对应的对象

	ImageFont.truetype(font=None, size=10, index=0, encoding="", layout_engine=None)
		--> ctype: Font对象,即从文件对象中加载TrueType或OpenType字体,并返回对应的对象
		--> font ,文件名或文件对象
		--> size ,字体的大小(单位:points)
		--> index ,默认使用第一个可用的字体外观
		--> encoding ,默认使用Unicode字体编码,其他有: "unic"(Unicode)
												   "symb"(Microsoft Symbol)
												   "ADOB"(Adobe Standard)
												   "ADBE"(Adobe Expert)
												   "armn"(Apple Roman)
		--> layout_engine ,使用哪个图层引擎

	ImageFont.load_default()
		--> ctyp: Font对象,加载默认的总比没有好

		.getsize(text)
			--> ctype: (width, height),即返回指定文本的宽度和高度

		.getmask(text, mode="", direction=None, features=[])
			--> ctype:

from PIL import ImageColor(完)
=============================================

	ImageColor.getrgb(color)
		--> ctype: 元组 ,即将一种颜色(字符串形式)转换成RGB模式(元组形式)；若无法转换,则raise ValueError异常
		--> color ,即标准颜色名(字符串形式)

	ImageColor.getcolor(color, mode)
		--> ctype: 元组 ,即同.getrgb()方法
		--> color ,即标准颜色名(字符串形式)
		--> mode ,即如果mode不是颜色或调色板对象,则将得到的RBG值进一步转换成灰阶值

from PIL import ImageDraw(完)
=============================================

	ImageDraw.Draw(im, mode=None)
		--> ctype: draw对象 ,即为指定的Image对象创建画笔对象(自称的)
		--> im ,即待画的Image对象
		--> mode ,即默认保留im参数中Image对象的mode,也可以指定其他的mode值

		.getfont()
			--> ctype: font对象 ,即返回当前默认的font

		.arc(xy, start, end, fill=None)
			--> ctype: None ,即画一条弧线(即某个内切圆的一部分)
			--> xy , [x1, y1, x2, y2]即通过(x1, y1)和(x2, y2)两个点确定一个矩形区域,从而构造一个内切圆；
			        写的时候,必须x1<=x2 且 y1<=y2,即约束矩形的【左上顶点】和【右下顶点】；
			--> start ,整数即弧线开始的角度(以3点钟为0度,顺时针增加,度数增加)
		    --> end ,整数即弧线结束的角度
		    --> fill ,弧线填充的颜色(遵循颜色表示法)

		.chord(xy , start, end, fill=None, outline=None)
			--> ctype: None ,即画一条弦线(即弧线的首尾用线段封闭)
			--> xy , [x1, y1, x2, y2]即通过(x1, y1)和(x2, y2)两个点确定一个矩形区域,从而构造一个内切圆；
			        写的时候,必须x1<=x2 且 y1<=y2,即约束矩形的【左上顶点】和【右下顶点】；
			--> start ,整数即弦线开始的角度(以3点钟为0度,顺时针增加,度数增加)
		    --> end ,整数即弦线结束的角度
		    --> fill ,弦线填充的颜色(遵循颜色表示法)
		    --> outline ,弦线描边的颜色(遵循颜色表示法)

	    .pieslice(xy , start, end, fill=None, outline=None)
			--> ctype: None ,即画一条弧折线(即弧线的尾点和矩形的中心用线段连接)
			--> xy , [x1, y1, x2, y2]即通过(x1, y1)和(x2, y2)两个点确定一个矩形区域,从而构造一个内切圆；
			        写的时候,必须x1<=x2 且 y1<=y2,即约束矩形的【左上顶点】和【右下顶点】；
			--> start ,整数即弧折线开始的角度(以3点钟为0度,顺时针增加,度数增加)
		    --> end ,整数即弧折线结束的角度
		    --> fill ,弧折线填充的颜色(遵循颜色表示法)
		    --> outline ,弧折线描边的颜色(遵循颜色表示法)

		.ellipse(xy, fill=None, outline=None)
			--> ctype: None ,即画一个椭圆
			--> xy , [x1, y1, x2, y2]即通过(x1, y1)和(x2, y2)两个点确定一个矩形区域,从而构造一个内切椭圆；
			        写的时候,必须x1<=x2 且 y1<=y2,即约束矩形的【左上顶点】和【右下顶点】；
		    --> fill ,椭圆填充的颜色(遵循颜色表示法)
		    --> outline ,椭圆描边的颜色(遵循颜色表示法)

		.point(xy, fill=None)
			--> ctype: None ,即画一个或多个点
			--> xy , [x1, y1, x2, y2, ...]即按照两个或多个坐标确定点的位置
			--> fill ,点填充的颜色(遵循颜色表示法)

		.line(xy, fill=None, width=0)
			--> ctype: None ,即画一条或多条线段
			--> xy , [x1, y1, x2, y2, ...]即按照两个或多个点确定线段的首尾
			--> fill ,线段填充的颜色(遵循颜色表示法)
			--> width ,线段的宽度(单位:像素)

		.polygon(xy, fill=None, outline=None)
			--> ctype: None ,即画一个多边形
			--> xy , [x1, y1, x2, y2, ...]即按照两个或多个点确定线段的首尾(自动添加首尾点之间的线段)
			--> fill ,多边形填充的颜色(遵循颜色表示法)
			--> outline ,多边形描边的颜色(遵循颜色表示法)

		.rectangle(xy, fill=None, outline=None)
			--> ctype: None ,即画一个矩形
			--> xy , [x1, y1, x2, y2]即按照两个点确定矩形区域
			--> fill ,多边形填充的颜色(遵循颜色表示法)
			--> outline ,多边形描边的颜色(遵循颜色表示法)

		.multiline_text(xy, text, fill=None, font=None, anchor=None, spacing=0, align="left", direction=None, features=None)
			--> ctype: None ,即画文字
			--> xy , [x1, y1]即文字左上角的坐标
			--> text ,字符串即被画的文本内容
			--> fill ,文本填充的颜色(遵循颜色表示法)
			--> font ,对象即ImageFont实例对象
			--> spacing ,整数即文本的行间距
			--> align ,字符串即文本的水平对齐方式:"left" "center" "right"
			--> direction ,字符串即文本的书写方向:"rtl" "ltr" "ttb" "btt"
			--> features ,列表即OpenType字体的特点

from PIL import ImageChops(完)
=============================================

	ImageChops.constant(image, value)
		--> ctype: Image对象,即根据value的灰阶值生成一个image大小的单通道对象

	ImageChops.invert(image)
		--> ctype: Image对象,即将image反相并返回修改后的Image对象

	ImageChops.darker(image1, image2)
		--> ctype: Image对象,即混合image1和image2,图层混合模式为"变暗"
		--> 公式:out = min(image1, image2)

	ImageChops.lighter(image1, image2)
		--> ctype: Image对象,即混合image1和image2,图层混合模式为"变亮"
		--> 公式:out = max(image1, image2)

	ImageChops.difference(image1, image2)
		--> ctype: Image对象,即混合image1和image2,图层混合模式为"差值"
		--> 公式:out = abs(image1 - image2)

	ImageChops.multiply(image1, image2)
		--> ctype: Image对象,即混合image1和image2,图层混合模式为"正片叠底"
		--> 公式:out = (image1 * image2) / 255

	ImageChops.add(image1, image2, scale=1.0, offset=0)
		--> ctype: Image对象,即混合image1和image2,图层混合模式为"相加"
		--> 公式:out = (image1 + image2) / scale + offset

	ImageChops.subtract(image1, image2, scale=1.0, offset=0)
		--> ctype: Image对象,即混合image1和image2,图层混合模式为"减去"
		--> 公式:out = (image1 - image2) / scale + offset

	ImageChops.screen(image1, image2)
		--> ctype: Image对象,即混合image1和image2,图层混合模式为"滤色"
		--> 公式:out = 255 - [(255 - image1) * (255 - image2) / 255]

	ImageChops.blend(image1, image2, alpha)
		--> ctype: Image对象,即根据alpha值将image1和image2进行透明度混合
		--> 公式:out = image1 * (1.0 - alpha) + image2 * alpha

	ImageChops.composite(image1, image2, mask)
		--> ctype: Image对象,即根据mask遮罩将image1和image2进行透明度混合
		--> 公式:out = image1 * (1.0 - 变化值) + image2 * 变化值


import io(完)
=============================================

	io.BytesIO([initial_bytes])
		--> ctype: 内存级字节流对象,继承自BufferedIOBase类(继承自IOBase类)

		.getbuffer()
			--> ctype: 视图对象,即可读、可写,包括完整的内容

		.getvalue()
			--> ctype: 字节对象,即包括完整内容

		# 来自父类的方法
		.read(size=-1)
			--> ctype: 字节对象,即从字节流的当前指针开始读取最多size个字节并返回它
			--> size ,即如果size为负数或None,则一次性全部读取；

		.write(b)
			--> ctype: 字节数,即将字节对象b从当前指针开始写入字节流中,并返回写入的字节数；
	    	           这个操作会导致当前指针偏移"写入的字节数",并覆盖已存在的字节流

		# 来自祖父的方法
		.closed
			--> ctype: True/False ,即检查IO流是否关闭

		.close()
			--> ctype: None ,即清理缓冲区内容并关闭IO流；
			                 该方法允许调用多次,但仅第一次调用有效；
		.flush()
			--> ctype: None ,即清理缓冲区内容；
							 该方法对只读操作和非块的IO流无效；

		.fileno()
			--> ctype: 整数 ,即返回IO流对应的文件描述符；
			                如果IO流未使用文件描述符,则raise OSError异常；

		.isatty()
			--> ctype: True/False ,即检查IO流是否与终端或其他设备连接(若连接,则开启交互,返回True)

		.readable()
			--> ctype: True/False ,即检查IO流是否可读

		.writable()
			--> ctype: True/False ,即检查IO流是否可写

		.readline(size=-1)
			--> ctype: bytes ,即默认从IO流中读取一行内容并返回它
			--> size ,即若指定size,则从IO流中最多读取size个字节

		.readlines(hint=-1)
			--> ctype: list ,即默认从IO流中读取所有行内容,并以内嵌行内容的列表形式返回它
			--> hint ,即若指定hint,则从IO流中最多读取hint行内容

		.seek(offset[, whence])
			--> ctype: 索引数,即将IO流中的当前指针偏移offset,并返回偏移后的当前索引数；
			--> offset ,整数即当前指针的偏移量
			--> whence ,偏移模式,默认为SEEK_SET 或 0 --> 表示从IO流的开始计算偏移量
			                         SEEK_CUR 或 1 --> 表示从IO流的当前位置开始计算偏移量
			                         SEEK_END 或 2 --> 表示从IO流的末尾开始计算偏移量
		.tell()
			--> ctype: 索引数,即返回IO流中当前指针的索引数

		.truncate(size=None)
			--> ctype: IO流内容,即修改当前IO流内容的size；
			--> size ,即若指定size,则将当前IO流内容压缩/扩充至size个字节(压缩 - 直接去掉尾部的；扩充 - 多数平台用0填充)；
			            若未指定size,则将当前IO流内容修改为"开始至当前指针处"；

	io.StringIO(initial_value="", newline="\n")
		--> ctype: 内存级文本流对象,继承自TextIOBase类(继承自IOBase类)

		.getvalue()
			--> ctype: 字符串对象,即包括完整内容

		# 来自父类的方法
		.read(size)
			--> ctype: 字符串对象,即从文本流的当前指针开始读取最多size个字符,并以字符串的形式返回它
			--> size ,即最多读取的字符个数；若为负数或None,则一次性全部读取；

		.readline(size=-1)
			--> ctype: 字符串对象,即从文本流的当前指针开始读取一行字符,并以字符串的形式返回它；如果没有剩余字符,则返回空字符串；
			--> size ,即最多读取的字符个数

		.seek(offset[, whence])
			--> ctype: 索引数,即将文本流中的当前指针偏移offset,并返回偏移后的当前索引数；
			--> offset ,整数即当前指针的偏移量
			--> whence ,偏移模式,默认为SEEK_SET 或 0 --> 表示从文本流的开始计算偏移量
			                         SEEK_CUR 或 1 --> 表示从文本流的当前位置开始计算偏移量
			                         SEEK_END 或 2 --> 表示从文本流的末尾开始计算偏移量
	    .tell()
	    	--> ctype: 索引数,即返回文本流中当前指针的索引数

	    .write(s)
	    	--> ctype: 字符数,即将字符串s从当前指针开始写入文本流中,并返回写入的字符数；
	    	           这个操作会导致当前指针偏移"写入的字符数",并覆盖已存在的文本流

		.encoding
			--> ctype: 即当前文本流使用的编码/解码方式

		.errors
			--> ctype: 即编码/解码错误时,error的配置

		# 来自祖父的方法
		.closed
			--> ctype: True/False ,即检查IO流是否关闭

		.close()
			--> ctype: None ,即清理缓冲区内容并关闭IO流；
			                 该方法允许调用多次,但仅第一次调用有效；
		.flush()
			--> ctype: None ,即清理缓冲区内容；
							 该方法对只读操作和非块的IO流无效；

		.fileno()
			--> ctype: 整数 ,即返回IO流对应的文件描述符；
			                如果IO流未使用文件描述符,则raise OSError异常；

		.isatty()
			--> ctype: True/False ,即检查IO流是否与终端或其他设备连接(若连接,则开启交互,返回True)

		.readable()
			--> ctype: True/False ,即检查IO流是否可读

		.writable()
			--> ctype: True/False ,即检查IO流是否可写

		.readline(size=-1)
			--> ctype: IO流内容 ,即默认从IO流中读取一行内容并返回它
			--> size ,即若指定size,则从IO流中最多读取size个字节

		.readlines(hint=-1)
			--> ctype: IO流内容 ,即默认从IO流中读取所有行内容,并以内嵌行内容的列表形式返回它
			--> hint ,即若指定hint,则从IO流中最多读取hint行内容

		.seek(offset[, whence])
			--> ctype: 索引数,即将IO流中的当前指针偏移offset,并返回偏移后的当前索引数；
			--> offset ,整数即当前指针的偏移量
			--> whence ,偏移模式,默认为SEEK_SET 或 0 --> 表示从IO流的开始计算偏移量
			                         SEEK_CUR 或 1 --> 表示从IO流的当前位置开始计算偏移量
			                         SEEK_END 或 2 --> 表示从IO流的末尾开始计算偏移量
		.tell()
			--> ctype: 索引数,即返回IO流中当前指针的索引数

		.truncate(size=None)
			--> ctype: IO流内容,即修改当前IO流内容的size；
			--> size ,即若指定size,则将当前IO流内容压缩/扩充至size个字节(压缩 - 直接去掉尾部的；扩充 - 多数平台用0填充)；
			            若未指定size,则将当前IO流内容修改为"开始至当前指针处"；


import importlib(完)
=============================================

	importlib.invalidate_caches()
		--> 在动态导入(即解释器启动后导入)模块/包之前,应该执行本方法来清除sys.meta_path中储存的模块/包信息,
			从而让Python的import系统能够重新识别到动态导入的模块/包

	importlib.__import__(name, globals=None, locals=None, fromlist=(), level=0)
		--> ctype: 顶层的模块/包对象,即内置函数__import__()的实现方法

	importlib.import_module(name, package=None)
		--> ctype: 指定的模块/包对象,相比上面的.__import__更推荐使用本方法
		--> name ,即指定的模块/包名,可以是相对名称,也可以是绝对名称；

				  如果是相对名称,则必须指定package参数当作钩子,从而找到实际的模块/包；
				  例如:name --> pkg.mod  package=None    等价于
				  	   name --> ..mod    package=pkg.mod

		--> 区别:.__import__() 方法遇到name参数是多层次结构(即pkg.mod)时,ctype是顶层的模块/包(即pkg)
				 而.import_module() 方法无论如何,ctype都是对应的模块/包(即pkg.mod)


import struct(完)
=============================================

	struct模块,被用于Python数据和bytes对象(相当于C语言中的structs数据)之间的转换,
	核心在于"格式化字符串"的制定；struct模块常见于各种协议,报头数据的格式化

	struct.pack(fmt, v1, v2, ...)
		--> ctype: bytes对象 ,即将v1, v2, ...等值按照fmt的规定转换成字节序,待转换的参数应该一一对应fmt
		--> fmt ,即格式化字符串,详见下文
			当.pack()时,如果值的字节长度与fmt中的不对等,那么只有【@模式】会进行填充,但即便如此也不会填充到ctype结果的开头或结尾

	struct.pack_into(fmt, buffer, offset, v1, v2, ...)
		--> ctype: None ,即将v1, v2, ...等值按照fmt的规定写入(可写的)buffer字节对象的offset索引处

	struct.unpack(fmt, buffer)
		--> ctype: tuple ,即将buffer字节对象按照fmt的规定进行解析,并以元组形式返回结果
						待解析的buffer的字节长度应该等于fmt的字节长度
		--> fmt ,即格式化字符串,详见下文

	struct.unpack_from(fmt, buffer, offset=0)
		--> ctype: tuple ,即将buffer字节对象按照fmt的规定从offset索引处开始向后解析,并以元组形式返回结果
						 从索引出开始向后解析的字节长度应该不小于fmt的字节长度

	struct.calcsize(fmt)
		--> ctype: 字节数 ,即返回fmt的字节长度(等价于.pack()后的bytes对象的字节长度)
		--> fmt ,即fmt字符串是一种格式规范,其中有一些特殊的字符,被用于规定bytes数据的存储顺序、大小和对齐等；
			1) fmt字符串的首个字符必须是以下之一:
				@ --> 字节序原始 --> 字节大小原始 --> 对齐原始  --> 默认值,原始即取决于数据来源
				= --> 字节序原始 --> 字节大小标准 --> 对齐None --> 原始即取决于数据来源
				< --> 字节序小端 --> 字节大小标准 --> 对齐None
				> --> 字节序大端 --> 字节大小标准 --> 对齐None
				! --> 字节序网络 --> 字节大小标准 --> 对齐None --> 网络即大端
				大端与小端,是指多字节数据在存储时,高、低位数据和物理内存中高、低位地址的对应关系:
				低位字节存在低位地址,高位字节存在高位地址,称作"小端字节序"(Little-Endian)
				高位字节存在低位地址,低位字节存在高位地址,称作"大端字节序"(Big-Endian) 	--> 用于网络数据传输

			2) fmt字符串的其他字符取值:
				标识符    参数类型    		 所占字节大小
				x        空值(即不传值)		 1

				c        bytes             1
				s        bytes             不定长(可以为0)

				b        int               1         		--> bit(位)
				B        int               1
				?        boolean           1         		--> 若无效,则用b替代
				h        int               2
				H        int               2
				i        int               4
				I        int               4
				l        int               4
				L        int               4
				q        int               8
				Q        int               8

				e        float             2
				f        float             4
				d        float             8
				重复的标识符可以简写,并注明数量,例如: "hhh"等价于"3h","ccc"等价于"3c"；
				注意: 标识符"s"是不定长,所以"3s"等价于1个长度为3的bytes对象,而不是3个bytes对象,"0s"等价于1个空bytes对象；


import itertools(完)
=============================================

	itertools.count(start[, step])
		--> ctype:迭代器,即从start值开始,按step值依次返回数字(可以是浮点数,也可以是整数)
			itertools.count(10, 2) ::= 10, 12, 14, 16, ....

	itertools.cycle(iterable)
		--> ctype:迭代器,即循环迭代iterable
			itertools.cycle("ABCD") ::= "A", "B", "C", "D", "A", "B", ...

	itertools.repeat(任意值[, count])
		--> ctype:迭代器,即从重复"任意值"[count次]
			itertools.repeat("A", 3) ::= "A", "A", "A"

	itertools.chain(*iterable)
		--> ctype:迭代器,即将一个或多个迭代器构成一个更大的迭代器
			itertools.chain("ABC", "DEF") ::= "A", "B", "C", "D", "E", "F"

	itertools.compress(iterable,过滤迭代器)
		--> ctype:迭代器,即(data for data, filter in zip(iterable,过滤迭代器) if filter)
						过滤迭代器是一个True或False值的集合,用于配对过滤iterable中的每个元素
			itertools.compress("ABCD", [1, 0, 1, 0]) ::= "A", "C"

	itertools.islice(iterable[, start], stop[, step])
		--> ctype:迭代器,即预先将iterable中的数据做分片处理,然后返回一个处理后的迭代器
			start和step参数可以省略,所以当islice()方法参数不够时,优先满足stop参数
			start, stop, step都必须是非负数；如果stop为None,则表示到尾部为止
			itertools.islice("ABCDEFG", 2, None, 2) ::= C", "E", "G"

	itertools.dropwhile(条件函数, iterable)
		--> ctype:迭代器,即依次从iterable中取出元素放入条件函数中,返回第一个False及它之后的iterable的所有元素
			itertools.dropwhile(lambda x:x<5, [1, 2, 3, 4, 5, 2, 3, 1]) ::= 5, 2, 3, 1

	itertools.filterfalse(条件函数, iterable)
		--> ctype:迭代器,即依次从iterable中取出元素放入条件函数中,返回所有为False的iterable元素
			和内置函数filter()互补操作
			itertools.filterfalse(lambda x:x<5, [1, 6, 5, 3, 7, 9, 8, 2]) ::= 6, 5, 7, 9, 8

	itertools.starmap(函数, iterable)
		--> ctype:迭代器,即将iterable中的每个元素【取出并解包】后放入函数中,然后所有的结果构成返回值
			itertools.starmap(pow, [(2, 2), (2, 3), (2, 4)]) ::= 4, 8, 16
	
	itertools.zip_longest(*iterable, fillvalue=None)
		--> ctype:迭代器,即将一个或多个iterable取出每个元素聚合成元组形式返回,如果多个iterable元素个数不等,
						缺少的一方用fillvalue值补充,相当于高兼容的zip()函数
			itertools.zip_longest("AB", "CDE", fillvalue="-") ::= ("A", C"), ("B", "D"), ("-", "E")

	itertools.product(*iterable, repeat=1)
		--> ctype:迭代器,即product(A, B) 		  --> (x, y) for x in A for y in B, 
						  product(A, repeat=2) --> product(A, A)
			有顺序、允许重复
			itertools.product("ABC", repeat=2) ::= ("A", "A"), ("A", "B"), ("A", "C"), ("B", "A"), ("B", "B"), ("B", "C"), ("C", "A"), ("C", "B"), ("C", "C")
			itertools.product("ABC") ::= ("A", ), ("B", ), ("C", )

	itertools.permutations(iterable, num)
		--> ctype:迭代器,同上,有顺序,不允许重复
			itertools.permutations("ABC", 2) ::= ("A", "B"), ("A", "C"), ("B", "A"), ("B", "C"), ("C", "A"), ("C", "B")

	itertools.combinations_with_replacement(iterable, num)
		--> ctype:迭代器,同上上,无顺序,允许重复
			itertools.combinations_with_replacement("ABC", 2) ::= ("A", "A"), ("A", "B"), ("A", "C"), ("B", "B"), ("B", "C"), ("C", "C")

	itertools.combinations(iterable, num)
		--> ctype:迭代器,同上上上,无顺序,不允许重复
			itertools.combinations("ABC", 2) ::= ("A", "B"), ("A", "C"), ("B", "C")


import pickle(完)
=============================================

	pickle.dump(obj, file, protocol=None, *, fix_imports=True)
		--> ctype: None,即将obj序列化写入file中
		--> protocol ,即表示遵循的序列化协议版本,默认是版本3(共四个版本,分别是版本0~版本4,版本3是python2.x和3.x的兼容)

	pickle.dumps(obj, protocol=None, *, fix_imports=True)
		--> ctype: bytes对象,即将obj序列化并以bytes形式返回

	pickle.load(file, *, fix_imports=True, encoding="ASCII", errors="strict")
		--> ctype: 从file中读取序列化数据,并返回序列化之前的内容

	pickle.loads(bytes_object, *, fix_imports=True, encoding="ASCII", errors="strict")
		--> ctype: 返回bytes_object序列化之前的内容


import json(完)
=============================================
	json模块生成的一定是str对象,而不是bytes对象；json对象中的键值对均是str类型

	json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)
		--> ctype: None,即将obj对象json化后写入fp中
		--> obj ,即被json化的对象
		--> fp ,即类file对象
		--> ensure_ascii=True/False ,即如果obj包含中文,则选择False
		--> indent=数字/字符串 ,即按照obj中的level完美格式输入；
							  如果indent=None,则level之间紧挨着输入；
							  如果indent=0、负数或"",则level之间会换行；
							  如果indent=正数,则level之间会空"正数"个空格；
							  如果indent=字符串,则level之间会嵌入"字符串"(例如,"\t")
		--> sort_keys=True/False ,即如果为True,则会按照key值排序输入

	json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)
		--> ctype: 字符串对象,即将obj对象json化后返回

	json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
		--> ctype: None,即从fp中读取json化数据,并返回json化之前的内容(即Python对象)

	json.loads(s, *, encoding=None, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)
		--> ctype: Python对象,即返回s(内含json数据的str, bytes或bytearry对象)json化之前的内容

	JSON和Python对象类型对比
		JSON   		   PYTHON
		object			dict
		array			list、tuple
		string			str
		number(int) 	int
		number(real)	float
		true			True
		false			False
		null			None


import csv(完)
=============================================

	csv.reader(csvfile, dialect="excel", **fmtparams)
		--> ctype: reader对象(即迭代器对象,每次迭代它都会返回一个字符串列表,表示读取的每行内容)

		--> csvfile ,即任何支持迭代器协议且每次调用__next__()方法都"返回字符串"的对象,例如:file、list对象
					 如果csvfile是一个file对象,应该指定参数newline="",这是为了让换行符不进行转换(newline=None,即默认情况下"\r\n"和"\n"都会转换成"\n")

		--> dialect ,即Dialect子类的实例对象,或者是csv.list_dialects()方法返回值中的某个标识符(该方法默认返回值为字符串你列表 - ["excel", "excel-tab", "unix"])
					 dialect参数用于指定CSV的格式化规范

		--> **fmtparams ,即用于重写(即修改)dialect参数指定的当前规范的内容

		--> .__next__()
				--> 即迭代器对象的基本使用方法,但建议使用next(reader对象)来进行迭代操作


	csv.writer(csvfile, dialect="excel", **fmtparams)
		--> ctype: writer对象(即负责将数据写入csvfile对象中)

		--> csvfile ,即支持write()方法的任何对象
					 如果csvfile是一个file对象,应该指定参数newline="",这是为了让换行符不进行转换(newline=None,即默认情况下"\r\n"和"\n"都会转换成"\n")

		--> dialect ,即Dialect子类的实例对象,或者是csv.list_dialects()方法返回值中的某个标识符(该方法默认返回值为字符串你列表 - ["excel", "excel-tab", "unix"])
					 dialect参数用于指定CSV的格式化规范

		--> **fmtparams ,即用于重写(即修改)dialect参数指定的当前规范的内容

		--> .writerow(row)
				--> ctype: None ,即将row写入csvfile对象中(对应一行内容)
				--> row ,即row必须是可迭代的字符串或数字(每个迭代元素都对应一个单元格,迭代元素的类型不要求全部一致)

		--> .writerows([row, ...])
				--> ctype: None ,即将row列表写入csvfile对象中(每个row都对应一行内容)
				--> row ,即row必须是可迭代的字符串或数字(每个迭代元素都对应一个单元格,迭代元素的类型不要求全部一致)


	csv.DictReader(f, fieldnames=None, restkey=None, restval=None, dialect="excel", *args, **kwds)
		--> ctype: 一个等同于reader对象的实例对象,区别是DictReader的读取的每行内容是OrderedDict()对象

		--> f ,即任何支持迭代器协议且每次调用__next__()方法都"返回字符串"的对象,例如:file、list对象
			   如果f是一个file对象,应该指定参数newline="",这是为了让换行符不进行转换(newline=None,即默认情况下"\r\n"和"\n"都会转换成"\n")

		--> fieldnames ,即序列对象,它们被当做key使用,用于标识数据读取的顺序；
						fieldnames参数如果未指定,则默认将读取数据的第一行当做fieldnames参数的值

		--> restkey ,即当fieldnames中的元素个数小于读取数据的个数时,读取数据中多余的单元格数据会全部放进一个列表中,该列表对应的key值就是restkey的值

		--> restval ,即当fieldnames中的元素个数大于读取数据的个数(空行除外)时,fieldnames中多余的元素(即key值)会全部"设置"为restval的值


	csv.DictWriter(f, fieldnames, restval="", extrasaction="raise", dialect="excel", *args, **kwds)
		--> ctype: 一个等同于write对象的实例对象,区别是DictWriter写入的是字典类型的数据

		--> f ,即即支持write()方法的任何对象
			   如果csvfile是一个file对象,应该指定参数newline="",这是为了让换行符不进行转换(newline=None,即默认情况下"\r\n"和"\n"都会转换成"\n")

		--> fieldnames ,即序列对象且必须指定,它们被当做key使用,用于标识数据写入的顺序；
						fieldnames参数本身不会被当作数据写入,该参数中的元素(即key)顺序对应着单元格的顺序

		--> restval ,即当fieldnames中的元素个数大于写入数据的个数时,fieldnames中多余的元素(即key值)会被"设置"为restval参数的值

		--> extrasaction ,即当fieldnames中的元素个数小于写入数据的个数时,即写入的数据中有元素没有对应的key值,
						  则如果extrasaction = "raise"(默认值),程序抛出ValueError异常；
						  如果extrasaction = "ignore",程序会忽略多余的写入数据；


import sys(完)
=============================================

	sys.argv
		--> ctype: 列表,即返回执行Python文件时额外传入命令行的参数(字符串形式)
				   sys.argv[0]是被执行的Python文件名(含后缀名)

	sys.exc_info()
		--> ctype: 元组/None,即返回当前最新抛出的异常,包含:(type, value, traceback)三个值；
				   type表示异常类型(即某个异常类的名字),value表示这个异常类的实例,traceback表示一个traceback对象
				   如果没有异常,则返回None

	sys.getdefaultencoding()
		--> ctype: 字符串,即返回当前Python运行环境中默认的编码名称

	sys.getrefcount(obj)
		--> ctype: 数字,即返回指定obj的引用计数,该数字比真实的引用计数多1；
						因为调用getrefcount()临时传入了参数,使得引用计数多1

	sys.modules
		--> ctype: 字典,即返回当前已加载的所有模块(字典形式 -> "模块名":模块对象)

	sys.path
		--> ctype: 列表,即返回模块搜索路径列表(字符串形式)

	sys.platform
		--> ctype: 字符串,即返回当前平台的标识符,Linux -> "linux" | Windows -> "win32" | Mac OS X -> "darwin"

	sys.version_info
		--> ctype: 类元祖,即返回当前Python解释器的版本,形如sys.version_info(major, minor, micro, releaselevel, serial)
				   例如,sys.version_info(3, 6, 5, "final", 0) --> 即Python 3.6.5的最终版,"alpha" "beta" "candidate" "final"
				   获取信息时,可以sys.version_info[索引] 或者 sys.version_info.参数名 来获取


import os(完)
=============================================

	os.environ
		--> ctype: 类字典的映射对象,即Python启动时获取的环境变量信息
				   使用方式: os.environ["key"] --> 获取对应key的的环境变量的值

	os.getenv(key, default=None)
		--> ctype: 对应key的环境变量的值,如果key不存在,则返回default值

	os.getpid()
		--> ctype: 当前进程的ID

	os.getppid()
		--> ctype: 当前进程的父进程ID

	os.uname()
		--> ctype: 当前操作系统的信息,返回对象具有5个属性
			sysname  - 操作系统名称
			nodename - 网络上的机器名称(实施定义)
			release  - 操作系统发行版本
			version  - 操作系统全信息
			machine  - 硬件标识符

	os.open(path, flags, mode=0o777, *, dir_fd=None)
		--> ctype: fd,即根据"路径"返回fd

	os.fdopen(fd, *args, **kwargs)
		--> ctype: 文件对象,即根据"fd"打开的文件对象,等价于内置函数open(),区别是后者根据"路径"打开文件对象
			*args/**kwargs ,接收于open()相同的参数配置

	os.getcwd()
		--> ctype: 字符串,即返回当前的工作目录

	os.chdir(path)
		--> ctype: None,即将当前的工作目录修改为path

	os.listdir(path=".")
		--> ctpye: 列表,即返回指定目录中的所有文件名(不会递归地列出)

	os.mkdir(path, mode=0o777, *, dir_fd=None)
		--> ctype: None,即单层创建【目录】(如果该目录存在,抛出FileExistsError异常)

	os.makedirs(name, mode=0o777, exist_ok=False)
		--> ctype: None,即递归创建【目录】(当exist_ok=False时,如果目标的最终目录存在,抛出FileExistsError异常)

	os.rmdir(path, *, dir_fd=None)
		--> ctype: None,即删除单个终极【目录】(仅限删除空目录,否则抛出OSEroor异常)

	os.remove(path, *, dir_fd=None)
		--> ctype: None,即删除【文件】(如果删除的是目录,抛出OSError异常)

	os.replace(src,dst,*,src_dir_fd = None,dst_dir_fd = None)
		--> ctype: None,即将src文件或目录重命名为dst【文件】(如果dst是一个目录,抛出OSError异常)
			等价于os.rename(...),区别在于.rename()仅限同平台,.replace()支持跨平台

	os.cpu_count()
		--> ctype: Number,即返回系统CPU的核数

	os.urandom(size)
		--> ctype: bytes,即返回指定字节数的随机字节,通常用于加密操作

	os.curdir
		--> 字符串常量,等价于".",表示当前目录

	os.pardir
		--> 字符串常量,等价于"..",表示父目录

	os.sep
		--> 字符串常量,等价于"/"(POSIX)或"\\"(Window),表示路径分隔符

	os.extsep
		--> 字符串常量,等价于".",表示路径和后缀名之间的分隔符

	os.pathsep
		--> 字符串常量,等价于":"(POSIX)或"；"(Window),表示搜索路径的分隔符

	os.linesep
		--> 字符串常量,等价于"\n"(POSIX)或"\r\n"(Window),表示行的分割符


import shutil(完)
=============================================

	shutil.copystat(src, dst, *, follow_symlinks=True)
		--> ctype: None,即将"src文件或目录"的大部分"元数据"("文件所有者"和"文件用户组"除外)拷贝至"dst文件或目录"；
				   注意: 若src不存在,则raise FileNotFoundError异常；
				   注意: 若dst不存在,则raise FileNotFoundError异常；
		--> src ,即"源文件或目录"路径；
		--> dst ,即"目的文件或目录"路径；
		--> follow_symlinks ,即若为False,则当src和dst均为"符号链接"时,该方法拷贝的是"符号链接"的元数据(而非对应文件的元数据)；

	shutil.copy(src, dst, *, follow_symlinks=True)
		--> ctype: abs-path-str,即将"src文件"拷贝至"dst文件或目录",拷贝的是"文件数据"和"元数据-文件权限"；
				   注意: 若src不存在,则raise FileNotFoundError异常；
		--> src ,即"源文件"路径；
		--> dst ,即"目的文件或目录"路径；若为目录,则表示将"源文件"拷贝至该目录下(冠以"源文件"的基本名)；若为文件且已存在,则会被覆盖重写；
		--> follow_symlinks ,即若为True,则当src为"符号链接"时,该方法拷贝的是"对应文件"；若为False,则当src为"符号链接"时,该方法拷贝的是"符号链接"；

	shutil.copy2(src, dst, *, follow_symlinks=True)
		--> ctype: abs-path-str,即同.copy(...),拷贝的是"文件数据"和大部分"元数据"(通过.copystat()方法)；
				   注意: 若src不存在,则raise FileNoteFoundError异常；
	
	shutil.copyfile(src, dst, *, follow_symlinks=True)
		--> ctype: abs-path-str,即将src文件拷贝至dst文件,仅包括"文件数据"；
				   注意: 若src不存在,则raise FileNotFoundError异常；
				   注意: 若dst不存在,则raise FileNotFoundError异常；
				   注意: 若src和dst相同,则raise SameFileError异常；
				   注意: 若dst是目录,则raise IsADirectoryError异常；
				   注意: 若dst无法写入,则raise OSError异常；
		--> src ,即"源文件"路径；
		--> dst ,即"目的文件"路径；
		--> follow_symlinks ,即若为True,则当src为"符号链接"时,该方法拷贝的是"对应文件"；若为False,则当src为"符号链接"时,该方法拷贝的是"符号链接"；

	shutil.copyfileobj(fsrc, fdst[, length])
		--> ctype: None,即将fsrc类文件对象从"当前指针至结尾"的内容拷贝至fdst类文件对象fdst；
		--> fsrc ,即类文件对象；
		--> fdst ,即类文件对象；
		--> length ,即设置缓存块的字节数；

	shutil.copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2, ignore_dangling_symlinks=False)
		--> ctype: abs-path-str,即递归性地将src目录拷贝至dst目录("元数据"借助.copystat()方法,"文件数据"借助.copy2()方法)；
		--> src ,即"源目录"路径；
		--> dst ,即"目的目录"路径,dst目录必须不存在；
		--> symlinks ,即与follow_symlinks正好相反；若为True,则当src为"符号链接"时,该方法拷贝的是"符号链接"；若为False,则当src为"符号链接"时，该方法拷贝的是"对应文件"；

	shutil.rmtree(path, ignore_errors=False, onerror=None)
		--> ctype: None,即递归性地删除path目录；
				   注意: 若path不存在,则raise FileNotFoundError异常；
				   注意: 若path不是目录,则raise NotADirectoryError异常；
		--> path ,即必须是"非符号链接"的目录路径；
		--> ignore_errors ,即若为True,则忽略删除期间引发的异常；若为False,则交由onerror参数指定的handler对象处理;
		--> onerror ,即处理异常的handler对象,若为None,则表示直接抛出异常；若声明了,则必须是一个callable对象,它接收function、path和excinfo三个参数:
						function	-> 对应抛出异常的函数,具体由平台决定
						path		-> 对应传入function中的路径信息
						excinfo		-> 对应sys.exc_info()捕获的异常对象
	
	shutil.move(src, dst, copy_function=copy2)
		--> ctype: abs-path-str,即递归性地将src文件或目录移动至dst目录中；
				   注意: src文件或目录在操作之后会消失；
				   注意: 若src不存在,则raise FileNotFoundError异常；
				   注意: 若dst存在但不是目录,则raise FileExistsError异常；
		--> src ,即"源文件或目录"路径；
		--> dst ,即"目的目录"路径,若dst不存在,则系统递归性地自动创建它；
	

import os.path(完)
=============================================

	os.path.exists(path)
		--> ctype: True/False,即如果指定的path存在或指向某个fd,则返回True；否则返回False(如果没有进入指定path的权限也会返回False)

	os.path.getatime(path)
		--> ctype: int,即返回最后一次进入指定path的时间(即秒数,从epoch纪元开始)

	os.path.getmtime(path)
		--> ctype: int,即返回最后一次修改指定path的时间(即秒数,从epoch纪元开始)

	os.path.join(path, *path)
		--> ctype: 字符串,即将path和*path中的字符串按顺序拼接成返回值,
						 如果这些path中有绝对path,则剔除之前的path,从当前的绝对path开始向后拼接

	os.path.getsize(path)
		--> ctype: 字节数,即返回指定path下的文件尺寸(按字节计算),若文件不存在或无权限进入,则raise OSError异常

	os.path.isfile(path)
		--> ctype: True/False,即指定path下是否是一个文件,若是文件则也是一个链接,故os.path.islink()也会返回True

	os.path.isdir(path)
		--> ctype: True/False,即指定path下是否是一个目录

	os.path.splitext(path)
			--> ctype: ("头部", "后缀"),例如:.splitext(".cshrc") --> (".cshrc", "")
										   .splitext(".cshrc.py") --> (".cshrc", ".py")
		
		os.path.split(path)
			--> ctpye: ("头部", "尾部"),即将指定的path拆分成头部和尾部,以元组的形式返回
									尾部是指定path最后一个"/"之后的内容(可以为空,不带"/")
									头部是指定path最后一个"/"之前的所有内容(不带"/")
		
		os.path.splitdrive(path)
			--> ctype: ("盘符", "尾部"),例如:.splitdrive("c:/dir") --> ("c:", "/dir")
		
	os.path.basename(path)
		--> ctype: "尾部",即见上,返回指定path的尾部内容,等价于.split(path)[1]

	os.path.commonprefix(path列表)
		--> ctype: 字符串,即返回path列表中共同的前缀(一个字符一个字符的比较)

	os.path.commonpath(path列表)
		--> ctype: 字符串,即同上,区别是返回的共同前缀符合路径的规范

	os.path.relpath(path, start=os.curdir)
		--> ctype: 字符串,即从start路径至path路径的相对关系


import collections(待定)
=============================================

	collections.deque([iterable[, maxlen]])
		--> 创建deque(双端队列,音’deck‘)对象
			iterable参数,预先向队列中存入了指定的元素；如果没有该参数,队列为空
			maxlen参数,指定了队列的最大容量,如果存入的元素超过了该值,反方向最旧的元素会被剔除；如果没有该参数,队列长度无限

		1) 增
		dq.appendleft(元素)
			--> 左侧添加元素

		dq.append(元素)
			--> 右侧添加元素

		dq.insert(索引,元素)
			--> 在指定索引出插入元素(如果该操作使得队列的长度超过maxlen,则抛出异常)

		dq.extendleft(iterable)
			--> 左侧添加内容

		dq.extend(iterable)
			--> 右侧添加内容

		2)删
		dq.clear()
			--> 清空队列

		dq.remove(元素)
			--> 删除第一次出现的元素

		dq.popleft()
			--> 从左侧截取第一个元素

		dq.pop()
			--> 从右侧截取第一个元素

		3)改
		dq.copy()
			--> 浅拷贝队列

		dq.reverse()
			--> 倒置队列

		dq.rotate(n=num)
			--> 旋转队列num次,num为负,左向旋转队列；num为正,右向旋转队列

		4)查
		dq.count(元素)
			--> 统计队列中元素的个数

		dq.index(元素, [start[, stop]])
			--> 从start开始到stop结束之间,元素第一次出现处的索引

	collections.OrderedDict([item])
		--> 创建有序字典(具有所有普通dict的属性和方法)
			item参数,预先向字典中存入了数据

		--> od.popitem(last=True)
				--> ctype: (key, value),即截取最后一个键值对,如果last=True(默认),后进先出(栈),否则先进先出(队列)

		--> od.move_to_end(key, last=True)
				--> ctype: None,即将对应key的键值对移动至字典的一端,如果last=True(默认),移动至最右侧,否则移动至最左侧

	collections.Counter([iterable/dict/ele1=num1, ele2=num2, ...])
		--> ctype: cnt对象,即计数器对象(dict的子类)用于计算可哈希对象的个数,类似于其他语言中的bags(背包)或multisets(多元集合)； 
					本质上,该对象将存进来的每个ele视作key,每个ele的个数视作对应的value(若value为0或负数,则表示对应的ele目前不存在,但可能未来存在)；
		1) 增
		cnt.update(iterable/dict/cnt对象)
			--> ctype: None/TypeError异常,即原处修改,根据iterable/dict/cnt对象,增加指定ele一次/value次/对应次；
		
		2) 删
		del cnt[ele]
			--> ctype: None,即原处修改,删除对应ele(若对应的ele不存在,并不会raise KeyError)；
		
		cnt.clear()
			--> ctype: None,即原处修改,清空ele；
		
		cnt.subtract(iterable/dict/cnt对象)
			--> ctype: None/TypeError异常,即原处修改,根据iterable/dict/cnt对象,减去指定ele一次/value次/对应次；

		3) 改
		+cnt
			--> ctype: new-cnt对象,即一元操作符,删除value为0或负数的ele；
		
		-cnt
			--> ctype: new-cnt对象,即一元操作符,对每个ele的value值取反后,删除value为0或负数的ele；
		
		cnt.copy()
			--> ctype: new-cnt对象,即拷贝一份cnt对象；

		cnt.keys()
			--> ctype: dict_keys对象,即所有ele组成的迭代器；

		cnt.values()
			--> ctype: dict_keys对象,即所有ele的个数组成的迭代器；

		cnt.items()
			--> ctype: dict_keys对象,即所有ele及其个数组成的迭代器；
		
		4) 查 
		cnt[ele]
			--> ctype: 0/int,即返回对应ele的个数,若ele不存在,返回0而不是raise KeyError；

		cnt.elements()
			--> ctype: iterator,即每个ele重复对应value次后的"无序"迭代器(不包含对应value为0或负数的ele)；
		
		cnt.most_common([n])
			--> ctype: 2-list,即返回所有ele组成的"2-无序列表",形如: [("ele1", num1), ("ele2", num2), ...]；
							若声明了n,则返回个数最多的前n个ele组成的"2-无序列表"；

	collections.namedtuple(typename, field_names, *, rename=False, defaults=None, module=None)
		--> ctype: 类名,即该函数是"命名元组"的工厂函数,用于创建可实例化的"命名元组"类；
			# ctype: NTP_cls
				collections.namedtuple("NTP", ["args1", "args2"], defaults=[df1, df2]) 
			# ctype: ntp_obj
				NTP(args1=xx, args2=xx) 
				NTP()						// args1=df1, args2=df2
		--> typename ,即"string"形式的"命名元组"类名,使用去掉引号的类名进行实例化；
		--> field_names ,即"str-list"形式的"命名元组"字段名,是实例化时传入的参数名,也是实例化后的可访问的属性名； 
		--> rename ,即若rename=True,且field_names列表中的字段命名不符合规则,则自动将不符合规则的字段名修改为"_列表索引名"； 
		--> defaults ,即iterable,为"命名元组"实例化时对应字段提供默认值；

			3) 改
			ntp._replace(**kwargs)
				--> ctype: new-ntp_obj,即更新ntp_obj中的字段值；

			ntp._asdict()
				--> ctype: OrderedDict对象,即将"命名元组"对象转换成"有序字典"对象；
			
			4) 查
			ntp.字段名 / ntp[字段索引]
				--> ctype: value,即返回对应"字段"的值；

			ntp._fields
				--> ctype: str-tuple,即返回"元组"形式的所有"命名元组"字段名；
			
			ntp>_fields_defaults
				--> ctype: dict,即返回"字典"形式的所有"命名元组"字段名及其默认值；


import re(完)
=============================================

	re.compile(pattern, flags=0)
		--> ctype: 正则对象,即将pattern字符串转换成正则对象并返回
		--> flags: re.I --> 不区分大小写的匹配
		           re.M --> ^ 匹配字符串的开头和每行的开头(默认^ 只匹配字符串的开头)
		                    $ 匹配字符串的末尾和每行的末尾(默认$ 只匹配字符串的末尾
		           re.S --> . 匹配任何字符,包括\n(默认. 不匹配\n)

	re.search(pattern, string, flags=0)
		--> ctype: 匹配对象/None,即寻找"第一个"符合匹配规则的对象

	re.match(pattern, string, flags=0)
		--> ctype: 匹配对象/None,即从字符串开头开始,寻找"第一个"符合匹配规则的对象；
								即使在re.M模式下,match()也只会匹配字符串的开头,而不是每行的开头

	re.findall(pattern, string, flags=0)
		--> ctype: 列表/[],即从左至右寻找所有符合匹配规则的字符串,然后按顺序返回至列表中；
							如果有单个分组,则只返回符合分组规则的字符串,即使结果为空也会被返回；
							如果有多个分组,则以嵌套元组形式只返回符合分组规则的字符串,即使结果为空也会被返回；

	re.finditer(pattern, string, flags=0)
		--> ctype: 迭代器对象,即匹配的对象列表的迭代器,用法同上

	re.sub(pattern, repl, string, count=0, flags=0)
		--> ctype: 字符串,即用repl字符串去替换string字符串中符合pattern匹配规则的部分

	re.split(pattern, string, maxsplit=0, flags=0)
		--> ctype: 列表,即用string中符合pattern匹配规则的字符(串)去分割string；
						如果pattern中有分组,则符合分组的部分也会一并返回至列表中
		--> maxsplit,即规定分割string多少次(按从左至右的顺序)

	匹配对象.group([分组序号])
		--> ctype: 字符串,即返回匹配对象的内容；分组序号为0(默认)时,返回整个匹配对象的内容；分组序号为1, ...,返回对应分组的内容

	匹配对象.groups(default=None)
		--> ctype: 元组,即返回所有分组内容构成的元组
		--> default,即没有匹配到的分组内容用default值代替

	匹配对象.groupdict(default=None)
		--> ctpye: 字典,即返回所有命名分组内容构成的字典
		--> default,即没有匹配到的分组内容用default值代替

	匹配对象.start([分组序号])
	匹配对象.end([分组序号])
		--> ctype: 索引值,即对应分组的字符串的开始字符和结束字符在原字符串中的索引值(结束字符的索引值比实际索引值大1),如果分组不存在返回-1

	匹配对象.span([分组序号])
		--> ctype: 元组,即等价于(匹配对象.start([分组序号]),匹配对象.end([分组序号])),(结束字符的索引值比实际索引值大1)

	匹配对象.re
		--> ctype: compile_obj,即得到当前匹配对象所使用的匹配模式

	匹配对象.string
		--> ctype: 字符串,即得到当前匹配对象所对应的原字符串匹


import math(完)
=============================================

	math.floor(数值) --> return 整数 --> 即坚决四舍后的整数(自己是自己)
	math.ceil(数值) --> return 整数 --> 即坚决五入后的整数(自己是自己)

	math.factorial(整数) --> return 整数 --> 即整数的阶乘

	math.copysign(x, y) --> return 数值 --> 即x的绝对值,y的符号

	math.gcd(x, y) --> return 整数 --> 即x和y的最大公约数

	math.sqrt(数值) --> return 数值 --> 即数值的平方根
	math.pow(x, y) --> return 数值 --> 即x的y次方,与内置函数pow(x, y)相比,
								  math类中的x, y可以不是整数


import statistic(完)
=============================================

	statistic.mean(列表) --> return 数值 --> 即列表中所有数值的平均数
	statistic.median(列表) --> return 数值 --> 即列表中所有数值的中位数
	statistic.median_low(列表) --> return 数值 --> 即列表中低个的中位数(有多个时)
	statistic.median_high(列表) --> return 数值 --> 即列表中高个的中位数(有多个时)
	statistic.mode(列表) --> return 元素 --> 即列表中出现最多次数的【一个】元素


import random(完)
=============================================

	random.randrange(a, b, c) 
		--> ctype: 整数,即列表从a到b间隔c期间随机一个整数
		
		random.randint(a, b) 
			--> ctype: 整数,即整数a到b期间随机一个整数
	
	random.uniform(a, b) 
		--> ctype: 浮点数,即浮点数a到b期间随机一个浮点数

	random.choice(序列) 
		--> ctype: 元素,即从一个序列中随机返还一个元素(空序列报错)

	random.sample(序列,k=X) 
		--> ctype: 子序列,即从一个序列中随机返还X个不重复的元素形成子序列

	random.choices(多个序列, k=X) 
		--> ctype: 子序列,即从所有原序列中随机返还X个元素形成子序列

	random.shuffle(序列) 
		--> ctype: 序列,即将一个序列随机洗混然后返还


import multiprocessing as mp(完)
=============================================

	a) 主进程会等到子进程先结束再结束
	b) 子进程在执行完taregt函数后结束
	c) 主进程和子进程【不共享】全局变量
	d) 通常,多进程会创建【mp.Process】的子类,然后实例化这个子类,并在这个子类中重写run()方法
	--> 子类对象调用start()方法 --> start()方法自动调用run()方法

	mp.Process(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=False)
		--> ctype: 新的进程对象
		--> target: 新的进程去执行的函数名
		--> name: 新的进程名
		--> args/kwargs: 传入target对应函数中的参数
		--> daemon: keyword-only参数,如果为True,则新的进程为守护进程

		--> process.start()
				--> ctype: None,即开启新的进程

		--> process.run()
				--> ctype: None,即继承Process类时,子类中重写run()方法

		--> process.join([timeout=None])
				--> ctyp: None,即当前进程处于堵塞状态,等待process进程执行完毕；若设置了timeout,则等待timeout后返回；

		--> process.is_alive()
				--> ctype: True/False,即process进程是否还活着

		--> process.terminate()
				--> ctype: None,即终止process进程

		--> process.name
				--> ctype: process进程名

		--> process.pid
				--> ctpe: process进程的ID

	---------------------------------------------
	a) 主进程不会等到子进程先结束再结束(这点与Process不同)
	b) 进程池不会因为任务数大于进程数就发生堵塞
	c) 当进程池中的一个进程结束时,不会自我销毁再创建新的进程用于后续的任务,而是不停工地连续执行任务。
	d) 使用join()方法之前必须先执行close()方法或terminate()方法

	mp.Pool(processes[, initializer[, initargs[, maxtasksperchild]]])
		--> ctpye: pool对象
		--> processes ,即进程池中的工作进程个数
		--> initializer ,即每个工作进程开启后率先执行的函数名
		--> initargs ,即每个工作进程开启后率先执行的函数参数
		--> maxtasksperchild ,即每个工作进程被新的工作进程替换前完成的"任务数"

		--> pool.apply_async(func[, args[, kwargs[, callback[, error_callback]]]])
				--> ctype: AsyncResult对象,即向进程池中"异步添加"一个任务(即待执行的函数)
				--> callback ,即仅接收1个参数的回调函数,当func返回结果后被调用；
				--> error_callback ,即仅接收1个参数的回调函数,当func发生异常后被调用；

		--> pool.apply(func[, args[, kwargs]])
				--> ctype: 即向进程池中"同步添加"一个任务(即待执行的函数)

		--> pool.terminate() / pool.close()
				--> ctype: None,即终止向进程池中添加任务

		--> pool.join()
				--> ctype: None,即调用者进程处于堵塞状态,等待进程池中的任务全部执行完毕
								 在调用join()方法之前必须先调用close()或terminate()函数

	mp.Lock()
		--> ctype: 进程锁对象,用法和线程锁一样,唯一的区别是:上锁状态的线程锁只能由"任意的线程"解锁,
													  而上锁状态的进程锁可以由"任意的进程或线程"解锁

		--> lock.acquire(blocking=True, timeout=-1)
				--> ctype: True/False/堵塞,即如果lock当前状态没有上锁,则返回True；
									  		如果lock当前状态已上锁,则发生堵塞；

				--> blocking,如果lock当前状态没上锁,则blocking为True或False没有区别,都会返回True,以表示lock上锁成功
							  如果lock当前状态已上锁,则blocking为True会发生堵塞(默认情况)；为False不会发生堵塞,而是返回False

				--> timeout,如果lock当前状态没上锁,则blocking为True或False没有区别,都会返回True,以表示lock上锁成功
							 如果lock当前状态已上锁,timeout为正浮点数,则这次调用acquire()只会堵塞"正浮点数"秒,并返回False
							 					 timeout默认为-1,表示这次调用acquire()会无限堵塞

		--> lock.release()
				--> ctype: None,即解锁；

	mp.RLock()
		--> ctype: 递归锁对象

		--> rlock.acquire()
				--> 即上锁,可以多次上锁,但上锁次数必须与解锁次数相同

		--> rlock.release()
				--> 即解锁,可以多次解锁,但解锁次数必须与上锁次数相同

	进程间通信
	---------------------------------------------
	mp.Queue([maxsize])
		--> ctype: 队列对象
		--> maxsize,即队列的最大容量

		队列对象.put(obj[, block[, timeout]])
			--> 即将对象传入队列中

		队列对象.put_nowait(obj)
			--> 当队列达到最大容量时,非堵塞地添加进队列中

		队列对象.get([block[, timeout]])
			--> 即取出队列中一个对象

		队列对象.get_nowait()
			--> 当队列达到最大容量时,非堵塞地从队列中取出

		队列对象.empty()
			--> ctype: True/False,即判断队列是否为空

		队列对象.full()
			--> ctype: True/False,即判断队列是否满了

	---------------------------------------------
	mp.Pipe([duplex=True])
		--> ctype: (recv_conn, send_conn),即创建一个管道对象,更确切地说是一对Connection对象；
		--> duplex,即默认为True,表示创建的管道是双工的；如果为False,则元组中的第一个只能收,第二个只能发

		conn.send(obj)
			--> 即向另一个Connection对象发送数据

		conn.recv()
			--> 即从另一个Connection对象接收数据

		conn.close()
			--> 即关闭Connection对象

	---------------------------------------------
	mp.Manager()
		--> ctype: manager对象,即manager对象控制着一个管理共享数据的"服务器"进程,其他进程可以通过"使用代理"来访问这些共享数据；
							   manager对象控制的共享数据可以是各种类型: list, dict, Namespace, 
											   				      Lock, RLock, Semaphore, BoundedSemaphore, Condition, Event, Barrier, 
											   					  Queue, Value, Array

		——> 简单的使用方法:li = manager.list(),然后把li对象作为参数传入其他进程中,即完成了多个进程之间的数据共享

	---------------------------------------------
	mp.sharedctypes.Value(typecode_or_type, *args, lock=True)
		--> ctype: 共享内存的ctypes对象

		--> typecode_or_type ,即指定ctypes对象的类型,(对应C语言)常用的有:
			"b" -> 有符号的字符    "B" -> 无符号的字符
			"h" -> 有符号的short  "H" -> 无符号的short
			"i" -> 有符号的int    "I" -> 无符号的int
			"l" -> 有符号的long   "L" -> 无符号的long
			"f" -> 单精浮点数     "d" -> 双精浮点数

		--> *args ,即传入的值

		--> lock ,即如果为True则保证"安全进程"下操作

	mp.sharedctypes.Array(typecode_or_type, size_or_initializer, *, lock=True)
		--> ctype: 共享内存的ctypes对象

		--> typecode_or_type ,即同上

		--> size_or_initializer ,即数组初始化的参数,是设置数组长度还是传入数组元素

		--> lock ,即如果为True则保证"安全进程"下操作(注意这是一个keyword-only参数)


import threading(完)
=============================================

	a) 所有被设置为daemon(即守护线程)的线程结束后,Python程序才会结束；
	b) Python程序的初始控制线程(即主线程)不是daemon线程；
	c) 所有线程共享全局变量；
	d) 主线程会等待子线程先结束再结束；

	threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=False)
		--> ctype: 新的线程对象
		--> target: 新的线程去执行的函数名
		--> name: 新的线程名
		--> args/kwargs: 传入target对应函数中的参数
		--> daemon: keyword-only参数,如果为True,则新的线程为守护线程

		--> thread.start()
				--> ctype: None,即开启新的线程

		--> thread.run()
				--> ctype: None,即继承Thread类时,子类中重写run()方法

		--> thread.join()
				--> ctyp: None,即当前线程处于堵塞状态,等待thread线程执行完毕

		--> thread.is_alive()
				--> ctype: True/False,即thread线程是否还活着

		--> thread.name
				--> ctype: thread线程名

	threading.main_thread()
		--> ctype: 主线程对象

	threading.current_thread()
		--> ctype: 当前线程对象

	threading.enumerate()
		--> ctype: 所有活着的线程列表

	threading.active_count()
		--> ctype: 所有活着的线程总数,即threading.enumerate()返回值的len

	线程间通信
	---------------------------------------------
	import queue

	* queue模块实现了"多生产者-多消费者"的队列模型,特别适用于"线程级"编程中安全的数据通信
	* queue模块实现了"三种队列": 先进先出队列(queue.Queue)
							  后进先出队列(queue.LifoQueue),类似于"栈"的概念
							  优先级队列(queue.PriorityQueue),借助了heapq模块进行内部排序

	class queue.Queue(maxsize=0)
		--> ctype: FIFO队列的构造类；
		--> maxsize ,即队列的最大容量；若为0或负数,则表示容量无限；
	
	class queue.LifoQueue(maxsize=0)
		--> ctype: LIFO队列的构造类；
		--> maxsize ,即队列的最大容量；若为0或负数,则表示容量无限；

	class queue.PriorityQueue(maxsize=0)
		--> ctype: 优先级队列的构造类；取出时,优先取出"最低优先级"的元素,添加时,以(优先数,元素)形式添加；
		--> maxsize ,即队列的最大容量；若为0或负数,则表示容量无限；

		qe.qsize()
			--> ctype: int,即返回队列的近似容量； 
		
		qe.empty()
			--> ctype: True/False,即判断队列是否为空；

		qe.full()
			--> ctype: True/False,即判断队列是否满了；
		
		qe.put(item, block=True, timeout=None)
			--> ctype: None/阻塞/queue.Full异常,即向队列中添加任务；
		
		qe.put_nowait(item)
			--> ctype: None/queue.Full异常,即向队列中添加任务；
		
		qe.get(block=Ture, timeout=None)
			--> ctype: item/阻塞/queue.Empty异常,即从队列中取出任务；

		qe.get_nowait()
			--> ctype: item/queue.Empty异常,即从队列中取出任务；

		qe.task_done()
			--> ctype: None,即通常会从队列中取出任务后调用该方法,用于提示队列已完成取出的任务；
		
		qe.join()
			--> ctype: 阻塞/None,即当队列中仍有未完成的任务时,该方法阻塞；
					   每次向队列中添加任务后,未完成数 + 1；
					   每次从队列中取出任务并调用.task_done()后,未完成数 - 1；
	
	---------------------------------------------
	threading.Lock()
		--> ctype: 线程锁对象

		--> lock.acquire(blocking=True, timeout=-1)
				--> ctype: True/堵塞,即如果lock当前状态没有上锁,则返回True；
									  如果lock当前状态已上锁,则发生堵塞；

				--> blocking,如果lock当前状态没上锁,则blocking为True或False没有区别,都会返回True,以表示lock上锁成功
							  如果lock当前状态已上锁,则blocking为True会发生堵塞(默认情况)；为False不会发生堵塞,而是返回False

				--> timeout,如果lock当前状态没上锁,则blocking为True或False没有区别,都会返回True,以表示lock上锁成功
							 如果lock当前状态已上锁,timeout为正浮点数,则这次调用acquire()只会堵塞"正浮点数"秒,并返回False
							 					 timeout默认为-1,表示这次调用acquire()会无限堵塞

	---------------------------------------------
	threading.RLock()
		--> ctype: 递归锁对象

		--> rlock.acquire()
				--> 即上锁,可以多次上锁,但上锁次数必须与解锁次数相同

		--> rlock.release()
				--> 即解锁,可以多次解锁,但解锁次数必须与上锁次数相同

	---------------------------------------------
	threading.Condition(lock=None)
		--> ctype: 条件变量对象,
		--> lock ,必须是一个Lock或RLock对象,作为底层锁使用(默认是RLcok对象)

		condi.acquire()
			--> 上锁底层锁

		condi.release()
			--> 解锁底层锁

		condi.wait(timeout=None)
			--> ctype: True/False/堵塞,即如果设置了timeout,则为False；否则为True
								  	  调用wait()之前,当前线程必须先上锁底层锁,否则抛出RuntimeError异常
								      调用wait()之后,当前线程"解锁底层锁"并"进入堵塞"状态,等待其他线程调用notify()唤醒它
								      一旦调用wait()的线程被唤醒(或timeout),当前线程会重新上锁；如果能上锁则返回,否则仍然会发生堵塞

		condi.notify(n=1)
			--> 默认唤醒一个线程,但notify()无法解锁；
				调用notify()之前,当前线程必须先上锁底层锁,否则抛出RuntimeError异常

		condi.notify_all()
			--> 唤醒所有wait()状态的线程
				调用notify_all()之前,当前线程必须先上锁底层锁,否则抛出RuntimeError异常

	---------------------------------------------
	threading.Event()
		--> ctype: 事件对象,即创建一个线程事件对象(默认状态为False)

		--> event.set()
				--> ctype: None,即将event状态更改为True

		--> event.clear()
				--> ctype: None,即将event状态更改为False

		--> event.wait(timeout=None)
				--> ctype: True,即如果event当前状态为False,调用wait()则发生堵塞(除非timeout到了)；
								  如果event当前状态为True,调用wait()则不堵塞

		--> event.is_set()
				--> ctype: True/False,即当且仅当event状态为True时,才返回True

	---------------------------------------------
	threading.Semaphore(value=1)
		--> ctype: 信号对象,即创建一个信号对象,它内置了一个计数器counter,初始值为value；
						   每次成功调用acquire()"之后",counter - 1；
						   每次成功调用release()"之后",counter + 1；
						   计算公式: counter = value + release - acquire

		--> sema.acquire(blocking=True, timeout=None)
				--> ctype: True/False,如果当前counter = 0,当前线程发生堵塞,直到当前counter>0从而被唤醒；
									   如果当前counter > 0,当前counter - 1 并返回True
		--> sema.release()
				--> ctype: None,调用release()之后,能够使当前counter + 1,从而让其他发生堵塞的线程被唤醒
							     每次调用release()能且仅能唤醒一个线程

	---------------------------------------------
	threading.Timer(interval, func, args=None, kwargs=None)
		--> ctype: 计时器对象,即创建一个计时器对象
		--> interval ,即计时数(单位:秒)
		--> func ,即到时间后要执行的函数名
		--> args/kwargs ,即要传入执行函数的参数

		--> timer.cancel()
				--> ctype: None,即在计时结束之前取消函数执行的设定


import concurrent.futures as ccf(完)
=============================================

	ccf.ThreadPoolExecutor(max_workers=None, thread_name_prefix="")
		--> ctype: 线程池对象,即executor对象
		--> max_workers ,即线程池的并发数

	ccf.ProcessPoolExecutor(max_workers=None)
		--> ctpye: 进程池对象,即executor对象
		--> max_workers ,即进程池的并发数

		executor.submit(fn, *args, **kwargs)
			--> ctype: Future对象,即向线程池中添加未来要执行的函数

			future.cancel()
				--> ctype: True/False,即试图取消Future对象中的函数调用；
									  如果函数正在被执行(无法取消),则cancel()返回False；否则函数执行被取消,并且返回True

			future.result(timeout=None)
				--> ctpye: Future对象中的函数执行结果,即如果当前函数尚未执行完毕,则会等待timeout秒；
						   如果timeout秒后仍未返回,则抛出concurrent.futures.TimeoutError异常

			future.exception(timeout=None)
				--> ctype: None/异常,即如果当前函数尚未执行完毕,则会等待timeout秒；
						   如果timeout秒后仍未返回,则抛出concurrent.futures.TimeoutError异常；
						   如果当前函数在完成前被取消,则抛出CancelledError异常；
						   如果当前函数完成没有抛出任何异常,则返回None

			future.running()
				--> ctype: True/False,即如果Future对象中的函数正在被执行(无法被取消),则返回True

			future.done()
				--> ctype: True/False,即如果Future对象中的函数执行完毕或者成功取消,则返回True

			future.cancelled()
				--> ctype: True/False,即如果Future对象中的函数成功取消,则返回True

	ccf.wait(fs, timeout=None, return_when=ALL_COMPLETED)
		--> ctype: 元组,即等待fs(Future对象)完成,元组中的两个元素都是集合类型,
						第一个叫done(包含所有已完成的Future对象),第二个叫not_done(包含所有未完成的Future对象)

		--> timeout ,即设定wait()在返回前最多等待多少秒
		--> return_when ,即设定wait()在什么时候返回,它必须是以下三个常量之一:
						  FIRST_COMPLETED,任何一个Future对象完成或被取消时wait()返回
						  FIRST_EXCEPTION,任何一个Future对象抛出异常时wait()返回,如果没有任何异常等价于ALL_COMPLETED
						  ALL_COMPLETED,所有Future对象完成或被取消时wait()返回

	ccf.as_completed(fs, timeout=None)
		--> ctype: 迭代器,即返回所有已完成的Future对象


import xlrd(完)
=============================================

	一、中间容器法(推荐)
		1)利用xlrd获取目标数据
		2)创建容器保存数据(列表、字典等)
		3)利用xlwt写入容器中的数据

	二、直接读写法
		1)利用xlrd读取目标文档
		2)利用xlutils.copy拷贝目标文档,并返回拷贝的文档对象
		3)利用“拷贝的文档对象.get_sheet(表格索引)“方法获取数据
		4)利用get_sheet()方法中自带的write()方法写入数据

		xlrd.open_workbook("文档路径", [formatting_info=False]) 
			--> ctype: 文档对象,即打开对应的文档并返回文档对象；
			--> formatting_info ,即若为True,则表示带格式打开；

			文档对象.sheet_by_index(表格索引) 
				--> ctype: 表格对象,即通过表格顺序返回表格对象
			
			文档对象.sheet_by_name(u"表格名称") 
				--> ctype: 表格对象,即通过表格名称返回表格对象

				表格对象.nrows 
					--> ctype: 整数,即获取表格的总行数
				
				表格对象.ncols 
					--> ctype: 整数,即获取表格的总列数

				表格对象.row_values(行索引) 
					--> ctype: 某行内容(列表),即通过行索引返回整行的内容
				
				表格对象.col_values(列索引) 
					--> ctype: 某列内容(列表),即通过行索引返回整列的内容

				表格对象.cell(行索引,列索引).value 
					--> ctype: 某单元格内容
				
				表格对象.row(行索引)[列索引].value 
					--> ctype: 某单元格内容
				
				表格对象.col(列索引)[行索引].value 
					--> ctype: 某单元格内容

				表格对象.cell(行索引,列索引).ctype 
					--> ctype: 整数,即获取单元格的数据类型:0为空,1为字符串,2为数字,3为日期,4为布尔,5为错误


import xlutils.copy as xc(完)
=============================================

	xc.copy(只读的文档对象) 
		--> ctype: 可写的文档对象,即拷贝一份文档,用于xlwt库将数据写入该【可写的文档对象】


import xlwt(完)
=============================================

	xlwt.Workbook(encoding="字符编码") 
		--> ctype: 文档对象,即创建对应字符编码的文档对象
		
		文档对象.save("文档路径") 
			--> ctype: None,即将文档保存到对应路径下

		文档对象.add_sheet("表格名", cell_overwrite_ok=False)
			--> ctype: 表格对象,即创建对应名称的表格							|
			--> cell_overwrite_ok ,即规定是否允许多次改写单元格内容,默认为False；如果有"合并单元格"操作,必须改为True；

			表格对象.write(row, col,值/公式, easyxf实例) 
				--> ctype: None,即在row行col列的单元格内写入xxx数据
				--> 值 	,允许文本 -> 即Unicode字符 String
							数字 -> 即int long float decimal.Decimal实例
							日期 -> 即datetime.datetime实例 datatime.date实例 datatime.time实例
							布尔 -> 即True False
							空格 -> 即None
					公式,允许Formula实例,通过xlwt.Formula("...")方法创建
							即xlwt.Formula("hyperlink("url", "xxx")") --> url的超链接,单元格中显示内容为xxx
				--> easyxf实例,即扩展格式化对象,通过xlwt.easyxf("...")方法创建
						即xlwt.easyxf("门类a:属性1 值1,属性2 值2；""门类b:属性1 值1,属性2 值2；"...)
						门类:属性 值 -->font:name         Arial/...
											bold         True/False 或 1/0 或 on/off
											italic       True/False 或 1/0 或 on/off
											color        red/yellow/blue/green/black/gray/orange/...
											shadow       True/False 或 1/0 或 on/off
											underline    none/single/double

									align:dire | direction   general/lr/rl
											horiz| horizontal  left/center/right/justified
											vert | vertical    top/center/bottom/justified

									border:left      no_line/dashed/dotted/double/thin/medium/thick
											right     no_line/dashed/dotted/double/thin/medium/thick
											top       no_line/dashed/dotted/double/thin/medium/thick
											bottom    no_line/dashed/dotted/double/thin/medium/thick

									protection:cell_locked      True/False 或 1/0 或 on/off
												formula_hidden   True/False 或 1/0 或 on/off

			表格对象.row(行索引).write(列索引,值) 
				--> ctype: None

			表格对象.col(列索引).write(行索引,值) 
				--> ctype: None

			表格对象.insert_bitmap("图片路径",行索引,列索引) 
				--> ctype: None,即插入图片

			表格对象.write_merge(行1,列1,行2,列2,合并后的新值, easyxf实例) 
				--> ctype: None,即合并单元格


import docx(待定)
=============================================

	1)打开/新建文档
	docx.Document("文档路径") 
		--> ctype: 文档对象,即读取对应路径下的文档,无路径则加载默认文档"template"
	
		文档对象.save("文档路径") 
			--> ctype: None,即将当前文档保存至对应路径下

		文档对象.paragraphs 
			--> ctype: 所有段落的合集(列表),即按顺序的段落合集
		
		文档对象.tables 
			--> ctype: 所有表格的合集(列表),即按顺序的表格合集

	---------------------------------------------
	2)新建标题
	文档对象.add_heading(u"标题名称", level=num) 
		--> ctype: 标题对象,即创建一个等级为num的标题(num越小,标题字号越大)

	---------------------------------------------
	3)新建段落
	文档对象.add_paragraph(u"段落文本", style=xxx, ) 
		--> ctype: 段落对象,即创建一个样式为xxx的段落

	from docx.enum.text import WD_ALIGN_PARAGRAPH
	段落对象.add_run(u"文本内容", style=xxx) 
		--> ctype: None,即在段落末尾追加内容
	
	段落对象.alignment = LEFT/CENTER/RIGHT/JUSTIFY

	---------------------------------------------
	4)插入图片
	文档对象.add_picture("图片路径", width=xxx, height=xxx) 
		--> ctype: 图片对象,即插入一张图片,若指定width或height参数,则按等比例缩放；若均未指定,则按原尺寸插入
		--> width ,即按计量单位表示,可以是: docx.shared.Inches(num)
										docx.shared.Cm(num)
										docx.shared.Mm(num)

	---------------------------------------------
	5)插入表格
	文档对象.add_table(rows=a, cols=b, style=xxx) 
		--> ctype: 表格对象,即插入一张a行b列的表格

		表格对象.rows[行索引].cells 
			--> ctype: 行对象(列表),即获取一行的单元格内容
		
		表格对象.add_row().cells 
		--> ctype: 新行对象(列表),即在表格末尾添加一行

			行对象[列索引].text = "string" 
				--> ctype: None,即向对应单元格内写入数据

	---------------------------------------------
	6)插入分页符
	文档对象.add_page_break() 
		--> ctype: None,即添加分页符