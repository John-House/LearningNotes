宿主机的命令行操作
==========================================
	docker [opts] <child-cmd> [child-cmd-args]
		--> [opts] ,即可选的命令参数,可以是:
				--help 					->  列出所有可用的命令；
				--version				->  列出Docker版本信息后退出；
				--debug					->  启用调试模式；

				--config confDirPath	->  指定客户端配置文件所在的'目录路径'(默认为'用户家目录/.docker')；
				--log-level level 		->  指定日志级别(例如: debug < info < warn < error < fatal,默认为info)；

				--tlsverify				->  启用TLS和远程认证；
				--tlscert filePath		->  指定TLS证书文件的所在路径；
				--tlskey filePath		->  指定TLS密钥文件的所在路径；
				--tlscacert filePath 	->  指定签名其他证书的证书文件的所在路径；
		
		--> <child-cmd> ,即子命令(以'docker [opts]'开头,配合[child-cmd-args]一起使用),可以是:
				##	基本信息的子命令
				--------------------------------------
				info [-f 'Go_format']
					-> 	显示Docker的系统信息(多用于检测Docker是否安装成功)；
					->  -f 'Go_format' ,即按照Go语言模板格式显示Docker的系统信息；
				
				inspect [-f 'Go_format'] obj_nameorid [obj_nameorid ...]
					->  显示底层Docker对象的详细信息(以JSON形式返回结果)；
					->  -f 'Go_format' ,即按照Go语言模板格式显示Docker对象的详细信息；

				##	镜像相关的子命令
				--------------------------------------
				build [options] path/url
					->  根据某个'文件/目录'或'链接'构建一个镜像；
						注意: 可以在'构建上下文'目录中,创建'.dockerignore'文件来忽略构建镜像不需要的东西；
					->  options ,即构建镜像的额外配置,常用的是:
							-f fileName ,即指定Docker在'构建上下文'目录自动寻找的文件名(默认是寻找'Dockerfile'文件)；
							--t repoName:tag ,即为新建的镜像指定仓库名和标签,该选项可以重复；
											  注意: 若是私有仓库,则格式为'userName/repoName:tag'；
							--label key=val ,即为新建的镜像配置元数据,该选项可以重复；
							--no-cache ,即在构建镜像的过程中,不缓存每一步产生的中间镜像；
							--build-arg var=val ,即为Dockerfile文件中'ARG'指令声明的变量动态赋值,该选项可以重复；

					->  path/url ,即构建镜像的源数据,可以是:
							path	->  可以链接至一个'文件'(包括'标准输入')
										注意: 该情况下,没有'构建上下文'目录且'-f filePath'无效,docker会根据该文件(必须叫'Dockerfile')构建镜像
									->  可以链接至一个'目录'(即'构建上下文'目录)
										注意: 该情况下,'目录'即为'构建上下文'目录,docker会自动寻找'构建上下文'目录中的'Dcokerfile'文件构建镜像
							url		->  可以链接至一个'tar包',例如: http://server/context.tar.gz
									->  可以链接至一个'Git仓库',形如: https://repo-url[#[分支]][:分支下的目录名]'
										注意: 该情况下,'分支下的目录'即为'构建上下文'目录(若未声明,则'仓库主目录'即为'构建上下文'目录),docker会自动寻找'构建上下文'目录中的'Dcokerfile'文件构建镜像
				
				pull [-a] repoURL[:tag]
					->  从repoURL仓库拽取一个镜像；
					->  -a ,即从repoURL仓库拽取'所有带标签'的镜像；
					->  repoURL[:tag] ,即待拽取的镜像(可以额外指定'标签名'来确定具体的镜像；若未声明,则默认为latest标签)；
				
				tag src_image[:tag] dest_image[:tag]
					->  将src_image镜像关联至dest_image镜像；
					->  src_image ,即源镜像(通常为: 镜像名 | 镜像ID | 镜像名:标签名, 例如: httpd:test)
					->  dest_image ,即目的镜像(通常为: 镜像URL:标签名, 例如: myregistryhost:5000/fedora/httpd:version1.0)

				push repoURL[:tag]
					->  向repoURL仓库推送一个镜像；
						注意: 事先使用'tag子命令'将'待推送的镜像'(即源镜像)关联至'推送后的镜像'(即目的镜像)；
					->  repoURL[:tag] ,即推送后的镜像(可以额外指定'标签名'来标识推送后的镜像)；

				load [--input filePath]/[< filePath]
					->  将'标准输入'导入至一个镜像；
					->  --input filePath ,即从'filePath'导入镜像；
					->  < filePath ,即借助重定向从'filePath'导入镜像；

				save [--output filePath] image [image ...] [> filePath]
					->  将一个或多个镜像导出至'标准输出'(保存'历史信息'和'元数据')；
						注意: 该操作的结果文件略大；
					->	--output filePath ,即导出至'filePath'文件；
					->  > filePath ,即借助重定向导出至'filePath'文件；
					->  image ,即待保存的镜像(可以带'标签名',例如: ubuntu:lucid)
				
				import -_or_filePath_or_URL [image[:tag]]
					->  将标准输入/一个tar包导入(或新建)至一个镜像；
				
				rmi [options] image [image ...]
					->  移除一个或多个镜像；
					->  options ,即移除镜像的额外配置,可以是:
							-f ,即强制移除镜像(即使有多个标签指向该镜像)；
					->  image ,即待移除的镜像(image的表现形式可以是: 镜像名:标签名 | 镜像短ID | 镜像全ID)；
				
				history [options] image
					->  列出一个镜像的历史信息；
					->  options ,即列出信息的额外配置,可以是:
							-H ,即以适合阅读的形式列出文件大小和日期等信息；
							-q ,即仅列出镜像的ID信息；

				##	容器相关的子命令
				--------------------------------------
				run [options] imageURL[:tag] [cmd] [cmd-arg ...]
					->  根据imageURL[:tag]镜像创建容器后,再执行cmd命令；
					->  options ,即创建镜像或执行cmd命令的额外配置,可以是:
							-d 						,即后台运行新建的容器；
							-i 						,即将宿主机的标准输入关联至新建的容器；
							-t 						,即在新建的容器中创建伪TTY终端；
							--name string 			,即为新建的容器指定名字；
							--attach stdin/stdout/stderr 			,即将宿主机的'标准输入'、'标准输入'和'标准错误'关联至新建的容器,该选项可以重复；
							--expose [宿主机IP:]端口:容器端口[/协议] 	,即将宿主机的某个端口映射至新建容器的某个端口；
							
							--hostname=string 		,即为新建的容器指定主机名；
							--network mode 			,即为新建的容器指定网络模式；
													MODE 						EXPLAIN
													bridge						通过一对veth接口(其中一个位于宿主机,另一个位于容器的命名空间)搭建通信用的桥,
																				这样容器之间也可以通过IP地址进行通信(默认值)
													none						禁止容器与外部程序的网络连接,只能通过'文件I/O'或'标准输入/输出'通信
													host 						容器共享宿主机的网络模式
													container:ctnr_name_or_id	采用其他容器的网络模式
													custom_mode					自定义网络模式(即通过'network create子命令')
							--network-alias=[]		,即为新建的容器指定网络别名；
							--ip string				,即为新建的容器指定网卡的IPv4地址；
							--ip6 string			,即为新建的容器指定网卡的IPv6地址；
							--dns string			,即为新建的容器指定DNS服务器(默认遵循宿主机的DNS服务器配置)；
							--add-host host:IP 		,即向新建容器的'/etc/hosts'文件中添加'host:IP'(即主机名->IP地址的映射关系)；

							--mount ...      		,即为新建的容器挂载某些东西(该操作更灵活丰富,虽然挂载卷也可以使用'--volume path')；
							--tmpfs ...				,
							--volumes-from ctnr_name_or_id 		,即将ctnr_name_or_id容器中的所有卷挂载到新建的容器上；
							
							--restart=arg 			,即为新建的容器指定重启策略；
													ARG					EXPLAIN
													no					当该容器退出时,不自动重启(默认值)
													on-failure[:cnts]	仅当该容器非0状态退出时,最多重启cnts次
													unless-stopped 		仅当该容器被显示停止(或者Docker程序被停止或重启)时,自动重启	
													always				无视容器状态,总是自动重启

							--env key=val 			,即设置环境变量,该选项可以重复；
							--env-file filePath 	,即根据'filePath'文件设置环境变量；
							--label key=val  		,即为新建的容器添加'元数据',该选项可以重复；
							--label-file filePath 	,即为新建的容器添加'filePath'文件中的元数据(元数据之间通过换行符分隔)；
							--rm 					,即当新建的容器退出时,自动清除对应的文件系统；
							--cidfile filePath		,即将新建的容器ID写入'filePath'文件(必须不存在)；
							-w dirPath 				,即指定命令执行的当前工作目录；

							--cpu-shares=cnts 		,即指定新建的容器对CPU资源的占用权重(这是一个相对值)；
							--cpu-period=cnts 		,即指定在多少微秒后重新分配新建的容器对CPU资源的占用；
							--cpu-quota=cnts 		,即指定(在--cpu-period周期内)新建的容器最多可以占用CPU资源多少微秒；
					->  imageURL[:tag] ,即创建容器使用的镜像(必须全部是小写)；
							注意1: Docker优先在本地搜索该镜像；
							注意2: 若本地没有,则搜索'Docker Hub'并下载到本地；
							注意3: 若找到多个基本名镜像,则通过'标签名'确定具体的镜像(若未声明':tag',则默认为':latest')；
					->  cmd [cmd-arg ...] ,即待执行的完整命令(即必须声明执行程序,不能是纯命令内容),例如:
							docker exec -i -t my_container "echo a && echo b"		->	执行无效
							docker exec -i -t my_container sh -c "echo a && echo b"	->  执行有效
				
				exec [options] ctnr_name_or_id cmd [cmd-arg ...]
					->  在'正在运行'的容器(延迟或停止的都不行)中执行cmd命令；
					->  options ,即执行命令的额外配置,可以是:
							-d ,即分离模式(命令在后台执行)；
							-i ,即将宿主机的标准输入关联至容器；
							-t ,即在容器中创建伪TTY终端；
							-w dirPath ,即指定命令执行的当前工作目录；
							-e key=val ,即设置命令执行的环境变量；
							--detach-keys ,即若当前Docker容器的分离序列号与宿主机上的其他应用冲突,则可以通过该参数修改它
										   (若修改全局Docker容器的分离序列号,需要在'配置文件'中设置)；
					->  cmd [cmd-arg ...] ,即待执行的完整命令(即必须声明执行程序,不能是纯命令内容),例如:
							docker exec -i -t my_container "echo a && echo b"		->	执行无效
							docker exec -i -t my_container sh -c "echo a && echo b"	->  执行有效

				start [options] ctnr_name_or_id [ctnr_name_or_id ...]
					->  启动一个或多个容器；
					->  options ,即启动容器的额外配置,可以是:
							-i ,即启动时将宿主机的'标准输入'关联至容器；
							--attach ,即启动时将宿主机的'标准输出'和'标准错误'关联至容器；
							--detach-keys="分离序列号" ,即若当前Docker容器的分离序列号与宿主机上的其他应用冲突,则可以通过该参数修改它
													  (若修改全局Docker容器的分离序列号,需要在'配置文件'中设置)；

				pause ctnr_name_or_id [ctnr_name_or_id ...]
					->  延迟一个或多个容器中的所有进程(即使用SIGSTOP)；
				
				unpause ctnr_name_or_id [ctnr_name_or_id ...]
					->  恢复一个或多个容器中的所有进程；
				
				stop ctnr_name_or_id [ctnr_name_or_id ...]
					->  关闭一个或多个容器；

				restart ctnr_name_or_id [ctnr_name_or_id ...]
					->  重启一个或多个容器；
				
				rm [options] ctnr_name_or_id [ctnr_name_or_id ...]
					->  移除一个或多个容器；
					->  options ,即移除容器的额外配置,可以是:
							-f ,即强制移除'正在运行'的容器(即使用SIGKILL)；
							-v ,即一并移除挂载在容器上的所有卷；
					->  ctnr_name_or_id ... ,即待移除的容器名,可以借助其他命令的结果,例如: docker rm $(docker ps -a -q)

				rename ctnr_name_or_id new_ctnr_name_or_id
					->  重命名一个容器；
				
				export [--output filePath] ctnr_name_or_id [> filePath]
					->  将一个容器导出至'标准输出'(仅保存'容器状态')；
						注意: 该操作本质是导出容器的'文件系统',但不包括已挂载的所有卷；
					->	--output filePath ,即导出至'filePath'文件；
					->  > filePath ,即借助重定向导出至'filePath'文件；

				ps [options]
					->  列出所有'正在运行'的容器信息；
					->  options ,即列出容器的依据配置,常用的是:
							-a ,即列出所有的容器信息；
							-q ,即仅列出容器的ID信息；
							-s ,即列出容器的大小信息；
							-n cnts ,即列出最近创建的cnts个容器的信息；
							-f "key=val" ,即列出所有'key为val'的容器信息；
								KEY			VAL_EXAMPLE			EXPLAIN
								id			673394ef1d4c		列出所有ID为id的容器
								name 		str_or_substr		列出所有名字为name的容器
								label 		color				列出所有元数据为label的容器
								expose		80/tcp				列出所有暴露expose端口(及协议)的容器
																	expose的表现形式可以是: 端口 | 端口/协议名 | 端口-端口 | 端口-端口/协议名
								exited		0					列出所有退出状态为exited的容器
								status		running				列出所有运行状态为status的容器
																	运行状态的值可以是: created | restarting | running | removing | paused | exited | dead
								ancestor	ubuntu				列出所有继承自ancestor的容器
																	ancestor的表现形式可以是: 镜像名 | 镜像名:标签名 | 镜像短ID | 镜像全ID
								volume    	/data 				列出所有挂载了volume卷的容器
				
				stats [options] [ctnr_name_or_id ...]
					->  列出所有'正在运行'的容器的资源占用信息(包括: 容器ID、容器名、CPU占用比、内存当前使用量/内存允许最大使用量、
						内存占用比、网口发/收量、块设备读/写量、进程(或线程)ID等信息)；
					->  options ,即列出信息的额外配置,可以是:
							-a ,即列出所有容器的资源占用信息；

				top ctnr_name_or_id
					->  列出某个容器的进程；
				
				images [options] [repoURL[:tag]]
					->  列出容器中所有'顶级镜像'的信息(包括: 所属仓库、镜像标签、镜像短ID、镜像的创建时段和镜像大小等)；
					->  options ,即列出信息的额外配置,可以是:
							-a ,即列出所有镜像的信息(包括'中间镜像')；
							-q ,即仅列出镜像ID；
							-f "key=val" ,即列出指定镜像的信息；
								KEY			VAL_EXAMPLE			EXPLAIN
								dangling	true				列出所有没有标签(即dangling=true)或拥有标签(即dangling=false)的镜像
								label 		color				列出所有元数据为label的容器	
					->  repoURL[:tag] ,即列出指定仓库中所有(标签为tag的)镜像的信息；
				
				diff ctnr_name_or_id
					->  列出容器的文件系统变化(结果为带前缀的文件系统列表)；
						PREFIX		EXPLAIN
						A 			新添加的文件
						D 			已删除的文件
						C 			已改变的文件
					
				attach [--detach-keys="分离序列号"] [--no-stdin] ctnr_name_or_id 
					->  将宿主机的'标准输入'、'标准输入'和'标准错误'关联至某个'正在运行'的容器；
						该命令凿开了'本地终端'和'Docker容器'之间的通路,有助于用户通过'本地命令'控制或查看容器的运行及其结果；
					->	--detach-keys ,即若当前Docker容器的分离序列号与宿主机上的其他应用冲突,则可以通过该参数修改它
									   (若修改全局Docker容器的分离序列号,需要在'配置文件'中设置)；
					->  --no-stdin ,即取消'标准输入'的关联；

				port ctnr_name_or_id [ctnr_port[/protocal]]
					->  列出一个容器所有端口的映射信息(形如: 容器端口/协议 -> 宿主机IP:端口),例如:
						*	启动容器时,必须将宿主机的某个端口映射至容器的某个端口(通过run子命令),否则外部程序无法访问容器
							localhost:~ tianling$ docker prot ctnr_example
							7890/tcp -> 0.0.0.0:4321
							9876/tcp -> 0.0.0.0:1234
					->  ctnr_port[/protocal] ,即列出一个容器指定端口的映射信息；

				logs [options] ctnr_name_or_id
					->  获取容器的日志信息；
					->  options ,即获取日志的额外配置,可以是:
							--details ,即日志中显示细节信息；
							--timestamps ,即日志中显示时间戳；
							--since cnts ,即日志中显示最近cnts时间内的内容(例如: 42m)
							--tail cnts ,即日志中显示最后cnts行的内容

				cp [options] ctnr_name_or_id:src_path 	dest_path/-
				cp [options] src_path/- 	ctnr_name_or_id:dest_path 
					->  在宿主机和容器之间拷贝文件(若是容器一侧需声明'容器名')；
					->  options ,即拷贝文件的额外配置,可以是:
							-a	,即归档模式(拷贝所有的uid/gid信息)
							-L  ,即对于src_path总是拷贝原始文件(而不是符号链接)
					->  *_path ,即可以是文件或目录,'-'表示'标准输入'/'标准输出')
								可以是'相对路径'(宿主机一侧是相对于'当前工作目录',容器一侧是相对于'根目录')
								若src_path是'文件',则:
									dest_path不存在时,会创建'dest_path基本名'文件
									dest_path不存在且以'/'结尾时,会抛出'目录必须存在'的错误
									dest_path存在且为'文件'时,会dest_path会被覆盖
									dest_path存在且为'目录'时,会在dest_path目录下创建'源文件基本名'文件
								若src_path是'目录',则:
									dest_path不存在时,会创建'dest_path基本名'目录,将src_path目录拷贝至该目录下
									dest_path存在且为'文件'时,会抛出'不能将目录拷贝至文件'的错误 
									dest_path存在且为'目录'时,若src_path以'/'结尾时,src_path目录及其内容会拷贝至dest_path目录下
														   若src_path以'/.'结尾时,src_path目录中的内容会拷贝至dest_path目录下

				update [options] ctnr_name_or_id [ctnr_name_or_id ...]
					->  动态修改一个或多个容器的配置(可以是正在运行的,也可以是停止运行的)；
					->  options ,即容器的可选配置,常用的是:
							*	以下可选配置都是Docker对容器占用CPU资源的隔离和限制措施；
							*  	以下可选配置都是'完全公平调度'(即CFS,Completely Fair Scheduler)的,所有进程在某个周期内平分CPU的使用权(保证每个进程至少执行一次)；
							--cpu-shares=cnts ,即指定容器对CPU资源的占用权重(这是一个相对值)；
							--cpu-period=cnts ,即指定在多少微秒后重新分配容器对CPU资源的占用；
							--cpu-quota=cnts ,即指定(在--cpu-period周期内)容器最多可以占用CPU资源多少微秒；

Docker中的核心概念
==========================================
	基础
		1) Docker是基于客户端-服务器架构(即CS架构)的；
		2) Docker是使用Go语言开发的； 
		3) Docker内置docker程序,即可以作为客户端,又可以用作服务器端；
		   作为客户端,docker程序向Docker守护进程发送请求,并处理返回的请求结果；

	数据
		1) 默认情况下,一个容器中产生的所有文件都被储存在该容器的'读写层'中,这意味着:
				* 当容器不存在时,'读写层'中的数据也会消失,因为它们没有进行持久化；
				* 容器的'读写层'与宿主机紧密关联,所以很难迁移'读写层'中的数据；
		   因此,Docker中提供了3种'将数据保存至宿主机'的方法: '卷'、'绑定挂载'和'tmpfs挂载'；
		   注意1: 若一个'空卷'挂载至一个容器目录,该容器目录中'已存在'的数据会被'复制'到卷中；
		   注意2: 若一个容器挂载一个不存在的'卷',则结果是挂载一个'空卷'；
		   注意2: 若一个'非空卷'或'绑定挂载'挂载至一个容器目录,该容器目录中'已存在'的数据会被卷中的数据覆盖；
		
		2) Volumes
			卷是一些位于'宿主机'的文件系统,它们由Docker产生也由Docker管理(非Docker进程不应该去操作它)；
			卷分为'命名卷'和'匿名卷'(即首次被挂载时未命名)；
			卷可以被多个容器同时共享,但不属于容器的文件系统,因此对卷的数据修改不会影响镜像的更新,而卷的数据修改是立即生效的；
			卷一直都存在(即使没有任何容器挂载它),直到被'显式移除'；
			2.1) 应用场景
				* 需要在多个正在运行的容器之间共享数据；
				* 需要将容器中的数据储存在远端主机或云端；
				* 需要将数据从当前宿主机备份、恢复或迁移至其他宿主机；
		
		3) Bind Mounts 
			绑定挂载是一些位于'宿主机'的文件系统,但非Docker进程和Docker进程都可以随时操作它；
			不要求绑定挂载中的文件或目录事先存在(实际上,它们被挂载时若不存在会被自动新建)；
			3.1) 应用场景
				* 需要在宿主机和容器之间共享配置；
				* 需要在宿主机和容器之间共享源码或部署环境；
				* 需要某些文件系统在宿主机和容器中的结构保持一致；
			
		4) tmpfs Mounts
			tmpfs挂载,是储存在'宿主机内存'的一些数据,绝不会被写入宿主机的文件系统；
			tmpfs挂载存在于内存中,它们的生命周期与容器的生命周期一致；
			4.1) 应用场景
				* 需要储存安全性的、非持久化的数据；
				* 需要储存不希望保存在宿主机或容器中的数据；
	
	镜像
		镜像,即Docker中的单层或多层文件系统,它是构建容器的基本单元,运用了'联合加载'、'写时拷贝'和'分层框架'等技术；
		更官方的说法是,镜像是一个包含应用运行所必备的代码、运行环境、库文件、环境变量和配置文件等的'可执行软件包'。
		
		通常,一个镜像由多个'文件系统'叠加而成：
			1) 最底层是bootfs(即引导文件系统,启动容器后会被卸载)；
			2) 往上是rootfs(即root文件系统,通常是Ubuntu、CentOS等操作系统)；
			3) 在'联合加载'技术的帮助下,root文件系统又会在加载自身的同时,加载其他的只读文件系统。
			   这些其他的文件系统一层一层地叠加在root文件系统之上,而每个文件系统都可以被视作单个镜像。
			   按照从属关系,下面的镜像是其上方所有镜像的'父镜像',最底层的镜像(即root文件系统)也被称为'基础镜像'。
			4) 最顶层是读写层(即读写文件系统),容器中文件系统的任何变化和启动容器时执行的任何程序都会应用于该层,例如：文件的写时拷贝。
			
			这样,Docker中容器的概念也呼之欲出,即在'镜像分层框架'的作用下,包含'读写层'、'单个或多个镜像层'以及'相关配置数据'的结构体。
		
		命令中的'镜像名'
			在Docker中,镜像被存放在'仓库'(即Registry,俗称'Repository')中。
			仓库分为：官方运营的公共仓库Docker Hub和用户运营的私有仓库,而公共仓库Docker Hub又分为：用户(公共)仓库(由用户管理并公开,对应的仓库名格式为'用户名/仓库名'),以及
			顶级仓库(由Docker官方或Docker认证的其他官方管理,对应的仓库名格式为'仓库名')。
			
			在命令中指定'镜像名'时,其实指定的是存放镜像的'仓库名',但由于一个仓库可以存放多个镜像,为区分彼此Docker又为每个镜像添加了Tag(即标签功能)。
			这样,对于任意的'镜像名',我们都可以使用'仓库名:标签名'来指定它(注意：仓库名的格式也分为两种)。
			
			注意: 一个镜像可以对应多个标签名,但一个标签名只能对应一个镜像；

		自定义镜像
			在Docker中,我们可以基于'基础镜像'来自定义镜像。当然,这不是让我们重构文件系统代码,而是预置一些容器启动后要执行的程序。

			我们使用'Dockerfile文件和docker build命令'来自定义镜像：
				1) 创建'构建上下文'目录
					在构建自定义镜像时,Docker会将该目录及目录中的所有文件或子目录都传递给Docker的守护进程,以便其读取我们在该目录中配置的数据；
					在创建并启动容器时,该目录被当作'build子命令'中的'path/url'参数使用；
				
				2) 在构建上下文目录中创建'Dockerfile'文件
					'Dockerfile'文件中可以编写一系列的指令。在构建自定义镜像时,Docker会启动原始容器,然后从上到下依次执行该文件中的每条指令；
					每执行一条指令,docker程序就做出修改并保存；然后,再基于整个新镜像层启动一个新容器去执行下条指令。

					'Dockerfile'文件中的指令
						a) 所有的指令必须全是大写字母；
						b) 如果指令带有参数,推荐所有的参数以'字符串数组'的形式出现；

						注释
							# 注释内容
								--> 以'#'开头的行都被视作注释行；
						
						ARG指令
							ARG var[=value]
								--> 该指令位于FROM指令之前,它声明的变量通常仅用在FROM指令中；
									[=value],即为声明的变量赋予默认值,当然也可以通过'build子命令'动态传入值；
									在FROM指令之后,如果仍想使用该指令声明的变量,应先执行一次'ARG var'才能让var变量生效；

						FROM指令 
							FROM 镜像名[:标签名] [AS 别名]
								--> 设置'基础镜像',(除ARG指令外)该指令必须是文件中的'第一条指令'；
								--> [:标签名],即将'指定标签'对应的镜像设置为'基础镜像',默认使用'latest'标签对应的镜像；若'指定标签'不存在,构建自定义镜像返回错误；
								--> [AS 别名],即将'镜像名'映射至'别名',以便在后续的FROM或COPY等指令中使用；

						ENV指令
							ENV var1=value var=value...
								--> 为'后续指令'设置一个或多个'环境变量'；
									1) ENV指令是整个指令执行后才生效的；
										换言之：
											ENV abc=hello
											ENV abc=bye def=$abc
											ENV ghi=$abc
										结果：
											def -> hello
											ghi -> bye
										在执行'def=$abc'时,同一指令内的'abc=bye'尚未生效(即届时abc=hello)；
										在执行'ghi=$abc'时,上一行的整个指令生效,所以abc=bye；
									2) ENV指令可能覆盖ARG指令；
										换言之:
											ARG var=10
											EVN var=20
										结果:
											var -> 20
						
						RUN指令
							shell模式
							RUN [shell路径 -c] 命令1[; 命令...]
								--> 构建当前镜像时,执行对应的命令并提交保存；
									在shell模式下,该指令默认使用'/bin/sh -c'shell程序执行命令；
								--> [shell路径 -c],即使用其他shell程序执行命令,此时被执行的命令应加上''引号；
								--> 命令1[; 命令...],即执行多条命令时使用';'分隔。若命令整体较长,可使用'\'字符进行换行；
						
							exec模式
							RUN [["shell路径", "-c",] "命令1", "命令..."]
								--> 构建当前镜像时,执行对应的命令并提交保存；
									在exec模式下,该指令使用JSON数组解析命令,因此数组中的所有元素都必须加上""双引号；
								--> ["shell路径", "-c",],即使用其他shell程序执行命令；
								--> "命令1",即由于被视作JSON数组解析,所以shell中的展开特性无效。若命令中涉及展开变量,建议将其与命令主体写在一个""双引号中；

						ENTRYPOINT指令
							shell模式
							ENTRYPOINT 命令 参数1 参数...
								--> 启动容器时,执行对应的命令,在构建镜像期间该指令不生效；该指令不会被容器启动时宿主机命令行的命令所覆盖,相反,宿主机的命令及其参数最终会传递到该指令中执行；
									文件中仅限执行一条ENTRYPOINT指令。若声明多条,则仅执行最后一条；

							exec模式
							ENTRYPOINT ["命令", "参数1", "参数..."]
								--> 启动容器时,执行对应的命令,在构建镜像期间该指令不生效；该指令不会被容器启动时宿主机命令行的命令所覆盖,相反,宿主机的命令及其参数最终会传递到该指令中执行；
									文件中仅限执行一条ENTRYPOINT指令。若声明多条,则仅执行最后一条；
									在exec模式下,该指令使用JSON数组解析命令,因此数组中的所有元素都必须加上""双引号；
								--> "命令",即由于被视作JSON数组解析,所以shell中的展开特性无效。若命令中涉及展开变量,建议将其与命令主体写在一个""双引号中；
							
						ONBUILD 其他指令
							在构建镜像的过程中,ONBUILD指令像一个'触发器',它被视作新建镜像的元数据的一部分(即可以通过'inspect子命令'查看)；
							当'其他镜像'将'拥有ONBUILD指令的镜像'作为自己的'基础镜像'时,'其他镜像'会在自己的'FROM指令'之后执行那些事先定义的ONBUILD指令；
							ONBUILD指令中不能定义'FROM'、'ONBUILD'和'MAINTAINER'等造成递归调用的指令；

						CMD指令
							shell模式
							CMD 命令 参数1 参数...
								--> 启动容器时,执行对应的命令,在构建镜像期间该指令不生效；该指令可以被容器启动时宿主机命令行的命令所覆盖；
									文件中仅限执行一条CMD指令。若声明多条,则仅执行最后一条；
									在shell模式下,该指令默认使用'/bin/sh -c'shell程序执行命令；
							
							exec模式
							CMD [["shell路径"], "命令", "参数1", "参数..."]
								--> 启动容器时,执行对应的命令,在构建镜像期间该指令不生效；该指令可以被容器启动时宿主机命令行的命令所覆盖；
									文件中仅限执行一条CMD指令；若声明多条,则仅执行最后一条；
									在exec模式下,该指令使用JSON数组解析命令,因此数组中的所有元素都必须加上""双引号；
								--> ["shell路径"],即使用其他shell程序执行命令；
								--> "命令",即由于被视作JSON数组解析,所以shell中的展开特性无效。若命令中涉及展开变量,建议将其与命令主体写在一个""双引号中；
							
							参数模式
							CMD ["参数1", "参数..."]
								--> 执行ENTRYPOINT指令时,为其提供默认参数；
									在构建镜像时,该指令紧跟在ENTRYPOINT指令之后；
						
						LABEL指令
							LABEL key1="value1" key="value"...
								--> 为镜像设置一个或多个元数据；
									注意:
										1) 若表示元数据的键值对较长,可使用'\'字符进行换行；
										2) 一个镜像中可以存在多条LABEL指令；
										3) 不同镜像中同一key键的元数据,其值由最后构建的镜像决定(先构建的元数据会被覆盖)；
										4) 元数据的形式更加灵活方便,足以代替已弃用的'MAINTAINER'指令；

						EXPOSE指令
							EXPOSE 端口号[/协议名]
								--> 监听镜像TCP协议下的'端口号'； 
									该指令其实是Docker中的一种协议,即将宿主机的端口号映射至容器中EXPOSE指令所公开的端口号,
									而宿主机的端口号可以由宿主机命令行的docker run命令指定,也可以由宿主机的系统自动分配；
								--> [/协议名],即默认监听的是TCP协议下的端口,也可以是设置为UDP,例如：EXPOSE 80/udp

						WORKDIR指令
							WORKDIR 镜像中的当前工作目录
								--> 为文件中的后续指令设置'当前工作目录',若该目录不存在,docker程序会自动创建；
									文件中该指令可以执行多次；
								--> 镜像中的当前工作目录,如果该目录的声明为'相对路径',则是基于上一条WORKDIR指令设置的路径；该目录的声明中可以存在文件中已声明的各种变量；

						ADD指令
							ADD [--chown=uid:gid] 源文件1 源文件... 镜像中的路径
								--> 将'构建上下文'目录中的一个或多个'文件/目录'拷贝至镜像的指定路径；
								--> [--chown=uid:gid],即设置被拷贝的所有'文件/目录'的uid和gid,也可以使用'用户名'和'用户组名'；
								--> 源文件,即基于‘构建上下文’目录的'相对路径名',这些路径名可以使用'通配符'规则；
										注意1：这些'源文件'可以是URL地址(当然,如果无法下载它们的话,就只能使用其他命令下载到本地了,例如：RUN wget)；
											  如果源文件的URL地址以'/'结尾,则会以'目录'的形式拷贝至镜像中,如果不以'/'结尾,则会以'文件'的形式；
										注意2：如果'源文件'是目录,则该目录不会被拷贝,拷贝的是该目录中的所有文件和子目录；
										注意3：如果'源文件'是tar包,则会自动解压成目录,然后按照注意2处理；
										注意4：如果指定了多个源文件,则'镜像中的路径'必须是一个目录(即以'/'结尾)；
								--> 镜像中的路径,即'绝对路径名'或基于WORKDIR的'相对路径名',
										该路径下被拷贝的所有'文件/目录'的默认uid为0、gid也为0,该路径过程中所有不存在的目录都会被自动创建；

						VOLUME指令 
							VOLUME ["挂载点路径1", "挂载点路径..."]
								--> 为基于当前镜像的容器设置一个或多个卷；
									在VOLUME指令声明了挂载点路径后,如果有后续指令对该路径下的任何数据做出修改,则这些修改都将无效；
								--> "挂载点路径",即由于被视作JSON数组解析,所以必须使用""双引号；

						USER指令
							USER uid[:gid]
								--> 为启动的容器或文件中的后续指令设置对应的uid和gid；
								--> uid[:gid],即默认gid为0；uid和gid也可以使用'用户名'和'用户组名'；
						
	容器
		|----------|		|----------|		|----------|
		|应用一		|		 |应用二	 |		  |应用三	  |
		|所需文件和库|		  |所需文件和库|		|所需文件和库|
		|----------|		|----------|		|----------|
			/|\					/|\					/|\
			 |-------------------|-------------------|
			 					 |
							Docker守护进程(即Docker服务器,也称作Docker引擎)
								 |
							宿主机操作系统
								 |
							宿主机硬件设备
		* 虚线框,即表示一个容器