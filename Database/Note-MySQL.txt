"""
基本概念
=============================================
	1.三层架构
		a) 面向客户端的'连接处理和权限验证'架构：
		   * 连接处理(为每个客户端连接分配单独的线程处理其请求)
		   * 权限验证('访问账户验证'和'操作权限验证')
		b) 面向服务器的'核心服务'架构；
		   * 查询缓存
		   * 预解析(关键字验证、解析树)、预处理(请求数据是否存在、别名是否冲突、权限验证)、优化器(生成执行计划)
		   * 视图、存储程序、触发器、事件等
		c) 面向底层引擎的'存储引擎'架构；
		   * 响应上层交互(数据的存储和提取，索引的处理，不同存储引擎之间无法通信)

	2.库表定义
		a) 每个数据库保存为'数据目录'下的一个子目录
		b) 每张表保存为'子目录'下的一个.frm文件(Windows系统对表名的大小写不敏感，类Unix系统对此敏感)
		c) 不同的存储引擎对表和索引的定义以及数据有着不同的存放规则：
		   * InnoDB的表和索引定义存放在.ibd文件，数据存放在表空间(即tablespace)
		   * MyISAM的表和索引定义存放在.myi文件，数据存放在.myd文件

	3.事务的ACID原则：A - 原子性，C - 一致性，I - 隔离性，D - 持久性
		隔离级别：
			READ UNCOMMITTED	->  未提交读
			READ COMMITED		->  提交读(即不可重复读)，大多数数据库的默认隔离级别
			REPEATABLE READ		->  可重复读，MySQL的默认隔离级别
			SERIALIZABLE		->  可串行化

	4.多数数据库采用'表锁'，MySQL通过MVCC(即多版本并发控制，行级锁的变种，用于提高数据库并发性能，常见的有：乐观并发控制、悲观并发控制)实现了'行锁'

	5.MySQL的默认引擎是事务型引擎InnoDB，该引擎支持热备份，采用MVCC来支持高并发，默认隔离级别为REPEATALBE READ，并通过<间隙锁>来防止<幻读>的出现，

配置文件
=============================================
	* MySQL的配置文件分成多个部分，每个部分的开头都用方括号标记，形如[xxxx]； 
	  不同的程序会读取不同的部分，例如：客户端程序通常读取[client]部分，服务器通常读取[mysqld]等等；



基准测试
=============================================
	1.Sysbench(即基于LuaJIT的'多线程'基准测试工具)
		* 下载网址: https://launchpad.net/sysbench 或者 https://github.com/akopytov/sysbench
		* 语法(命令行环境)
			sysbench --help
				--> 显示sysbench的用法；

			sysbench testname help
				--> 显示sysbench中内置测试的用法；

			sysbench [options...] [testname] [cmd]
				--> options ,(可选)即以'--'开头的一个或多个配置项,常见的有:
						--config-file=path 				->  表示写有options配置信息的文件路径
						
						--threads=cnt					->  表示测试使用的工作线程数(默认为1)
						--thread-stack-size=cnts		->  表示测试的每个工作线程的栈大小(默认为32K)
						--thread-init-timeout=cnt		->  表示测试的工作线程初始化的秒数(默认为30)

						--events=cnt					->  表示测试的最大请求数(默认为0,即无限制)
						--time=cnt						->  表示测试的最大执行秒数(默认为0,即无限制)
						--rate=cnt						->  表示测试的平均事务率,即所有工作线程平均每秒应该执行的事务量(默认为0,即无限制)
						--warmup-time=cnt 				->  表示测试的预热时间,该期间内不统计测试数据(默认为0)
						--verbosity=cnt					->  表示测试的Log显示级别(默认为4,0-仅显示critical信息,5-显示debug信息)
						
						--db-driver=str					->  表示测试的主体(默认为mysql)
						--mysql-host=str				->  表示测试的MySQL主机(默认为localhost)
						--mysql-port=str				->  表示测试的MySQL端口(默认为3306)
						--mysql-user=str				->  表示测试的MySQL用户(默认为sbtest)
						--mysql-password=str 			->  表示测试的MySQL密码(默认为空)
						--mysql-db=str 					->  表示测试的MySQL数据库(默认为sbtest)

						--debug=flag 					->  启用或禁止打印调试信息(默认为off)
						--report-interval=cnt 			->  表示周期性(按秒计算)报告中间状态的统计数据(默认为0)
						--report-checkpoints=cnt,...	->  表示测试的备份节点,即测试开始后多少秒处备份统计数据(每次备份重置秒数计时)
				
				--> testname ,(可选)即内置测试名,常见的有:
						oltp_read_only					##  表示测试在线事务处理能力
							--tables=cnt              	->  表示测试中表的总数(默认为1)
							--table_size=cnt         	->  表示测试中每张表的行数(默认为10000)
							--mysql_storage_engine=str 	->  表示测试中Mysql使用的引擎(默认为innodb)
							--auto_inc=flag         	->  表示使用自增列作为主键,否则需客户端指定IDs(默认为on) 
							--create_secondary=flag 	->  表示创建(指向主键索引的)二级索引(默认为on)
							--secondary=flag	        ->  表示测试中使用二级索引替代主键索引(默认为off)
							
							--delete_inserts=cnt   		->  表示每个事务中'delete/insert'操作的数量(默认为1)
							
							--index_updates=cnt         ->  表示每个事务中'update'(更新索引)操作的数量(默认为1) 
							--non_index_updates=cnt     ->  表示每个事务中'update'(更新非索引)操作的数量(默认为1)

							--distinct_ranges=cnt       ->  表示每个事务中'select distinct'操作的数量(默认为1)
							--simple_ranges=cnt         ->  表示每个事务中'简单范围select'操作的数量(默认为1)
							--sum_ranges=cnt            ->  表示每个事务中'select sum()'操作的数量(默认为1)
							--point_selects=cnt         ->  表示每个事务中'point select'操作的数量(默认为10)
							--range_selects=flag    	->  表示是否测试'all range select'操作(默认为on)
							--range_size=cnt            ->  表示'range select'操作的范围大小(默认为100)
							--order_ranges=cnt          ->  表示每个事务中'select order by'操作的数量(默认为1)

							--pgsql_variant=redshift    ->  当测试的主体为PostgreSQL时,仅限取值'redshift'(届时--create_secondary=off且--delete_inserts=0)
						
						fileio							##  表示测试文件I/O能力
							--file-num=cnt				->  表示测试中创建的文件总数(默认为128)
							--file-total-size=cnt		->  表示测试中创建的文件总大小(默认为2G)
							--file-test-mode=flag 		->  表示测试文件I/O的类型(seqwr-顺序写入,seqrewr-顺序重写,seqrd-顺序读取,
																		  	   rndwr-随机写入,rndrd-随机读取,rndrw-随机混合读/写)
							--file-rw-ratio=cnt			->  表示测试中混合读/写测试的比例(默认为1.5)
							--file-block-size=cnt		->  表示测试中所有I/O操作的块大小
						
						cpu 							##  表示测试CPU计算能力
							--cpu-max-prime=cnt 		->  表示测试CPU生成cnt个素数的时间(默认为10000)
						
						memory 							##  表示测试内存处理速度
						
						threads 						##  表示测试线程调度能力
							--thread-locks=cnt 			->  表示测试中每个工作线程的锁数量(默认为8)
							--thread-yields=cnt			->  表示测试中每个请求yield的次数(默认为1000)
					
						mutex 							##  表示测试互斥锁功能
				
				--> cmd ,(可选)即testname测试的执行类型,常见的有:
						run								->  表示开启testname测试
						prepare							->  表示做好testname测试的准备工作
						cleanup							->  表示移除testname测试产生的临时数据
						help							->  表示显示testname测试的用法信息

服务器和客户端编程
=============================================
	1.服务器编程
		* mysqld，即MySQL服务器，它管理着数据目录(存放了库、表、日志文件和状态文件等)的入口。当MySQL服务器启动后，它监听着来自客户端(或客户端代理)的网络连接；
		* mysqld，有许多可配置的系统变量，这些变量可以在MySQL服务器启动时配置，也可以在运行时配置；
		在终端输入'mysqld --verbose --help'命令可以查看所有启动时的配置项，在运行时输入'mysqladmin variables'命令可以查看所有使用中的配置项；

	2.客户端编程
		* mysql，即可编辑的带输入行的SQL shell客户端，在交互模式和非交互模式下都有许多的操作命令；
			非交互模式：
				>>> 核心命令
					mysql -h 服务器主机名 -P 服务器端口号 -u 用户名 -p[密码] -D 数据库名
						->  即使用'指定用户名'和'密码'去连接'指定主机'和'指定端口'下的'指定数据库'；通常-p后会省略密码，以防止明文形式的密码被泄露；
				>>> (常用)追加命令
					... --bind-address=IP地址     ->  即当客户端存在多个网络接口时，指定使用哪个去连接服务器
					... --delimiter=字符串        ->  即设置连接服务器后，声明语句时使用的定界符，默认为';'
					... --reconnect              ->  即设置断开服务器连接后，自动设法重连
					... --max_allowed_packet=xx  ->  即设置客户端和服务器之间的最大缓存数，默认为16M，最大为1GB；
					... < [/xx/xx/]文件名		  ->  即执行指定路径下文件(含后缀名)中的所有声明语句；
					-e 'SQL语句;...' 			  ->  即执行SQL语句后断开服务器连接；

			交互模式：
				>>> (常用)命令
					[...] \c                     ->  即清空当前输入的内容，并开启新的输入行；
					...   \g 		   		     ->  即将当前输入的内容发送至服务器执行，并将返回结果按<表格结构>展示；
					...   \G                     ->  即将当前输入的内容发送至服务器执行，并将返回结果按<竖向结构>展示；
					[...] \q                     ->  即断开服务器连接；
					\u 数据库名	 	              ->  即将'数据库名'作为默认的数据库
					\. [/xx/xx/]文件名            ->  即执行指定路径下文件(含后缀名)中的所有声明语句；
					\T /xx/xx/文件名		      ->  即将后续的所有执行语句及其结果保存至指定路径下的文件(含后缀名)中，多用于debug调试；
					\d 字符串                     ->  即在后续的操作中语句的定界符修改为'指定的字符串'；

		* mysqldump，即执行逻辑备份的客户端，它会生成一系列可执行的SQL声明(用于在原库、表中重新生成数据)，它既可以为当前数据库做备份，也可以将数据转移至其他的MySQL服务器；
			>>> 核心命令
				mysqldump -h 服务器主机名 -P 服务器端口号 -u 用户名 -p[密码] 数据库名 [表名1 表名2 ...] [options] -r /xx/xx/文件名
					->  即在options配置项下，将'指定数据库'中的一张或多张'表'备份至'指定路径下的文件'中；通常-p后会省略密码，以防止明文形式的密码被泄露；

				mysqldump -h 服务器主机名 -P 服务器端口号 -u 用户名 -p[密码] -B 数据库名1 数据库名2 ... -r /xx/xx/文件名
					->  即在options配置项下，将一个或多个'指定数据库'备份至'指定路径下的文件'中；通常-p后会省略密码，以防止明文形式的密码被泄露；

				mysqldump -h 服务器主机名 -P 服务器端口号 -u 用户名 -p[密码] --A -r /xx/xx/文件名
					->  即在options配置项下，将整个'MySQL服务器'备份至'指定路径下的文件'中；通常-p后会省略密码，以防止明文形式的密码被泄露；

账户管理和权限系统
=============================================
	* MySQL的权限系统：
		1. 无法准确匹配某位用户并拒绝他的连接；
		2. 可以阻止某位用户创建或删除数据库，但无法阻止他在该数据库中创建或删除表；
		3. 可以授予全局的账户密码，但无法为具体的库、表或存储程序设置密码；
		4. 权限系统的信息默认存储在'mysql'数据库的多张授权表中；
		5. 权限系统通过连接服务器的主机名和账户名交叉定位用户；
		6. 权限系统大体分2步：a. 用户连接服务器，服务器验证密码并反馈信息，b. 用户连接后在涉及任何权限操作前，服务器都会验证该账户的权限范围；

	* 系统级数据库'mysql'中的授权表，每张授权表中的列都分为'范围列'和'权限列'两种；
	  '范围列'用于指定当前行数据适用的上下文(即场景)，'权限列'用于指定当前行数据能够执行的操作有哪些：
		1. user表          ->  包含账号名、全局权限和其他非权限信息；user表中的'范围列'用于验证连接是否成功，(若成功)'权限列'均为全局权限，适用于服务器中所有的数据库；
		2. db表            ->  包含数据库级别的权限；db表中的'范围列'用于确定哪些用户可以进入哪个服务器中的哪个数据库，'权限列'用于确定能够执行哪些操作；
		3. tables_priv表   ->  包含表级别的权限；
		4. columns_priv表  ->  包含列级别的权限
		5. procs_priv表    ->  包含存储过程和存储函数的权限；
		6. proxies_priv表  ->  包含代理用户的权限；

	* 账户名，形如：'用户名'@'主机名'；可以使用current_user或current_user()来代替'当前账户名'；
		* 若账户名仅由用户名构成，则为'用户名'@'%'；若账户名仅由主机名构成，则为匿名用户，形如：''@'主机名'；
		* MySQL根据账户名来验证连接，若'用户名'为''，则表示接收任意的用户(但还得看'主机名'部分)，若'主机名'中出现'%'，则表示该部分的值可以任意：
			'john'@'h1.example.net' ->  允许来自'h1.example.net'的john连接MySQL服务器
		    'john'@'%' 				->  允许来自任何主机的john连接MySQL服务器
			'john'@'%.example.net'  ->  允许来自'example.net'域名的任何主机的john连接MySQL服务器
		    'john'@'198.51.100.%'   ->  允许来自'198.51.100'网段下的任何主机的john连接MySQL服务器
		    ''@'%' 					->  允许来自任何主机的任何用户连接MySQL服务器
		    ''@'h1.example.net'     ->  允许来自'h1.example.net'的任何用户连接MySQL服务器

	* MySQL中通过insert、update或delete等SQL语句修改'mysql'中的授权表数据，是无法让账户等信息立即生效，必须重启服务器才能生效；
	  若想立即生效，你需要通过grant、revoke、或rename user等SQL语句；

	* MySQL的加密连接:
		1. MySQL客户端和服务器之间的普通连接，可能造成数据被监听和窃取。因此，当传输重要数据时，建议使用加密连接(主从复制之间也可以使用加密连接)；
		2. MySQL中使用TLS协议搭建加密连接，不使用SSL协议是因为它比较脆弱(虽然很多人将SSL和TLS混为一谈)；
		3. 若MySQL服务器支持加密连接，则优先使用加密连接，若无法接通，再使用普通连接；
		4. 服务器的加密连接配置(服务器默认开启--ssl配置项，即允许但不强求客户端进行加密连接)；
		   --ssl-ca=xx/xx/ca证书文件名.pem

		   --ssl-cert=xx/xx/服务器公钥文件名.pem

		   --ssl-key=xx/xx/服务器私钥文件名.pem

		       a. 服务器在启动时可以使用OpenSSL自动生成生成证书和私钥文件，也会自动到MySQL的数据目录下寻找它们；
		       	  若启用(默认启用)系统变量auto_generate_certs，则服务器会在MySQL的数据目录下自动生成服务器及客户端的SSL证书和相关的钥匙文件；
		       	  当MySQL数据目录下缺少以下任一文件时，服务器都会自动创建它们(并附上一些额外文件):
		       	      ca.pem 			->  自签名的CA证书文件
		       	      ca-key.pem 		->  CA证书的私钥文件
		       	      server-cert.pem   ->  服务器证书文件
		       	      server-key.pem 	->  服务器私钥文件
		       	      client-cert.pem 	->  客户端证书文件
		       	      client-key.pem 	->  客户端私钥文件
		   	   b. 可以通过系统变量tls_version，显示指定加密连接使用的协议；
		5. 客户端的加密连接配置
		   --ssl-ca=xx/xx/(与服务器相同的)ca证书文件名.pem

		   --ssl-cert=xx/xx/客户端公钥文件名.pem

		   --ssl-key=xx/xx/客户端私钥文件名.pem

		   --ssl-cipher=加密方式1[:加密方式2:...]   ->  例如，--ssl-cipher=DHE-RSA-AES128-GCM-SHA256:AES128-SHA

		       a. 客户端通过--ssl-mode配置项控制加密连接：
		       	  --ssl-mode=preffered           ->  优先使用加密连接(等价于省略--ssl-mode配置项)
		       	  --ssl-mode=required            ->  要求客户端使用加密连接，否则连不上；
		       	  --ssl-mode=disabled            ->  客户端使用普通连接；
		       	  --ssl-mode=verify_ca           ->  客户端使用普通连接，但需要进行CA证书验证；
		       	  --ssl-mode=verify_identity     ->  客户端使用普通连接，但需要进行CA证书验证及证书中的服务器主机名验证；

支持的数据类型
=============================================
	1.数字类型
		a) 基本信息
			* 数字类型的最大展示位数(即255，通常用M表示)与其能够存储的最大数值无关；
			* 数字类型作为表的列类型时，该列的值默认为SIGNED，若指定了ZEROFILL参数，则该列的值变为UNSIGNED；
		b) 类型细分
			* unsigned 	->  该声明表示定义的是无符号的数字类型；
			* zerofill 	->  该声明表示若实际数值不满足展示位数，则展示时用0填充空位；
			* serial 	->  该声明等价于bigint unsigned not null auto_increment unique；
			bit[(M)]
				--> 位-数字类型，每个值都为M(1~64)位，受到MyISAM、MEMORY、InnoDB和NDB引擎支持；
					当存储该类型的值时，输入b'xxx'或0~2**M之间的整数，同时当输入值不足声明的位数M时会进行0的左补位；
				--> M默认为1；
			tinyint[(M)] [unsigned] [zerofill]
				--> 极小整数-数字类型，每个有符号(默认)的值都在-128~127之间，每个无符号的值都在0~255之间；
				--> 存储大小为'1字节'；
			smallint[(M)] [unsigned] [zerofill]
				--> 小整数-数字类型，每个有符号(默认)的值都在-32768~32767之间，每个无符号的值都在0~65535之间；
				--> 存储大小为'2字节'；
			mediumint[(M)] [unsigned] [zerofill]
				--> 中小整数-数字类型，每个有符号(默认)的值都在-8388608~8388607之间，每个无符号的值都在0~16777215之间；
				--> 存储大小为'3字节'；
			int/integer[(M)] [unsigned] [zerofill] [auto_increment]
				--> 整数-数字类型，每个有符号(默认)的值都在-2147483648~2147483647之间，每个无符号的值都在0~4294967295之间；
				--> 存储大小为'4字节'；
				--> int和float类型具有额外的auto_increment声明，启用auto_increment后：
				向该列插入 null(需要该列声明not null) 或 0(需要启用no_auto_value_on_zero) 时，插入值自动转换为'当前列最大值+1'；
			bigint[(M)] [unsigned] [zerofill]
				--> 大整数-数字类型，每个有符号(默认)的值都在-9223372036854775808~9223372036854775807之间，
					每个无符号的值都在0~18446744073709551615之间；
				--> 存储大小为'8字节'；
			decimal/dec/fixed[(M[,D])] [unsigned] [zerofill]
				--> 精确小数-数字类型，M声明总位数(不包括符号)，D声明小数位数；
					若未声明unsigned，则禁止负值；
					MySQL内部使用二进制存储decimal类型；
				--> 默认M为10(最大65)，D为0(最大30，即默认不包括小数部分)；
			float[(M,D)] [unsigned] [zerofill] [auto_increment]
				--> 单精浮点数-数字类型，M声明总位数(不包括符号)，D声明小数位数；若声明unsigned，则禁止负值；
					MySQL默认使用双精浮点数计算，所以float可能造成不可期的问题；同时单精浮点数属于近似值，使用它进行比较也可能造成一定的问题；
				--> 存储大小为'4字节'；
				--> 默认D为7；
			double[(M,D)] [unsigned] [zerofill]
				--> 双精浮点数-数字类型，M声明总位数(不包括符号)，D声明小数位数；
					若声明unsigned，则禁止负值；
				--> 存储大小为'8字节'；
				--> 默认D为15；

	2.日期/时间类型
		a) 基本信息
			* 日期/时间类型中的time, datetime和timestamp，允许值出现小数位(即最多表示到6个小数位的'微秒')；
		b) 类型细分
			* fsp ->  该声明仅用于个别类型，且值位于0~6之间；若省略，则默认为0；
			year[(4)]
				--> 四位年份-日期/时间类型，每个值都在1901~2155(或'1901'~'2155')以及0000之间；
				--> year(2)类型在 MySQL 5.7.5 中被废除；
				--> 插入值'0'或0是0000的快捷输入；
				--> 存储大小为1字节(MySQL 5.6.4之后)；
			date
				--> 日期-日期/时间类型，每个值都在'1000-01-01'~'9999-12-31'之间，默认的展示格式为'YYYY-MM-DD'；
				--> 插入值'0'或0是'0000-00-00'的快捷输入；
				--> 存储大小为3字节(MySQL 5.6.4之后)；
			time[(fsp)]
				--> 时间-日期/时间类型，每个值都在'-838:59:59.000000'至'838:59:59.000000'之间；
					默认的展示格式为'HH:MM:SS[.小数位]'
				--> 插入值'0'或0是'00:00:00'的快捷输入；
				--> fsp默认为0；
				--> 存储大小为3字节+小数位字节(0位,0字节；1~2位,1字节；3~4位,2字节；5~6位,3字节)(MySQL 5.6.4之后)；
			timestamp[(fsp)]
				--> 时间戳-日期/时间类型，每个值都在'1970-01-01 00:00:01.000000'UTC~'2038-01-19 03:14:07.999999'UTC之间；
				--> 若服务器启用系统级变量 explicit_defaults_for_timestamp ，则所有timestamp类型的列都不会自动添加
					default current_timestamp 或 on update current_timestamp 声明(用户必须显示声明)；
					同时未显示声明not null，则允许timestamp类型的列为null值；
				--> 若服务器禁用系统级变量 explicit_defaults_for_timestamp ，则第一个timestamp类型的列在未赋值时，会自动变更为最近一次修改的日期/时间；
					你可以将任意timestamp类型的列赋值为null，从而让其自动设置为当前的日期/时间；
				--> 插入值'0'或0是'0000-00-00 00:00:00'的快捷输入；
				--> 存储大小为4字节+小数位字节(0位,0字节；1~2位,1字节；3~4位,2字节；5~6位,3字节)(MySQL 5.6.4之后)；
			datetime[(fsp)]
				--> 日期+时间-日期/时间类型，每个值都在'1000-01-01 00:00:00.000000'~'9999-12-31 23:59:59.999999'之间，
					默认的展示格式为'YYYY-MM-DD HH:MM:SS[.小数位]'；
				--> 插入值'0'或0是'0000-00-00 00:00:00'的快捷输入；
				--> fsp默认为0；
				--> 存储大小为5字节+小数位字节(0位,0字节；1~2位,1字节；3~4位,2字节；5~6位,3字节)(MySQL 5.6.4之后)；

	3.字符串类型
		a) 基本信息
			* 在许多情况下，字符串类型可以通过 create table或 alter table 语法声明转换成其他类型；
		b) 类型细分
			* character set/charset ->  该声明用于指定字符串的字符集；
			* collate ->  该声明用于指定上述指定字符集的排序规则；
			[national] char[(M)] [character set 字符集] [collate 排序规则名]
				--> 定长字符-字符串类型，若实际值不足声明的M时，采用空格右补位的方式；
					M(即字符串的长度)范围为0~255，默认为1；
				--> national声明是更标准的char类型列的声明方式；
				--> char(0) null的声明，让该列只用1位就拥有2个有效的输入值：null和''
			[national] varchar(M) [character set 字符集] [collate 排序规则名]
				--> 可变字符-字符串类型，MySQL内部存储时
					M(即字符串的最大长度)范围由字符集限定，一般为0~65535(像utf8，则为0~21844)，必须指定；
				--> varchar类型的存储形式为：1/2字节的前缀 + 实际值，前缀用于表示实际值的字节数，若实际值不超过255字节，则前缀为1字节；否则为2字节；
				--> national声明是更标准的char类型列的声明方式；
			binary[(M)]
				--> 二进制字节码-字符串类型，与char类型相似，但是二进制字符存储的是二进制字符串(即字节对象)，M表示按字节计算的长度，采用\0(即空字节)右补位的方式；
				--> M默认为1；
			varbinary(M)
				--> 可变二进制字节码-字符串类型，与varchar类型相似，但是可变二进制字符存储的是二进制字符串(即字节对象)，M表示按字节计算的最大长度；
			tinytext [character set 字符集] [collate 排序规则名]
				--> 极小文本-字符串类型，tinytext类型的理论最大字符长度为255(即2**8 - 1)，实际最大字符长度由指定的字符集决定；
				--> tinytext类型的存储形式为：1字节的前缀 + 实际值，前缀用于表示实际值的字节数；
				--> 无法指定默认值；
			text[(M)] [character set 字符集] [collate 排序规则名]
				--> 文本-字符串类型，text类型的理论最大字符长度为65535(即2**16 - 1)，实际最大字符长度由指定的字符集决定；
					若指定了M，则隐式使用足够存储M个字符但空间最小的text类型(tinytext、text、mediumtext或longtext)；
				--> text类型的存储形式为：2字节的前缀 + 实际值，前缀用于表示实际值的字节数；
				--> 无法指定默认值；
			mediumtext [character set 字符集] [collate 排序规则名]
				--> 中文本-字符串类型，mediumtext类型的理论最大字符长度为16777215(即2**24 - 1)，实际最大字符长度由指定的字符集决定；
				--> mediumtext类型的存储形式为：3字节的前缀 + 实际值，前缀用于表示实际值的字节数；
			longtext [character set 字符集] [collate 排序规则名]
				--> 长文本-字符串类型，longtext类型的理论最大字符长度为4294967295(即2**32 - 1)，实际最大字符长度由指定的字符集、client/server协议中规定的最大包尺寸和可用内存决定；
				--> longtext类型的存储形式为：4字节的前缀 + 实际值，前缀用于表示实际值的字节数；
			tinyblob
				--> 极小字节-字符串类型，tinyblob类型的理论最大字节长度为255(即2**8 - 1)；
				--> tinyblob类型的存储形式为：1字节的前缀 + 实际值，前缀用于表示实际值的字节数；
			blob[(M)]
				--> 字节-字符串类型，blob类型的理论最大字节长度为65535(即2**16 - 1)；
					若指定了M，则隐式使用足够存储M个字节但空间最小的blob类型(tinyblob、blob、mediumblob或longblob)；
				--> blob类型的存储形式为：2字节的前缀 + 实际值，前缀用于表示实际值的字节数；
				--> 无法指定默认值；
			mediumblob
				--> 中字节-字符串类型，mediumblob类型的理论最大字节长度为16777215(即2**24 - 1)；
				--> mediumblob类型的存储形式为：3字节的前缀 + 实际值，前缀用于表示实际值的字节数；
			longblob
				--> 长字节-字符串类型，longblob类型的理论最大字节长度为4294967295(即2**32 - 1)；
				--> longblob类型的存储形式为：4字节的前缀 + 实际值，前缀用于表示实际值的字节数；
			enum('value1', 'value2', ...) [character set 字符集] [collate 排序规则名]
				--> 枚举-字符串类型，每个enum类型的值都在'value1', 'value2', ..., ''和null(若允许)之间，MySQL内部使用int表示enum类型的值；
				--> 每个enum类型的列理论不重复的最大值数为65535(实际不超过3000)；
				--> 若允许null，则默认值为null；否则为value1；
				--> 存储大小为1,2字节（取决于每个值的大小)；
			set('value1', 'value2', ...) [character set 字符集] [collate 排序规则名]
				--> 集合-字符串类型，每个set类型的值都允许0个或多个，每个的选择都在'value1', 'value2', ...和''之间，MySQL内部使用int表示set类型的值；
				--> 每个set类型的列理论不重复的最大值数为64；
				--> 存储大小为1,2,3,4,8字节(取决于每个值中的个数)；

	4.JSON类型
		a) 基本信息
			* JSON类型的列支持在插入值时自动进行json格式的验证，无效的值会引起错误；
			* JSON类型的列在插入值时自动进行存储优化(即转换成内部的二进制格式)，这使得稍后读取这些数据时无需做字符串格式的解析，而是通过key或索引快速读取对应的值；
			* JSON类型的列的值大小受到系统级变量max_allowed_packet的限制，大体上等于longtext和longblob类型的大小；
			* JSON类型的列没有默认值，同时与其他二进制类型的列一样，无法直接建立索引(有其他办法)；
			* JSON类型的列值可以直接输入，例如：'{"key1": "value1", "key2": "value2"}' 或 '[ele1, ele2, ele3, ele4]'
			* JSON类型的列值也可以通过函数生成(见'内置函数 > JSON函数')；
			* JSON类型的值访问:
				* $ 	->  表示整个JSON值； 
				* .key 	->  获取JSON值中某个键对应的值；
				* .* 	->  获取JSON值中某个键对应的全部值；
				* [i] 	->  获取JSON值中某个索引位置的值；
				* [*]	->  获取JSON值中某个索引位置的全部值；

内置函数
=============================================
	* 调用函数时，应该避免函数名和()之间有空格，这有助于MySQL解析器区分'函数调用'和'表或列的引用'，但允许()中的参数之间有空格；
	数字函数
	----------------------
		abs(...)
			--> 即返回...的绝对值；

		conv(原值, 源进制, 目的进制)
			--> 即将原进制下的'原值'转换成目的进制下的值；

		crc32('字符串'表达式)
			--> 即将'字符串'(可以是中文)转换成循环冗余的'10位数字'(本质上，是32位的无符号整数)；
			--> null将转换成null；
		
		cell(...)
			--> 即返回大于或等于...的最小整数(可以是负整数)；
		
		floor(...)
			--> 即返回小于或等于...的最大整数(可以是负整数)； 
		
		format(数字, D)
			--> 即将'数字'转换成'千位分隔'且'具有D位小数'的字符串；

		mod(M, N)
			--> 即返回'M % N'的结果；
		
		pow(x, y)
			--> 即返回'x ** y'的结果；

		rand()
			--> 即返回'0 <= R < 1.0'之间的浮点数；

		round(X[, D])
			--> 即X为精确值，则返回严格的四舍五入值(即最近的整数)；
				若X为近似值，则返回非严格的四舍五入值(即最近的偶数)； 
				总而言之，X是什么类型，结果值就是什么类型；
			--> D ,默认为0，表示四舍五入的小数位数；

		sqrt(X)
			--> 即返回'非负数'X的平方根(若X为负数，则返回null)；

		PI()
			--> 即返回数字3.141593；

		truncate(X, D)
			--> 即返回X取D位小数后的值(若D为负数，则小数点象征性左移，所经之处皆为0且截去小数部分)，例如：
				truncate(1.222, 1) ->  1.2
				truncate(-1.22, 1) ->  -1.2
				truncate(1.222, 0) ->  1
				truncate(1222, -3) ->  1000
				truncate(12.2, -1) ->  10

	日期/时间函数
	----------------------
		adddate('日期或日期/时间', interval 数量 单位)
			--> 即返回'日期'或'日期/时间'加上'数量 单位'后的结果；

		subdate('日期或日期/时间', interval 数量 单位)
			--> 即返回'日期'或'日期/时间'减去'数量 单位'后的结果；

		addtime('时间或日期/时间'表达式, '时间'表达式)
			--> 即返回'时间'或'日期/时间'加上'时间'后的结果；
		
		subtime('时间或日期/时间'表达式, '时间'表达式)
			--> 即返回'时间'或'日期/时间'减去'时间'后的结果；
		
		------------------
		convert_tz('日期/时间', '源时区', '目的时区')
			--> 即将'源时区'下的'日期/时间'转换至'目的时区'下的值并返回；
			--> 时区 ,即'+xx:xx'或者'时区缩写'；
		
		------------------
		current_date()
			--> 即返回当前的日期，返回值会根据上下文自动转换成'字符串格式'或'数字格式'，形如：'2003-08-14'或20030814； 

		current_time([fsp])
			--> 即返回当前的时间，返回值会根据上下文自动转换成'字符串格式'或'数字格式'，形如：'18:07:53'或180753.000000； 

		now([fsp]) / current_timestamp([fsp])
			--> 即返回当前的时间戳，返回值会根据上下文自动转换成'字符串格式'或'数字格式'，形如：'2003-08-14 18:08:04'或20030814180804.000000； 
		
		utc_date()
			--> 即返回UTC制的当前日期，返回值会根据上下文自动转换成'字符串格式'或'数字格式'，形如：'2003-08-14'或20030814；

		utc_time([fsp])
			--> 即返回UTC制的当前时间，返回值会根据上下文自动转换成'字符串格式'或'数字格式'，形如：'18:07:53'或180753.000000；

		utc_timestamp([fsp])
			--> 即返回UTC制的当前时间戳，返回值会根据上下文自动转换成'字符串格式'或'数字格式'，形如：'2003-08-14 18:08:04'或20030814180804.000000；

		------------------
		week('日期'表达式, mode)
			--> 即返回'日期'表达式属于第几周；
			--> mode ,mode=0，表示每周第一天为Sunday，返回值范围为0~53；
					  mode=1，表示每周第一天为Monday，返回值范围为0~53；

		------------------
		date('日期/时间'表达式)
			--> 即返回'日期/时间'表达式中的日期部分；
		
		time('日期/时间'表达式)
			--> 即返回'日期/时间'表达式中的时间部分；
		
		year('日期'表达式)
			--> 即返回'日期'表达式中的年份部分；

		month('日期'表达式)
			--> 即返回'日期'表达式中的月份部分；

		hour('时间'表达式)
			--> 即返回'时间'表达式中的小时部分；
		
		minute('时间'表达式)
			--> 即返回'时间'表达式中的分钟部分；

		second('时间'表达式)
			--> 即返回'时间'表达式中的秒数部分；

		microsecond('日期/时间'表达式)
			--> 即返回'日期/时间'表达式中的微秒部分；

		------------------
		to_days('日期'表达式)
			--> 即返回从0000-00-00开始至'日期'表达式为止的总天数，例如：'2007-10-07'返回'数字733321'；
			--> '日期'表达式 ,若输入'0000-00-00'或其他无效值，则返回null；

		to_seconds('日期'表达式)
			--> 即返回从0000-00-00开始至'日期'表达式为止的总秒数，例如：'2009-11-29 13:43:32'返回数字'63426721412'；

		time_to_sec('时间'表达式)
			--> 即返回'时间'表达式对应的总秒数，例如：'00:39:38'返回'数字2378'；

		unix_timestamp(['日期'表达式])
			--> 即返回从1970-01-01 00:00:00开始至当前或'日期'表达式为止的总秒数(可以有小数点'，例如：'2015-11-13 10:20:19.012'返回'数字1447431619.012'；
	
		------------------
		last_day('日期'表达式)
			--> 即返回'日期/时间'表达式对应的月份的最后一天的日期，例如：'2003-02-05'返回'2003-02-28'；

		------------------
		quarter('日期'表达式)
			--> 即返回'日期'表达式属于第几季度，例如：'2008-04-01'返回'数字2'；

		monthname('日期'表达式)
			--> 即返回'日期/时间'对应的'全拼月'，例如：'2007-02-03'对应'February';

		dayname('日期'表达式)
			--> 即返回'日期/时间'对应的'全拼日'，例如：'2007-02-03'对应'Saturday';

		dayofweek('日期'表达式)
			--> 即返回'日期'表达式对应的'周计日'(1~7表示Sunday~Saturday)，例如：'2007-02-03'对应'数字7'；
			
			weekday('日期'表达式)
			--> 即返回'日期'表达式属于'周计日'(0~6表示Monday~Sunday)，例如：'2007-11-05 00:32:23'返回'数字0'；

		dayofmonth('日期'表达式)
			--> 即返回'日期'表达式对应的'月计日'，例如：'2007-02-03'对应'数字3'；
		
		dayofyear('日期'表达式)
			--> 即返回'日期'表达式对应的'年计日'，例如：'2007-02-03'对应'数字34'；

		------------------
		datediff('日期/时间'表达式1, '日期/时间'表达式2)
			--> 即返回('日期/时间'表达式1 - '日期/时间'表达式2)的结果，
				计算时仅考虑表达式的'日期'部分，结果精度按'天'算(可以为负数)；
		
		timediff('日期/时间'表达式1, '日期/时间'表达式2)
			--> 即返回('日期/时间'表达式1 - '日期/时间'表达式2)的结果，
				结果精度按'hh:mm:ss.ssssss'算(可以为负数)；

		------------------	
		date_format('日期/时间'表达式, 格式化字符串)
			--> 即将'日期/时间'表达式按'格式化字符串'的要求返回； 
			--> 格式化字符串 ,%Y	四位年 - 1998
							%y    两位年 - 98

							%m	  两位月 - 01~12
							%c    不定月 - 1~12
							%M    全拼月 - January~December
							%b    缩写月 - Jan~Dec

							%d    两位日 - 00~31
							%e    不定日 - 0~31
							%W    全拼日 - Sunday~Saturday
							%a    缩写日 - Sun~Sat
							%j    年计日 - 001~366
							
							%T    24制时分秒 - hh:mm:ss
							%r    12制时分秒 - hh:mm:ss AM/PM

							%H    两位24制时 - 00~23
							%h    两位12制时 - 01~12
							%k    不定24制时 - 0~23
							%l    不定12制时 - 1~12

							%i    两位分 - 00~59

							%s    两位秒 - 00~59
							%f    六位微妙 - 000000~999999

							%p    AM或PM
	
	字符串函数
	----------------------
		bit_length(str)
			--> 返回字符串str的总位数；

		length(str)
			--> 返回字符串str的总字节数；

		char_length(str)
			--> 返回字符串str的总字符数；

		left(str, len)
			--> 选中str最左侧n个字符并返回；若str或len为null，则返回null；

		right(str, len)
			--> 选中str最右侧n个字符并返回；若str或len为null，则返回null；

		replace(str, from_str, to_str)
			--> 将str中的from_str部分全部用to_str替换掉(匹配时大小写敏感)；

		repeat(str, count)
			--> 将str重复count次并返回；若str或count为null，则返回null；若count<1，则返回空字符串；

		reverse(str)
			--> 将str倒置后返回；

		lower(str) / upper(str)
			--> 将str全部转换成小写并返回 / 将str全部转换成大写并返回

		ltrim(str) / rtrim(str)
			--> 删除str左侧的全部空格后返回 / 删除str右侧的全部空格后返回

		locate(substr, str, pos)
			--> 判断从父串str的第pos个字符(含)开始，子串substr中的第一个字符是父串str中的第几个字符(从1开始计算)；
				若substr不是str的子串，则返回0；

		field(str, str1, str2, ...)
			--> 返回str1, str2, ...中str所在的位置(从1开始计算)；若str为null，则返回0；若str并不在其中，则返回0；

		bin(n)
			--> 将整形n转换成二进制字符串并返回；若n为null，则返回null；

		oct(n)
			--> 将整形n转换成八进制字符串并返回；若n为null，则返回null；

		hex(n)
			--> 将整形n转换成十六进制字符串并返回；若n为null，则返回null；
		
		unhex('字符串')
			--> 将'字符串'中的'每对字符'视作十六进制数字并转换成'1个字节'后返回，因此函数的返回值为二进制字符串；
				可以用于某些表的binary([N])类型的列，以便更有效地储存'加密函数的结果'；

		concat(val1, val2, ...)
			--> 将一个或多个值拼接成完整的字符串并返回；若任意一个参数值为null，则返回null:
				把不同类型的值在拼接时转换优先级：数字 < 字符串 < 二进制字符串

		concat_ws(sep, val1, val2, ...)
			--> 将一个或多个值用sep分隔符拼接成完整的字符串并返回；若sep分隔符为null，则返回null；
				若参数值中出现null，在拼接时它们会被忽略，但出现空字符串却不会；

	聚合函数
	----------------------
		* 除非特别声明，否则聚合函数都不会包括null值；
		* 如果没有group by子句，则聚合函数会对全部数据行聚合；
		bit_and(列名)
			--> 即返回列中所有值'按位与'后的结果；
		
		bit_or(列名)
			--> 即返回列中所有值'按位或'后的结果；
			
		bit_xor(列名)	
			--> 即返回列中所有值'按位异或'后的结果；
		
		count(列名)
			--> 即则返回列中所有'非null值'的个数；
				如果'列名'为*，则返回结果集的总行数；
		
		max([distinct] 列名)
			--> 即返回列中所有值中的最大值；
			--> distinct ,即加上该关键字，则返回列中所有非重复值中的最大值；
		
		min([distinct] 列名)
			--> 即返回列中所有值中的最小值；
			--> distinct ,即加上该关键字，则返回列中所有非重复值中的最小值；

		sum([distinct] 列名)
			--> 即返回列中所有值的总和；
			--> distinct ,即加上该关键字，则返回列中所有非重复值的总和；

		avg([distinct] 列名)
			--> 即返回列中所有值的平均值；
			--> distinct ,即加上该关键字，则返回列中所有非重复值的平均值；
		
		std(列名)
			--> 即返回列中所有值的标准差；
		
		variance(列名)
			--> 即返回列中所有值的方差(标准差的平方)；

		group_concat([distinct] 列名1, 列名2, ... order by 列名1 asc/desc, 列名2 asc/desc separator '分隔符')
			--> 即搭配group by子句使用，(分组后)将指定的一个或多个'非null'的列值拼接成完整字符串，(每组中的)每个完整字符串之间都用'分隔符'(默认为',')隔开；
			--> distinct ,即加上该关键字，则拼接的是一个或多个'非null且不重复'的列值；
			--> order by ,即加上该关键字，则将(每组中)用'分隔符'隔开的'完整字符串'进行排序(这种排序并非是升序/降序，而是正序/倒序)；

		any_value(列名)
			--> 即抑制'列名'的可确定值检测(本质上，该函数不属于聚合函数)；
				在'ONLY_FULL_GROUP_BY'模式下，聚合类查询要求结果集中显示的列必须是'可确定值的'；
				换句话说，显示的列名要么在group by子句中出现过，要么是not null约束下的唯一索引(含主键索引)，要么作为某个函数的参数出现在结果集中，
				要么使用any_value(列名)抑制自己的可确定值检测；

		default(列名)
			--> 即返回'列名'的默认值(本质上，该函数不属于聚合函数)；
				若'列名'没有默认值，则返回错误；

		JSON列名 -> '路径'
			--> 即返回'列名'指定部分的数据，'->'操作符等效于json_extract(...)函数(本质上，该函数不属于聚合函数)； 
				该'列名'必须是JSON类型，'路径'涵盖$或[i]或.key或[*]等格式；
		
		JSON列名 ->> '路径'
			--> 即类似于<JSON列名 -> '路径'>，只不过在其基础上额外将返回的数据去掉引号；

	加密函数
	----------------------
		aes_encrypt('明文字符串', '密钥字符串'[, 初始矢量])
			--> 即使用'密钥字符串'加密'明文字符串'并返回二进制字符串形式的密文；
			--> '明文字符串'和'密钥字符串'的长度不限，该函数会自动补齐至AES算法要求的block_size的倍数；
			--> 初始矢量 ,即至少16个字节，具体是否需要'初始矢量'将由AES算法的加密模式决定，该模式又由系统变量'block_encryption_mode'决定(默认为'aes-128-ecb')；

		aes_decrypt('密文字符串', '密钥字符串'[, 初始矢量])
			--> 即使用'密钥字符串'解密'密文字符串'并返回字符串形式的明文；

		random_bytes(n)
			---> 即返回n个字节的随机二进制字符串(n的范围为1~1024)；

		md5('字符串')
			--> 即返回'字符串'经MD5算法后的校验和，返回值为32个十六进制字符的'字符串'；
		
		create_digest('摘要算法', '字符串')
			--> 即返回'字符串'经'摘要算法'后的结果，返回值为二进制字符串；
			--> 摘要算法 ,可以取值为'SHA224'、'SHA256'、'SHA384'、'SHA512'；
		
		sha1('字符串')
			-->  即返回'字符串'经SHA-1算法后的结果，返回值为40个十六进制字符的'字符串'；

		sha2('字符串', n)
			--> 返回'字符串'经SHA-n算法后的结果，返回值为对应个十六进制字符的'字符串'；
			--> n ,可以取值为224、256、384和512；

	JSON函数
	----------------------
		json_array([val1[, val2, ...]])
			--> 即返回一个存有[val1, val2, ...]等值的JSON数组；
		
		json_object([key1, val1[, key2, val2, ...]])
			--> 即返回一个存有{key1:val1, key2:val2, ...}等值的JSON对象；

		json_array_append(JSON对象, '路径1', val1[, '路径2', val2, ...])
			--> 即根据'路径'在'JSON对象'的指定位置添加数据后，返回新的JSON对象(若任何参数为null，函数都将返回null)； 
				例如：json_array_append('["a", ["b", "c"], "d"]', '$[0]', 2) 
				返回：[["a", 1], ["b", "c"], "d"]
				又如：json_array_append('["a", ["b", "c"], "d"]', '$[1][1]', 2)
				返回：["a", ["b", ["c", 2]], "d"]

		json_set(JSON对象, '路径1', 值1[, '路径2', 值2, ...])
			--> 即根据'路径'在'JSON对象'的指定位置添加/修改值后，返回新的JSON对象；
				指定位置'已存在'数据，则'修改'；指定位置'不存在'数据，则'新增'； 
		
		json_insert(JSON对象, '路径1', 值1[, '路径2', 值2, ...])
			--> 即根据'路径'在'JSON对象'的指定位置添加值后，返回新的JSON对象；
				指定位置'已存在'数据，则'无效'；指定位置'不存在'数据，则'新增'； 
		
		json_replace(JSON对象, '路径1', 值1[, '路径2', 值2, ...])
			--> 即根据'路径'在'JSON对象'的指定位置修改值后，返回新的JSON对象；
				指定位置'已存在'数据，则'修改'；指定位置'不存在'数据，则'无效'； 
		
		json_remove(JSON对象, '路径1'[, '路径2', ...])
			--> 即根据'路径'删除'JSON对象'指定位置的数据后，返回新的JSON对象；

		json_merge_patch(JSON对象1, JSON对象2[, ...])
			--> 即将两个或多个JSON对象依次合并后，返回新的JSON对象；
				两个JSON对象合并的规则：
					1) 如果前一个JSON对象'不是对象'，则合并结果永远取'后一个JSON对象'；
					2) 如果后一个JSON对象'不是对象'，则合并结果也永远取'后一个JSON对象'；
					3) 如果两个JSON对象都是'对象'，则合并结果取合并后的JSON对象，合并时遵循：
						* 键相同，键值不是对象，则取顺序靠后的，若靠后的为null，则删除该键值对；
						* 键相同，键值都是对象，则合并这些对象作为新的键值；
		
		json_merge_preserve(JSON对象1, JSON对象2[, ...])
			--> 即类似于<json_merge_patch(...)>，只不过对于第3)点：键相同，json_merge_preserve(...)会以数组形式储存所有相同键的键值，并作为新的键值；

		json_extract(JSON对象, '路径')
			--> 即根据'路径'将'JSON对象'中对应部分的数据返回，例如：json_extract('[10,20,30]', '$[1]') 返回'数字20'；

		json_keys(JSON对象, '路径')
			--> 即根据'路径'将'JSON对象'中对应部分的'数据的键值'以'数组形式返回'，例如：json_keys('{"a": 1, "b": {"c": 30}}', '$.b') 返回'["c"]'；

		json_search(JSON对象, 'one'/'all', '值'[,...])
			--> 即在'JSON对象'中搜索'值'对应的'路径'，例如：json_search('{"a": "1", "b": {"c": "30"}}', 'one', '1') 返回'"$.a"'；
			--> 'one'/'all' ,在'one'模式下找到第一个匹配的(无序)后就终止函数，在'all'模式下找到所有匹配的后以'数组形式'(元素无序)返回；
			--> '值' ,必须是字符串类型(若JSON对象中是1而不是"1"，则搜索"1"是搜不出来的，会返回null)；
					  同时'值'可以使用'%'(0或多个)或'_'(1个)来模糊搜索；
			--> [,...] ,是转义等不常用的设置；
		
		json_quote('字符串')
			--> 即返回一个""双引号包裹的标准的JSON值(自动转义)，等效于cast('字符串' as JSON)，
				例如：json_quote('null') 	 -> "null"
					 json_quote('"null"')	-> "\"null\""
					 json_quote('[1,2,3]')	-> "[1,2,3]"

		json_length(JSON对象[, '路径'])
			--> 即返回'JSON对象'或指定位置的数据的长度：
					标量数据的长度为1，
					数组的长度为其中元素的个数(只计算最外层的个数，不考虑嵌套关系)，
					对象的长度为其中键值对的个数(只计算最外层的个数，不考虑嵌套关系)；

	全文搜索函数
	----------------------
		match(列名1, 列名2, ...) against(‘搜索词表达式’ 搜索模式)
			--> 即借助'列名1, 列名2, ...'组成的全文索引，在指定的'搜索模式'下对'搜索词'进行全文搜索；
				* 全文索引仅适用于InnoDB或MyISAM引擎表中的char或varchar或text类型的列，
				  不适用于分区表(因为分区表本质上是一种由底层物理子表组成的逻辑表。它不存在全文索引，有的只是每个物理子表上的索引)；
				* 若数据是中文、日文和韩文，则MySQL需要依靠内置的'连词解析器'(即ngram full-text parser)进行全文搜索；
					1.不同于默认的以'空格'等作为定界符，连词解释器基于字符(最小为1，最大为10)分隔，导致在搜索词匹配时按照ngram_token_size的值隐式分隔；
					  例如1：对于字符串'abc def'，若设置ngram_token_size=2，则它可能被解释成4种token('ab','bc','de'和'ef')，
					  		因此会被'abc def'或'ab bc de ef'这样的搜索词命中，但不会被'abcdef'这样的搜索词命中；
					  例如2：对于万能操作符*，若搜索词(含操作符*)长度小于ngram_token_size，则如ngram_token_size=2，搜索词'女*'会命中所有以'女'开头的数据行；
					2.变量ngram_token_size是只读变量，只能在配置文件中或启动服务器时设置它；
					3.启用连词解析器需要在定义或修改全文索引时显示声明它，例如：
						create table 表名(
						... 
						fulltext key (col1, col2, ...) with parser ngram),
						...) ...
					  或者
						alter table 表名
						add fulltext key (col1, col2, ...) with parse ngram
				* 全局变量innodb_ft_server_stopword_table决定了全文搜索时采用哪张表中的停止词；
				* 全文搜索的注意事项：
					1.适用于全文搜索的搜索词的最小或最大长度；
					2.布尔全文搜索模式下的操作符使用；
					3.被搜索数据的字符集；
					4.全文索引的优化、甚至重构；
			--> 列名1, 列名2, ... 声明，必须与全文索引定义时的列名一致；
			--> '搜索词表达式'	   声明，与搜索模式密切相关；
			--> 搜索模式 		  声明，包括：
						in natural language mode	
							->  该模式(默认模式)下，将'搜索词'视作'短语'(用“”双引号包裹)；
									搜索注重词序和词是否一致(一个词可以由数字、字母、下划线和单个单引号组成)，不注重穿插其间的标点符号等；
									对于单个词的界定，由空格、逗号和点号等定界符决定(对于中文等难以界定的语言，需要依靠'连词解析器')；
									搜索会忽略小于innodb_fi_min_token_size(InnoDB引擎)或
										小于ft_min_word_len(MyISAM引擎)或
										小于ngram_token_size(依靠连词解析器的语言)的'搜索词'，
										以及所有的停止词；
								该模式下，对于每行数据，match()...函数都会返回一个表示'相关性'的浮点值(根据词频计算)；
								该模式下，全文搜索是'大小写不敏感的'，使用'xxx_bin'的排序规则会让其'大小写敏感'； 
								该模式下，如果match()...函数'被用于where子句'，则结果集自动按'相关性'从高到低进行排序；
						
						in boolean mode 			
							->  该模式下，将'搜索词'加上特殊的'操作符'从而适用于特殊的搜索规则；
									操作符
										+搜索词		->  该'搜索词'一定有
										-搜索词		->  该'搜索词'一定没有
										搜索词		->  该'搜索词'可有可没有
										>搜索词		->  该'搜索词'的相关权重更高
										<搜索词		->  该'搜索词'的相关权重更低
										~搜索词		->  该'搜索词'是噪声词，其相关性比没有更低
										搜索*		->  该'搜索词'部分可以是任意的
										"搜索词"	->  该'搜索词'恰好是这个(但允许标点符号穿插其间)
									注意事项
										不支持多个操作符，例如：'++搜索词'或'+-搜索词'；
										不支持后置操作符，例如：'搜索词+'；
										不支持纯万能操作符，例如：'+*'；
							->  该模式下，搜索会忽略小于innodb_fi_min_token_size(InnoDB引擎)或
									小于ft_min_word_len(MyISAM引擎)或
									小于ngram_token_size(依靠连词解析器的语言)的'搜索词'，
									以及所有的停止词；
							->  该模式下，结果集不会自动按'相关性'从高到低进行排序；
							->  该模式下，InnoDB引擎表下的布尔全文搜索依托Sphinx全文搜索引擎，使用BM25和TF-IDF(即'term frequency-inverse document frequency'权重系统)排名算法；
									简单来说，一个单词在某个文档中出现的越多，在文档集合中出现的越少，则它的相关性就越高；
									单个搜索词的单行相关性算法：
										单词单行TF值 = 单行中单个搜索词出现的次数
										IDF值 = log10(数据的总行数 / 存在搜索词的总行数)
										单词单行相关性 = 单行TF值 * IDF值 * IDF值
									多个搜索词的单行相关性算法：
										多词单行相关性 = 单词1单行相关性 + 单词2的单行相关性 + ...
						with query expansion	
						in natural language mode with query expansion	
							->  该模式与默认模式类似，只不过会额外将相关性最高的行作为新的搜索词进行二次搜索；
								有点自动关联搜索和模糊搜索的意思，但建议仅在'搜索词较短'的情况下使用该模式；
						
						
	系统函数
	----------------------
		current_user()
			--> 即返回服务器端验证当前客户端连接所使用的'账户名'(可以与user()的值不同)；

		user()
			--> 即返回当前客户端连接真实的'账户名'；
		
		connection_id()
			--> 即返回服务器端为当前客户端连接所分配的线程ID；
		
		database()
			--> 即返回默认的数据库名；

		charset(字符串)
			--> 即返回'字符串'对应的字符集名；
		
		collation(字符串)
			--> 即返回'字符串'对应的排序规则名；

		found_rows()
			--> 即返回'最近一次'select语句返回的总行数(忽略limit子句的过滤)；

	其他函数
	----------------------
		convert(表达式, type) / cast(表达式 as type)
			--> 即将表达式的结果转换成指定的类型；
			--> type ,即包括：
					json
					binary[(N)]、char[(N)] [character set 字符集名]
					date、time、datetime
					signed[integer]、unsigned[integer]、decimal[(M,D)]
		
		benchmark(times, expr)
			--> 即测试'expr'执行times次所需的时间,返回值永远为0；
				该函数仅记录'expr'执行的时间,不包括MySQL内部解析、优化所需的时间；

		inet_aton('xxx.xxx.xxx.xxx')
			--> 即将字符串类型的'点分四组IPv4地址'转换成数字类型(即32位的无符号整数)；
		
		inet_ntoa(数字)
			--> 即将数字类型(即32位的无符号整数)的IPv4地址转换成字符串类型的点分四组IPv4地址；

		is_ipv4('xxx.xxx.xxx.xxx')
			--> 即若参数是有效的IPv4地址，则返回1，否则返回0；
		
		uuid()
			--> 即返回一个版本1的UUID值(即36个十六进制字符的字符串，含'-')；


操作符
=============================================
	比较操作符
	----------------------
		* 对数字和字符串均有效，它们在比较时会自动转换；
		* 返回结果为1、0或null；

		=
			--> 即判断操作符左右两边是否相等(也适用于行比较)；
			--> 1 = 0 			  ->  返回0
				'0' = 0           ->  返回1(会自动转换类型再做比较)
				1 = null          ->  返回null
				null = null       ->  返回null
				(a ,b) = (x, y)   ->  行比较，等价于(a = x) and (b = y)
		<=>
			--> null-safe比较，即判断操作符左右两边是否相等(也适用于行比较)；
				若左右两边均为null，则返回1；若只有其中一边为null，则返回0；
			--> 1 <=> 1 		  ->  返回1
				1 <=> null        ->  返回0
				null <=> null     ->  返回1
				(a ,b) <=> (x, y) ->  行比较，等价于(a <=> x) and (b <=> y)

		<> 或 !=
			--> 即判断操作符左右两边是否不相等(也适用于行比较)；
			--> 'zapp' <> 'zappp' ->  返回1
				'0' <> 0          ->  返回0
				(a ,b) <> (x, y)  ->  行比较，等价于(a <> x) or (b <> y)

		<
			--> 即判断操作符的左边是否小于右边(也适用于行比较)；
			--> 2 < 2             ->  返回0
				(a, b) < (x, y)   ->  行比较，等价于(a < x) or ((a = x) and (b < y))

		<=
			--> 即判断操作符的左边是否小于或等于右边(也适用于行比较)；
			--> 0.1 <= 2          ->  返回1
				(a, b) <= (x, y)  ->  行比较，等价于(a < x) or ((a = x) and (b <= y))

		>
			--> 即判断操作符的左边是否大于右边(也适用于行比较)；
			--> 2 > 2             ->  返回0
				(a, b) > (x, y)   ->  行比较，等价于(a > x) or ((a = x) and (b > y))

		>=
			--> 即判断操作符的左边是否大于或等于右边(也适用于行比较)；
			--> 0.1 >= 2          ->  返回0
				(a, b) >= (x, y)  ->  行比较，等价于(a > x) or ((a = x) and (b >= y))

		is true/false/unknown
			--> 即判断操作符左边是否是某个布尔值；
			--> 1 is true         ->  返回1
				0 is false        ->  返回1
				null is unknown   ->  返回1

		is not true/false/unknown
			--> 即判断操作符左边是否是某个布尔值；

		is null
			--> 即判断操作符左边是否是null；
			--> 1 is null         ->  返回0
				0 is null 		  ->  返回0
				null is null 	  ->  返回1
			
		is not null
			--> 即判断操作符左边是否不是null；

		表达式 between .. and ...
			--> 即判断操作符左边的表达式是否在..和...之间(含临界值)；
			--> 1 between 0 and 3       ->  返回1
				'b' between 'c' and 'd' ->  返回0

		表达式 not between .. and ...
			--> 即判断操作符左边的表达式是否不在..和...之间(含临界值)；

		表达式 in (val1, ...)
			--> 即判断操作符左边的表达式是否位于右边的'集合'(不应该同时存在字符串值和非字符串值)中；
				若表达式不位于右边'集合'中且'集合'中至少有一个null，则返回null；
			--> 1 in (null, 0, 2)            ->  返回null
				1 in (null, 1, 2)            ->  返回1
				'wd' in ('wee', 'wd', 'wde') ->  返回1

		表达式 not in (val1, ...)
			--> 即判断操作符左边的表达式是否不位于右边的'集合'(不应该同时存在字符串值和非字符串值)中；
				若表达式不位于右边'集合'中且'集合'中至少有一个null，则返回null；
			--> 1 not in (null, 0, 2)        ->  返回null
				1 not in (null, 1, 2)        ->  返回0

		interval(基值, 比较值1, ...)
			--> 即判断括号中小于或等于基值的有多少个；若基值为null，则返回-1；
				比较值1, 比较值2, ... ->  必须按照升序排列才会正常工作；
			--> interval(23, 25, 33, 45, 56)  ->  返回0
				interval(10, 2, 4, 6, 10)     ->  返回4
				interval(null, 1, 4, 6, 7)    ->  返回-1

	逻辑操作符
	----------------------
		and 或 &&
			--> 逻辑与

		or 或 ||
			--> 逻辑或

		xor
			--> 逻辑异或

		! 或 not
			--> 逻辑非
			--> !(1 + 1)   	->  返回0
				！1 + 1 	->  返回1

	赋值操作符
	----------------------
		=
			--> 赋值操作或判断是否相等

		:=
			--> 一定是赋值操作

	流程控制操作符
	----------------------
		case 基值 
		when [比较值1] 
			then 结果1
		[when[比较值2] 
			then 结果2 ...] 
		[else 结果] 
		end
			--> 即返回第一个与基值相等的比较值所对应的结果值；
				若所有比较值都不等于基值，则返回else对应的结果值；若未声明else，则返回null；
			--> case 10 when 11 then 'no1' when 32 then 'no2' when '10' then 'yes'
				->  返回'yes'

		case 
		when [条件1] 
			then 结果1 
		[when [条件2] 
			then 结果2 ...] 
		[else 结果] 
		end
			--> 即返回第一个为true的条件所对应的结果值；
				若所有条件都不为true，则返回else对应的结果值；若未声明else，则返回null；

		if(条件表达式, 表达式2, 表达式3)
			--> 即当'条件表达式'为true(即不为0，不为null)时，返回表达式2，否则返回表达式3；

		ifnull(表达式1, 表达式2)
			--> 即表达式1非null，则返回表达式1；否则，返回表达式2；

		nullif(表达式1, 表达式2)
			--> 即若表达式1=表达式2，则返回null；否则，返回表达式1；

		coalesce(val1, ...)
			--> 即返回括号中的第一个非null值；若均为null，则返回null；
			--> coalesce(null, 1)		->  返回1
				coalesce(null, null) 	->  返回null
		
		isnull(表达式)
			--> 即判断表达式是否为null；
			--> isnull(1 + 1)        	->  返回0
				isnull(1 / 0) 			->  返回1

		greatest(val1, val2, ...)
			--> 即返回括号中(至少2个值)的最大值；若任意一个值为null，则无需比较直接返回null；
				不同类型的值比较时转换优先级：二进制字符串 < 字符串 < int < Decimal < double
			--> greatest(2, 1.2, 34)	->  返回34.0

		least(val1, val2, ...)
			--> 即返回括号中(至少2个值)的最小值；若任意一个值为null，则无需比较直接返回null；
				不同类型的值比较时转换优先级：二进制字符串 < 字符串 < int < Decimal < double
			--> least(2, 1.2, 34) 		->  返回1.2

	运算操作符
	----------------------
		+
			--> 即将操作符左右两边相加后返回；

	其他操作符
	----------------------
		binary
			--> 将表达式强制转换成二进制字符串

		&
			--> 按位与

		|
			--> 按位或

		^
			--> 按位异或

		<<
			--> 左移

		>>
			--> 右移

		~
			--> 取反
				
DDL和DML语法
=============================================
	基本概念
	----------------------
	* DDL(Data Definition Language)，即关于'数据定义'的语言
	* DML(Data Manipulation Language)，即关于'数据操作'的语言

	账户管理相关的操作
	----------------------
		* 除了root账户，不要授予任何其他账户进入系统级数据库mysql中user表的权限；
		* 不要向账户授予多余的权限，也不要向任意主机授予权限；
		* 账户管理相关的操作需要super权限，以及对应的操作权限；

		create user [if not exists] 账户名1 [验证选项1] [, 账户名2 [验证选项2], ...]
		[require none / 连接要求1 / 连接要求2 ...]]
		[with 资源限制1 [资源限制2 ...]]
		[密码选项 / 锁选项]
			--> 创建账户名，新创建的账户名没有任何权限，需要通过grant语句来赋予；
				该操作必须拥有create user权限(若启用系统变量read_only，则必须拥有super权限)；
			--> if not exists		声明，若声明了，则创建已存在的账户名会产生警告信息而不是直接报错；
				账户名				 声明，即'用户名'@'主机名'，'主机名'默认为'%'；
				验证选项			 声明，指定服务器根据什么验证账户名，包括：
									identified by '验证字符串'					->  '验证字符串'即密码
									identified by password '哈希字符串'
									identified with 验证插件					->  验证插件，由系统变量default_authentication_plugin决定；
									identified with 验证插件 by '验证字符串'         验证插件，位于'mysql'数据库'user'表的'plugin'列，通常是对密码的进一步加工；
									identified with 验证插件 as '哈希字符串'         验证插件，分为'caching_sha2_password'和'mysql_native_password'；
				none / 连接要求...   声明，指定SSL/TLS验证的内容，适用于之前指定的所有账户名，包括：
									  none										->  告诉服务器对当前账户名无需SSL或x509证书验证，无加密连接(默认)
									  ssl 										->  告诉服务器对当前账户名仅接受它的加密连接
									  x509 										->  告诉服务器对当前账户名需要它提供证书(证书的真实性无所谓)，
									  											   这意味客户端连接时必须指定--ssl-key和--ssl-cert配置项；
									  cipher '密文' 							 ->  告诉服务器对当前账户名需要它提供加密连接的'密文'(或密文块)
									  issuer 'issuer'							->  告诉服务器对当前账户名需要它提供CA商’issuer'颁发的证书
									  subject 'subject'	 						->  告诉服务器对当前账户名需要它提供包含'subject'的证书
				资源限制               声明，指定账户名的资源限制，包括：
									  max_queries_per_hour 次数     			 ->  告诉服务器对当前账户名限制每小时的最大查询次数，默认为0(即无限制)
									  max_updates_per_hour 次数					 ->  告诉服务器对当前账户名限制每小时的最大更新次数，默认为0(即无限制)
									  max_connections_per_hour 次数  			 ->  告诉服务器对当前账户名限制每小时的最大连接次数，默认为0(即无限制)
									  max_user_connections 个数 				 ->  告诉服务器对当前账户名限制其同一账户名同时连接的最大个数，默认为0(即无限制)
				密码选项 / 锁选项 		声明，指定账户名的密码超时时间，包括：
				 					  password expire default				 	->  告诉服务器当前账户名的密码遵循系统变量default_password_lifetime的设定(默认)
									  password expire 							->  告诉服务器当前账户名(新创建)的密码立即失效
									  password expire never 					->  告诉服务器当前账户名的密码永不超时
									  password expire interval 天数 day  		 ->  告诉服务器当前账户名的密码每隔'天数'天失效一次(即需要重新设定)；
									  account unlock							->  告诉服务器当前账户名处于未锁定状态(默认)
									  account lock   							->  告诉服务器当前账户名处于锁定状态


		alter user [if exists] 账户名1 [验证选项1] [, 账户名2 [验证选项2], ...]
		[require none / 连接要求1 / 连接要求2 ...]
		[with 资源限制1 [资源限制2 ...]]
		[密码选项 / 锁选项]
			--> 更新账户名；该操作必须拥有create user权限(若启用系统变量read_only，则必须拥有super权限)；
		

		rename user 旧账户名1 to 新账户名1 [, 旧账户名2 to 新账户名2, ...]
			--> 重命名一个或多个账户名(旧账户名必须已存在)；


		drop user [if exists] 账户名1 [, 账户名2, ...]
			--> 删除账户名；该操作必须拥有create user权限(若启用系统变量read_only，则必须拥有super权限)；


		grant 权限名称1 [(列名a1, 列名b1, ...)] [, 权限名称2 [(列名a2, 列名b2, ...)] , ...]
		on [table / function / procedure] 权限级别
		to 账户名1 [验证选项1] [, 账户名2 [验证选项2] , ...]
		[require none / 连接要求1 [[and] 连接要求2, ...]]
		[with grant option / 资源限制]
			--> 为账户名授权；该操作必须拥有grant option权限(若启用系统变量read_only，则必须拥有super权限)；
			--> 权限名称[列名, ...]   声明，当授予列级别权限时需要指定对应的列名；
				[table / ...] 		声明，表示对表、存储函数或存储过程授权时，需要显示声明对应的关键字；
				权限级别		 	 声明，*.*  		        ->  表示授予操作'所有服务器数据库'的权限(即数据库级权限)；
										 * / 数据库名.*       ->  表示授予操作'默认数据库'或'指定数据库'的权限(即数据库级权限)；
										 表名 / 数据库名.表名   ->  表示授予操作'默认数据库中指定表'或'指定数据库中指定表'的权限(即表级权限)；
										 数据库名.存储程序名    ->  表示授予操作'指定数据库中指定存储程序'的权限(即存储程序级权限)
				[with ...]     		声明，若声明为grant option，则表示允许被授权账户名授权给其他账户名；
								         若声明为资源限制，则表示对被授权账户名进行限制(可以设置多个资源限制)；


		grant proxy on 账户名 to 账户名1 [, 账户名2, ...] [with 授权选项]
			--> 设置账户名的代理账户名(即代理权限)；


		revoke 权限名称1 [(列名a1, 列名b1, ...)] [, 权限名称2 [(列名a2, 列名b2, ...)] , ...]
		on [table / function / procedure] 权限级别
		from 账户名1 [, 账户名2, ...]
			--> 废除一个或多个账户名上指定级别的指定权限(注意：是废除权限，不是删除账户名)；
				该操作必须拥有'mysql'数据库中create user或update权限(若启用系统变量read_only，则必须拥有super权限)；


		revoke all privileges, grant option
		from 账户名1 [, 账户名2, ...]
			--> 废除一个或多个账户名上所有的权限(注意：是废除权限，不是删除账户名)；
				该操作必须拥有'mysql'数据库中create user或update权限(若启用系统变量read_only，则必须拥有super权限)；


		revoke proxy on 账户名 from 账户名1 [, 账户名2, ...]
			--> 废除代理权限；

	数据库相关的操作
	----------------------
		create database [if not exists] 数据库名 [character set/charset=字符集] [collate=排序规则名];
			--> 创建数据库；
			--> 若声明if not exists，则创建已存在的数据库时不会报错(但这样的话创建操作本身无意义)；
			--> 字符集和排序规则存储在MySQL目录下的db.opt文件中；


		alter database 数据库名 [character set/charset=字符集] [collate=排序规则名];
			--> 修改数据库的字符集和排序规则；


		drop database [if exists] 数据库名;
			--> 删除数据库(自然包括其中所有的表)；
			--> 若声明if exists，则删除不存在的数据库时也不会报错；

	表相关的操作
	----------------------
		create [temporary] table [if not exists] 表名(
			列名1 列类型1 列约束1 [comment '注释内容']
			[column_format fixed / dynamic / default]
			[storage disk / memory / default]
			[references 其他表名(列名, ...)
			[match full / match partial / match simple]
			[on delete cascade / set null / set default / no action / restrict]
			[on update cascade / set null / set default / no action / restrict]
			],
			列名2 列类型2 列约束2 ...
			...,
		 .. primary key (列名1, 列名2, ...) [using btree/hash] [index_option],
		 .. unique key [索引名] (列名1, 列名2, ...) [using btree/hash] [index_option],
			index/key [索引名] (列名1, 列名2, ...) [using btree/hash] [index_option],
			fulltext key [索引名] (列名1, 列名2, ...) [index_option],
			spatial key [索引名] (列名1, 列名2, ...) [index_option],
		 	[constraint 外键标识] foreign key [索引名] (列名1, 列名2, ...) 
				references 其他表名(列名, ...)
				[match full / match partial / match simple]
				[on delete cascade / set null / set default / no action / restrict]
				[on update cascade / set null / set default / no action / restrict]
		) [表选项1, 表选项2, ...]
		[partition_options]
			--> 在'默认数据库'中使用'InnoDB引擎'创建表，该表的理论最大列数为4096；
			--> temporary       声明，可以创建临时表(当前session关闭时自动被删除)；
				if not exists   声明，可以阻止抛出错误(当待创建的表已经存在时)；
				表名             声明，可以用点号连接，例如：db_name.table_name 或 'db_name'.'table_name'；
				列类型           声明，可以见上文<MySQL的数据类型>；
				列约束           声明，可以有：
					[not null/null]  ->  是否允许列值为空；若缺省，则默认为null；
					[auto_increment] ->  为当前列(整数或浮点数类型的列)添加自增约束(列自建索引，列无默认值，列值为正数、使用null<推荐>或0做占位符、默认从1开始)
					[default 默认值]  ->  为当前列(blob,text和json类型的列除外)指定默认值(必须是常量，不可以是函数或表达式)
					[unique [key]]   ->  是否允许列值重复；
					[primary key]    ->  是否指定当前列为主键(等价于not null + unique [key])；
				comment         声明，可以为某个列注释内容(最多1024个字符)，这些内容会在show create table和show full columns语法中展示；
				column_format   声明，可以在NDB Cluster中指定每个NDB表的列格式；
				storage         声明，可以指定NDB表的列值存储在哪里；
				index/key       声明，可以为一列或多列创建一个普通的索引(索引值总是按升序排序)；
								     一些MySQL引擎允许创建索引时指定其类型，推荐位于索引覆盖的列名定义之后；
				unique [key]    声明，可以为一列或多列创建一个索引值均不重复(但允许多个列值为null)的索引，一张表可以有多个unique [key]索引；
									 一些MySQL引擎允许创建索引时指定其类型，推荐位于索引覆盖的列名定义之后；
									 若constraint symbol省略，则MySQL自动创建；若指定，则symbol必须是整个数据库唯一的；
				primary key     声明，可以为一列或多列创建一个索引值均不重复且非空(not null)的索引，一张表只能有一个primary key索引且其索引名总是为primary；
									 若用户未指定primary key索引但应用要求表中必须有primary key索引，则将首个无空值的unique [key]索引作为primary key索引；
									 一些MySQL引擎允许创建索引时指定其类型，推荐位于索引覆盖的列名定义之后；
				fulltext key    声明，仅InnoDB和MyISAM引擎支持，该索引仅覆盖char、varchar和text类型的列；
				spatial key 	声明，仅InnoDB和MyISAM引擎支持，该索引仅覆盖spatial类型的列；
				注意：
					1) 索引定义时，按照先primary key，再unique [key]，再普通索引的顺序，更利于检测unique [key]索引的重复问题
					2) 索引定义时，若未指定索引名，则索引名自动为<'索引覆盖的首个列名' + '_可选数字'>
				[constraint 外键标识 ...]  声明，'外键标识'和'索引名'都可以用作外键的ID(优先使用'外键标识'；若未声明，则使用'索引名'；若均未声明，则使用创建该外键的'列名')；
									 on delete / on update 声明，表示当'被关联表'(即父表)中的值被删除或更新时，'发起关联的表'(即子表)中的值如何变化：
									 	restrict / no action ,(默认)表示抵制父表的变化
									 	cascade ,表示子表的值随父表的变化而变化，且不会触发'触发器'(如果有的话)
										set null ,表示子表的值变为null(如果允许的话)
										set default ,表示子表的值变为列的默认值
			--> 表选项           声明，(常见的)可以有：
					engine [=] 引擎名/'引擎名'
						->  指定当前表所使用的引擎(推荐为'DEFAULT'，即默认的InNoDB引擎)，加不加引号一样；
						   InnoDB / MyISAM / NDB / MEMORY / ARCHIVE / CSV / EXAMPLE / FEDERATED / HEAP / MERGE
					auto_increment [=] 值
						->  指定当前表中带有自增约束的列的初始值(适用于InnoDB、MyISAM、MEMORY和ARCHIVE引擎创建的表，
						   其他引擎创建的表可以先插入一行数据<带有自增约束的列值为n-1>，再删掉刚插入的一行数据，这样也能使带有自增约束的列的初始值为n)；
					character set [=] 字符集名
						->  指定当前表所使用的字符集；若为default，则遵循当前数据库所使用的字符集；
					collate [=] 排序规则名
						->  指定当前表所使用的排序规则；
					comment [=] '注释内容'
						->  指定当前表的注释内容(最多2048个字符)；
					data directory = '系统级目录路径'
						->  将每张表空间的文件储存到MySQL数据目录之外的其他目录下，仅适用于MyISAM引擎；
					index directory = '系统级目录路径'
						->  将每张表空间的文件储存到MySQL数据目录之外的其他目录下，仅适用于MyISAM引擎；
					tablespace [=] 表空间名
						->  指定当前表的表空间名；
			--> partition_options  声明，即MySQL的分区机制：
					* MySQL中只有InnoDB和NDB支持分区机制(最新的8.0版本中仅InnoDB支持)；
					* 分区表是一种逻辑表(非临时表，底层由物理子表组成)，分区表的声明语句实际上是对底层物理子表的句柄对象(Handler Object)的封装，
					  而这些句柄对象可以将'对分区表的请求'转化成'存储引擎的接口调用'(在存储引擎眼中，这些物理子表和正常的表一样)；
					* 分区表由多个物理子表组成，因此没有全局索引，且分区表的声明语句中的索引声明实际上是每个物理子表的索引声明；
					* 分区表的主要目的是将数据按照'较粗粒度'进行存储，以便后续集中管理；其优点是可以多终端存储数据、各分区数据独立删除和恢复、优化特定条件的查询；
					* MySQL中的分区表，是将'行数据'作为单元进行划分，而不是将'列数据'作为单元进行划分；
					* MySQL中的分区表，8.0版本最多支持8192个分区(含分区及子分区)，不支持spatial数据类型的列，不支持外键索引和全文索引；
					* 分区表的类型及创建：
						* '分区表达式'或'列名集合'中涉及的所有列名必须是当前表中所有unique key(含primary key)的共有列名；
						1. range分区
							原理：若某些'行数据'所对应的'分区表达式'的值位于同一范围内，则将这些'行数据'划分至同一分区；
							特点：range分区是'连续但不重叠的'、'values less than关键字定义的'；
							示例：create table xxx (
								"""列定义""",
								"""索引定义"""
								) """表选项"""
								partition by range (分区表达式) (
									partition 分区名1 values less than (分界值1),
									partition 分区名2 values less than (分界值2),
									partition 分区名3 values less than (分界值3),
									...
								)
							含义：某'行数据'经'分区表达式'返回的整型值小于'分界值1'					 ，则该'行数据'被划分至'分区名1'子表中；
																大于或等于'分界值1'且小于'分界值2'，则该'行数据'被划分至'分区名2'子表中；
																大于或等于'分界值2'且小于'分界值3'，则该'行数据'被划分至'分区名3'子表中；
																		...
							注释：a) '分区表达式'仅操作单个列值，可以是MySQL函数、常规表达式(/操作符必须用div操作符替代，不允许出现位操作符)，
							 	    但不允许是存储函数、存储过程、插件，也不允许出现系统变量和用户定义的变量)，
								    无论如何，'分区表达式'必须返回一个'整型值'或'null'('null'被视作最小的整型值)；
								 b) 声明语句中的'分界值'均为整型值，其中最后一个分界值可以使用'maxvalue'来代替，以表示最大的分界值；
								 c) 再次强调，'分区表达式'或'列名集合'中涉及的所有列名必须是当前表中所有unique key(含primary key)的共有列名；
								
						2. range columns分区
							原理：若某些'行数据'所对应的'列名集合'的值位于同一范围内，则将这些'行数据'划分至同一分区；
							特点：与range分区相似，区别在于range columns分区依靠'列名集合'进行比较从而敲定'行数据'的范围，而不是'分区表达式'； 
							示例：create table xxx (
								"""列定义""",
								"""索引定义"""
								) """表选项"""
								partition by range columns (列名集合) (
									partition 分区名1 values less than (列值集合1),
									partition 分区名2 values less than (列值集合2),
									partition 分区名3 values less than (列值集合3),
									...
								)
							含义：某'行数据'经'列名集合'返回的整体值小于'列值集合1'					   ，则该'行数据'被划分至'分区名1'子表中；
															大于或等于'列值集合1'且小于'列值集合2'，则该'行数据'被划分至'分区名2'子表中；
															大于或等于'列值集合2'且小于'列值集合3'，则该'行数据'被划分至'分区名3'子表中；
															...
							注释：a) '列名集合'包含一个或多个xxx表中的列名，形如：range columns (列名1, 列名2, ...)；
								 b) '列值集合'包含'列名集合'中对应列名的值，'null'被视作最小的整型值，要求值的数量和顺序与'列名集合'中的完全一致，
							        形如：values less than (列值1, 列值2 , ...)；
								 c) '列值集合'中每个值的类型要求不高(可以是整型系列、date、datetime、char、varchar、binary、varbinary)，
								    也都可以使用'maxvalue'来代替最大的列值；
								 d) range columns分区中敲定范围，是将'列名集合'作为一个元组整体与'列值集合'比较(从左至右依次比较每个列值)；
								 e) 再次强调，'分区表达式'或'列名集合'中涉及的所有列名必须是当前表中所有unique key(含primary key)的共有列名；

						3. list分区
							原理：若某些'行数据'所对应的'分区表达式'的值位于同一集合内，则将这些'行数据'划分至同一分区；
							特点：与range分区相似，其区别在于list分区是'基于成员关系'，而不是范围；
							示例：create table xxx (
								"""列定义""",
								"""索引定义"""
								) """表选项"""
								partition by list (分区表达式) (
									partition 分区名1 values in (分界集合1),
									partition 分区名2 values in (分界集合2),
									partition 分区名3 values in (分界集合3),
									...
								)
							含义：某'行数据'经'分区表达式'返回的整型值位于'分界集合1'中，则该'行数据'被划分至'分区名1'子表中；
																位于'分界集合2'中，则该'行数据'被划分至'分区名2'子表中；
																位于'分界集合3'中，则该'行数据'被划分至'分区名3'子表中；
																...
							注释：a) '分区表达式'仅操作单个列值(可以是函数、表达式等)，无论如何它必须返回一个'整型值'(不允许'null')；
								 b) 无法使用'maxvalue'；
								 c) 再次强调，'分区表达式'或'列名集合'中涉及的所有列名必须是当前表中所有unique key(含primary key)的共有列名；
								
						4. list columns分区 
							原理：若某些'行数据'所对应的'列名集合'的值位于同一集合内，则将这些'行数据'划分至同一分区；
							特点：与list分区相似，区别在于list columns分区依靠'列名集合'进行比较从而敲定'行数据'的集合，而不是'分区表达式'； 
							示例：create table xxx (
								"""列定义""",
								"""索引定义"""
								) """表选项"""
								partition by list columns (列名集合) (
									partition 分区名1 values in (列值集合1),
									partition 分区名2 values in (列值集合2),
									partition 分区名3 values in (列值集合3),
									...
								)
							含义：某'行数据'经'列名集合'返回的整体值位于'列值集合1'中，则该'行数据'被划分至'分区名1'子表中；
															位于'列值集合2'中，则该'行数据'被划分至'分区名2'子表中；
															位于'列值集合3'中，则该'行数据'被划分至'分区名3'子表中；
															...
							注释：a) '列名集合'包含一个或多个xxx表中的列名，形如：list columns (列名1, 列名2, ...)；
								 b) '列值集合'包含一个或多个整体值(每个整体值都包含'列名集合'中对应列名的值，不允许null，要求值的数量和顺序与'列名集合'中的完全一致)，
								    形如：values in ((列值1, 列值2 , ...), (列值a, 列值b , ...), ...)；
								 c) '列值集合'中每个值的类型要求不高(可以是整型系列、date、datetime、char、varchar、binary、varbinary)，
								    也都可以使用'maxvalue'来代替最大的列值；
								 d) list columns分区中敲定集合，是将'列名集合'作为一个元组整体与'列值集合'比较(判断是否是其成员)；
								 e) 再次强调，'分区表达式'或'列名集合'中涉及的所有列名必须是当前表中所有unique key(含primary key)的共有列名；

						5. hash分区
							原理：若某些'行数据'所对应的'分区表达式'的值除'分区数'后的余数相同，则将这些'行数据'划分至同一分区；
							特点：hash分区主要用于均衡分配'行数据'，不需要显式指定分界值或集合值；
							示例：create table xxx (
								"""列定义""",
								"""索引定义"""
								) """表选项"""
								partition by hash (分区表达式)
								partitions 分区数
							含义：某'行数据'经'分区表达式'返回的值为a，声明语句中的'分区数'为b，则该'行数据'被划分至'a mod b'号分区(分区编号为0 ~ b-1)；
							注释：a) '分区表达式'操作单个列值(允许但不推荐操作多个列值)，它必须返回一个非固定且非随机的'整型值'或'null'('null'被视作0)；
								 b) <'分区表达式'的返回值>与<被操作的单个列值>之间最好是线性关系，即自变量(单个列值)的变动不会造成因变量(表达式返回值)的剧烈变动；
								 c) 分区数，是一个正整数，表示当前表将被划分成多少个分区；
						
						6. linear hash分区
							原理：若某些'行数据'所对应的'分区表达式'的值经特定算法后的结果相同，则将这些'行数据'划分至同一分区；
							特点：声明语句简单，对分区的增、删、合并、分割等操作更快，但均衡分配上不及hash分区；
							示例：create table xxx (
								"""列定义""",
								"""索引定义"""
								) """表选项"""
								partition by linear hash (分区表达式)
								partitions 分区数
							含义：某'行数据'经'分区表达式'返回的值为a，声明语句中的'分区数'为b，则：
									a) V = power(2, ceiling(log(2, b))) 	->  对'分区数'b取2的对数，再四舍五入，再取2的幂
									b) N = a & (V-1)  						->  对上述结果减1，再与'分区表达式'返回的值a做'按位与'
									c) while N>= b:
										V = V/2
										N = N & (V-1)
									d) 该'行数据'被划分至N号分区
							备注：a) '分区表达式'操作单个列值(允许但不推荐操作多个列值)，它必须返回一个非固定且非随机的'整型值'或'null'('null'被视作0)；
								 b) 分区数，是一个正整数，表示当前表将被划分成多少个分区；
						
						7. key分区
							原理：自适应分区；
							特点：与hash分区相似，其区别在于key分区不再使用用户定义的'分区表达式'，而是当前表主键索引的部分或全部列名；其算法也不再是求余，而是MySQL服务器内置的hash函数；
							示例：create table xxx (
								"""列定义""",
								"""索引定义"""
								) """表选项"""
								partition by key ([主键索引的部分或全部列名])
								partitions 分区数
							含义：自适应分区；
							备注：a) 主键索引的部分或全部列名，为0或多个列名(即可以省略，若省略，则默认使用主键索引对应的列名，
							        这意味无主键索引时按照规定自动使用第一个无null值的unique key对应的列名)
								 b) 主键索引的部分或全部列名的值，不要求必须是'整型值'或'null'(若出现'null'，则'null'被视作0)；
						
						8. linear key分区 
							与key分区的唯一区别在于，linear key分区的算法不再是MySQL服务器内置的hash函数，而是linear hash的算法；

		create [temporary] table [if not exists] 表名
		like 已存在的表名
			--> like          声明，可以创建已有表的空副本(无数据，但保留所有的列和索引)


		create [temporary] table [if not exists] 表名
		[(
			列名1 列类型1 列约束1 [comment '注释内容']
			[column_format fixed / dynamic / default]
			[storage disk / memory / default]
			[
				references 其他表名(列名, ...)
				[match full / match partial / match simple]
				[on delete cascade / set null / set default / no action / restrict]
				[on update cascade / set null / set default / no action / restrict]
			],
			列名2 列类型2 列约束2
			...
			...,
			""" 各种索引定义 """
		)]
		[表选项1, 表选项2, ...]
		[partition_options]
		[igore/replace] as 查询语句
			--> as            声明，可以根据某个查询结果创建表；
			    igore/replace 声明，必须指定其中一个，即拷贝查询结果中带有unique约束的列值时，是直接忽略上述列值所对应的行数据(即igore)，还是在新表中保留下来(即replace)；
			    				   否则碰到unique约束的列值重复时会报错；


		alter table 表名
		[更新声明1, 更新声明2, ...]
		[partition_options]
			--> 更新声明，(常见的)可以有：
					更新表选项
						->  例如，engine = 'xxx'/xxx

					lock [=] default/none/shared/exclusive
						->  指定更新表期间，支持并发读/写的等级；
						->  default, 即若支持读写，则允许读/写，次之若支持读，则允许读，再之强制排它锁；
						   none, 即若支持读/写，则允许读/写，否则报错；
						   shared, 即若支持读，则允许读，否则报错；
						   exclusive, 即强制排它锁；

					add [column] (新列名1 新列类型1 新列约束1, 新列名2 新列类型2 新列约束2, ...)
						->  向当前表中添加新的一列或多列；

					add [column] 新列名1 新列类型1 新列约束1 first/after 已有列名
						->  向当前表中精准添加新的一列(即在已有列的前面或后面新添)；

					change [column] 旧列名 新列名 新列类型 新列约束 [first/after 已有列名]
						->  修改当前表中已存在的列(重命名、类型修改、约束修改)；
					modify [column] 列名 新列类型 新列约束 [first/after 已有列名]
						->  修改当前表中已存在的列(类型修改、约束修改)，对不重命名的修改列操作有优化；

					alter [column] 列名 set default 新默认值 / drop default
						->  修改/删除当前表中已存在的列的默认值；

					drop [column] 已有列名
						->  删除当前表中已存在的列(若当前表中仅含一列，则禁止删除该列)；

					add .. primary key (列名1, 列名2, ...) [using btree/hash] [index_option]
						->  向一列或多列添加primary key索引；
						   若constraint symbol省略，则MySQL自动创建；若指定，则symbol必须是整个数据库唯一的；

					add .. unique key [索引名] (列名1, 列名2, ...) [using btree/hash] [index_option]
						->  向一列或多列添加unique [key]索引；
						   若constraint symbol省略，则MySQL自动创建；若指定，则symbol必须是整个数据库唯一的；

					add index/key [索引名] (列名1, 列名2, ...) [using btree/hash] [index_option]
						->  向一列或多列添加普通索引；

					add fulltext key [索引名] (列名1, 列名2, ...) [using btree/hash] [index_option]
						->  向一列或多列添加fulltext [key]索引；

					add spatial key [索引名] (列名1, 列名2, ...) [using btree/hash] [index_option]
						->  向一列或多列添加spatial [key]索引；

					add constraint 外键标识 foreign key (列名1, 列名2, ...) 
						references 其他表名(列名, ...)
						[match full / match partial / match simple]
						[on delete cascade / set null / set default / no action / restrict]
						[on update cascade / set null / set default / no action / restrict]
						->  向一列或多列添加外键；

					rename index/key 旧索引名 to 新索引名
						->  重命名普通索引；

					drop primary key
						->  删除primary key索引；若未定义primary key索引，则删除操作会报错；

					drop index/key 索引名
						->  删除普通索引；

					drop foreign key 外键标识
						->  删除外键；

					rename to/as 新表名
						->  重命名表名；

					convert to character set 新字符集名 [collate 新排序规则名]
						->  修改整张表的字符集和排序规则(若未指定，则使用对应字符集的默认排序规则)；

					order by 列名1[, 列名2, ...] [asc/desc]
						->  将当前表中的一列或多列数据按照升序/降序进行排序(因为多次插入或更新后，当前表中的数据可能已经乱序)；


		drop [temporary] table [if exists] 表名1 [, 表名2, ...] [restrict/cascade]
			--> 删除表和数据；
			--> temporary   声明，可以仅删除临时表；
				if exists   声明，可以在删除不存在的表时阻止报错；


		truncate table 表名
			--> 删除全部数据，定义为DDL声明；与DML声明的delete语法有以下不同：
				a. truncate语法是<先drop，后re-create>操作，比一行一行地删除的delete语法快；
				b. truncate语法无法回滚；
				c. truncate语法无法删除一个上了表锁的表，也无法在一个事务中声明；
				d. truncate语法无法删除一个拥有跨表外键的表(同表外键可以)；
				e. truncate语法永远显示有效操作行数为0(即'0 rows affected')；
				f. truncate语法无法触发设定为delete由头的触发器；
				g. truncate语法将所有auto_increment声明的列值恢复到初始值；


		delete [low_priority] [quick] [ignore] from 表名
		[partition (分区表名1, 分区表名2, ...)]
		[where 条件声明]
		[order by ...]
		[limit 行数]
			--> 删除单表中的一行或多行数据，定义为DML声明；
			--> low_priority  声明，表示该操作处于低优先级，会延迟到没有任何客户端执行数据库的读操作后执行；
				ignore        声明，表示该操作期间阻止报错；
				where         声明，表示删除符合指定条件的行；若未指定，则表示删除整张表的数据；
				order by      声明，表示按照指定顺序从前往后删除；
				limit         声明，表示待删除的总行数；


		delete [low_priority] [quick] [ignore] 表名1[.*] [,表名2[.*], ...] from 连表声明
		[where 条件声明]

		delete [low_priority] [quick] [ignore] from 表名1[.*] [,表名2[.*], ...] using 连表声明
		[where 条件声明]
			--> 上述两个语法等效，都是删除多表(即表名1[.*] [,表名2[.*], ...])中的一行或多行数据，定义为DML声明；
			--> .*            声明，表示兼容性地进入对应表；

		转义连表表达式1[, 转义连表表达式2, ...]
			--> 连表声明(即JOIN语法)，多用于select语法、多表delete语法和多表update语法；
			--> 转义连表表达式，紧跟的','分隔符的优先级较低，(常见的)可以是：
					<1> 表表达式，可以是：
							a. 表名 [partition (分区表1, 分区表2, ...)] [as 别名] [索引使用规则1[, 索引使用规则2, ...]]
							b. 表查询结果 as 结果别名

					<2> 连表表达式，可以是：
							a. (左)表表达式/(左)连表表达式 [inner/cross] join (右)表表达式 [on 条件表达式/using(列名1, 列名2, ...)]
							b. (左)表表达式/(左)连表表达式 left/right [outer] join (右)表表达式 on 条件表达式/using (列名1, 列名2, ...)
							c. (左)表表达式/(左)连表表达式 natural [left/right [outer]] join (右)表表达式
							d. (左)表表达式/(左)连表表达式 straight_join (右)表表达式 [on 条件表达式]

					索引使用规则                  	 ->  将指定MySQL如何使用索引；
					inner join/cross join/join   ->  在MySQL语法中是等价的，但在标准SQL语法中，inner join 需要搭配on使用；
					on 条件表达式                  ->  即where查询中所有可用的条件表达式；条件表达式可以使用'.'来表示某张表中的列(即'表名.列名')；
												    通常为左右表之间的关系；
					using(列名1, 列名2, ...)      ->  这些列名必须是所涉表中都有的列名；


					连表表达式的结果(从左至右)：

						一、join / inner join / cross join / straight_join
							无<on ...>或<using ...>声明：
							    列名：顺序取<左表>所有的列名，再顺序取<右表>所有的列名
							    取值：<左表>列值1 + <右表>列值1
								     	...
								     <左表>列值n + <右表>列值1
							         ...
							         ...
							         <左表>列值1 + <右表>列值n
							         	...
							         <左表>列值n + <右表>列值n

							存在<on ...>声明：
								列名：顺序取<左表>所有的列名，再顺序取<右表>所有的列名
								取值：满足表达式的<左表>列值1 + 满足表达式的<右表>列值1
								     	...
								     满足表达式的<左表>列值n + 满足表达式的<右表>列值1
							         ...
							         ...
							         满足表达式的<左表>列值1 + 满足表达式的<右表>列值n
							         	...
							         满足表达式的<左表>列值n + 满足表达式的<右表>列值n

							存在<using ...>声明：
								列名：顺序取<左表>中<using ...>声明的<共有列名>，再顺序取<左表>中<剩余的列名>，最后顺序取<右表>中<剩余的列名>
								取值：<共有列名>     <左表剩余的列名>         <右表剩余的列名>
									 左表顺值a 	左表第1个顺值a的同行值    右表第1个顺值a的同行值
									 	...
									 左表顺值a 	左表第n个顺值a的同行值 	  右表第1个顺值a的同行值
									 	...
									 	...
									 左表顺值a 	左表第1个顺值a的同行值	  右表第n个顺值a的同行值
									 	...
									 左表顺值a 	左表第n个顺值a的同行值 	  左表第n个顺值a的同行值
									 ...
									 ...
									 左表顺值z 	左表第1个顺值z的同行值    右表第1个顺值z的同行值
 									 	...
 									 左表顺值z 	左表第n个顺值z的同行值 	  右表第1个顺值z的同行值
 									 	...
 									 	...
 									 左表顺值z 	左表第1个顺值z的同行值	  右表第n个顺值z的同行值
 									 	...
 									 左表顺值z 	左表第n个顺值z的同行值 	  左表第n个顺值z的同行值

								* 顺值a~顺值z均为<左表>和<右表>共有列名中共有的值，即<左表>共有列名中有，但<右表>共有列名中没有的值，不会出现在结果集中，反之亦然；
								* 同一个顺值出现的次数取决于：左表该值次数 * 右表该值次数；


						二、left join / right join -- left join<左表>为第一张表，<右表>为第二张表；right join<右表>为第一张表，<左表>为第二张表；
							存在<using ...>声明：
								列名：顺序取第一张表中<using ...>声明的<共有列名>，再顺序取第一张表中<剩余的列名>，最后顺序取第二张表中<剩余的列名>
								取值：<共有列名>     <第一张表剩余的列名>       <第二张表剩余的列名>
									 第一张表值a 	第一张表第1个值a的同行值    第二张表第1个值a的同行值
									 	...
									 第一张表值a 	第一张表第n个值a的同行值    第二张表第1个值a的同行值
									 	...
									 	...
									 第一张表值a 	第一张表第1个值a的同行值    第二张表第n个值a的同行值
									 	...
									 第一张表值a 	第一张表第n个值a的同行值    第二张表第n个值a的同行值
									 ...
									 ...
									 第一张表值z 	第一张表第1个值z的同行值    第二张表第1个值z的同行值
									 	...
									 第一张表值z 	第一张表第n个值z的同行值    第二张表第1个值z的同行值
									 	...
									 	...
									 第一张表值z 	第一张表第1个值z的同行值    第二张表第n个值z的同行值
									 	...
									 第一张表值z 	第一张表第n个值z的同行值    第二张表第n个值z的同行值

								* 值a~值z均为第一张表中的值，即第一张表共有列名中的所有值都会出现在结果集中；
							   ** 若第二张表中没有第一张表值，则<第二张表非公有列名>的同行值全部取null；
								* 同一个值出现的次数取决于：第一张表该值次数 * 第二张表该值次数；

							存在<on ...>声明：
								列名：顺序取第一张表中的所有列名，再顺序取第二张表中的所有列名
								取值：第一张表第1个列值a及同行值 + 满足表达式的第二张表第1个列值及同行值/null
								     	...
								     第一张表第n个列值a及同行值 + 满足表达式的第二张表第1个列值及同行值/null
								        ...
								        ...
							         第一张表第1个列值a及同行值 + 满足表达式的第二张表第n个列值及同行值/null
							     		...
							     	 第一张表第n个列值a及同行值 + 满足表达式的第二张表第n个列值及同行值/null
							     	 ...
							     	 ...
							     	 第一张表第1个列值z及同行值 + 满足表达式的第二张表第1个列值及同行值/null
 								     	...
 								     第一张表第n个列值z及同行值 + 满足表达式的第二张表第1个列值及同行值/null
 								        ...
 								        ...
 							         第一张表第1个列值z及同行值 + 满足表达式的第二张表第n个列值及同行值/null
 							     		...
 							     	 第一张表第n个列值z及同行值 + 满足表达式的第二张表第n个列值及同行值/null

 							    * 值a~值z均为第一张表中的值，即第一张表中的所有值都会出现在结果集中；
 							   ** 若第二张表中没有第一张表值，则第二张表的列值及同行值全部取null；
 							    * 同一个列值出现的次数取决于：第一张表该列值次数 * 第二张表该列值次数；


						三、natural left join / natural right join -- left join<左表>为第一张表，<右表>为第二张表；right join<右表>为第一张表，<左表>为第二张表；
							列名：顺序取第一张表中<所有的共有列名>，再顺序取第一张表中<剩余的列名>，最后顺序取第二张表中<剩余的列名>
						   	取值：<所有的共有列名>    <第一张表剩余的列名>       <第二张表剩余的列名>
						   		 第一张表值a 	    第一张表第1个值a的同行值    第二张表第1个值a的同行值
						   		 	...
						   		 第一张表值a 	    第一张表第n个值a的同行值    第二张表第1个值a的同行值
						   		 	...
						   		 	...
						   		 第一张表值a 	    第一张表第1个值a的同行值    第二张表第n个值a的同行值
						   		 	...
						   		 第一张表值a   		第一张表第n个值a的同行值    第二张表第n个值a的同行值
						   		 ...
						   		 ...
						   		 第一张表值z 	    第一张表第1个值z的同行值    第二张表第1个值z的同行值
						   		 	...
						   		 第一张表值z 	    第一张表第n个值z的同行值    第二张表第1个值z的同行值
						   		 	...
						   		 	...
						   		 第一张表值z 		第一张表第1个值z的同行值    第二张表第n个值z的同行值
						   		 	...
						   		 第一张表值z 		第一张表第n个值z的同行值    第二张表第n个值z的同行值

						   	 * 值a~值z均为第一张表中的值，即第一张表中的所有值都会出现在结果集中；
						   	** 若第二张表中没有第一张表值，则第二张表的同行值全部取null；
						   	 * 同一个列值出现的次数取决于：第一张表该列值次数 * 第二张表该列值次数；
					

		load data [low_priority / concurrent] [local] infile '文件名' [replace / ignore] into table 表名
		[partition (分区名1 [, 分区名2, ...])]
		[character set 字符集名]
		[columns [terminated by '字符串'] [enclosed by '字符'] [escaped by '字符']]
		[lines [terminated by '字符串] [starting by '字符串']]
		[ignore 数字 rows]
		[(列名1或用户变量1[, 列名2或用户变量2, ...])]
		[set 列名1= 表达式1/default[, 列名2= 表达式2/default, ...]]
			--> 从'文件名'中导入数据至指定的'表名'或'表的指定分区'中；
			--> low_priority            声明，表示该操作处于低优先级，会延迟到没有任何客户端执行该表的读操作后执行；
				local                   声明，若未声明，则'文件'必须位于MySQL服务器上(文件名可以是相对于MySQL数据目录的相对路径)；
										     否则，'文件'应位于客户端，待发送至服务器(文件名可以是相对于客户端当前目录的相对路径)；
				replace/ignore          声明，表示导入数据时，对于unique约束的列，若后续出现重复的列值时，是用后续的行替换之前的行(即replace)，还是忽略后续的行(即ignore)；
				columns... 和 lines...   声明，表示导入数据时，列与行之间的定界符；若未声明，则默认为：
											 columns terminated by '\t' enclosed by '' escaped by '\\'
											 lines terminated by '\n' starting by ''
				ignore 数字 rows         声明，表示导入数据时，忽略最开始的'数字'行数据；
				[(列名1或用户变量1, ...)]  声明，表示导入数据时，仅导入'文件''表中'的部分列；
				...
				...
				...

	数据相关的操作
	----------------------
		insert [low_priority/hign_priority] [ignore] into 表名 [partition (分区名1, 分区名2, ...)] [(列名a, 列名b, ...)] values
		(列值a1, 列值b1, ...),
		(列值a2, 列值b2, ...),
		...
		[on duplicate key update 列名a=xx[, 列名b=xx, ...]]
			--> 向'指定表'或'指定表的分区'中插入新行数据；
			--> low_priority  声明，表示该操作处于低优先级，会延迟到没有任何客户端执行数据库的读操作后执行；
				hign_priority 声明，会造成并发插入无效；
				ignore        声明，表示该操作期间阻止报错；
				列名a, ...     声明，非严格模式下，缺省的列名自动被设置为其默认值；
								   列名和列值的个数必须一一对应；
				列值a1, ...    声明，若对应的列名设有默认值，则可以使用default作为占位符来便捷输入；
								   列值可以使用表达式，例如：表达式default(列名) 和 default占位符 具有同样的效果；
								   还可以使用当前列的任意左侧列名作为当前列值表达式中的变量；


		insert [low_priority/hign_priority] [ignore] into 表名 [partition (分区名1, 分区名2, ...)] [(列名a, 列名b, ...)]
		"""查询语句"""
		[on duplicate key update 列名a=xx[, 列名b=xx, ...]]
			--> 根据查询语句结果向'指定表'或'指定表的分区'中插入新行数据；


		update [low_priority] [ignore] 表名 
		set 列名1=列值1[, 列名2=列值2, ...]
		[where 条件表达式]
		[order by ...]
		[limit 行数]
			--> 更新指定单表中指定行的部分或全部数据；
			--> low_priority  声明，表示该操作处于低优先级，会延迟到没有任何客户端执行数据库的读操作后执行；
				ignore        声明，表示该操作期间阻止报错；
				列值           声明，可以是具体值，也可以是表达式，也可以是default(表示当前列的默认值)；
				where         声明，若未声明，则更新的是指定表中的所有行，否则更新的是满足条件的行；
				order by      声明，按照指定的顺序依次更新行数据；
				limit		  声明，规定更新的总行数；

		update [low_priority] [ignore] 表表达式/连表表达式 
		set 列名1=列值1[, 列名2=列值2, ...]
		[where 条件表达式]
			--> 更新指定多表中指定行的部分或全部数据；多表更新禁止使用order by和limit声明；
			--> low_priority  声明，表示该操作处于低优先级，会延迟到没有任何客户端执行数据库的读操作后执行；
				ignore        声明，表示该操作期间阻止报错；
				列值           声明，可以是具体指，也可以是表达式，也可以是default(表示当前列的默认值)；
				where         声明，若未声明，则更新的是指定表中的所有行，否则更新的是满足条件的行；


		select [all/distinct] [hign_priority] [straight_join]
		[sql_small_result] [sql_big_result] [sql_buffer_result] [sql_calc_found_rows]
		列表达式1 [as 列表达式别名1][, 列表达式2 [as 列表达式别名2], ...] / 函数 / 操作符连接的表达式
		[from 连表声明 [partition 分区名1, 分区名2, ...]]
		[where 条件表达式]
		[group by 列名1/表达式1/位置1 [asc/desc], 列名2/表达式2/位置2 [asc/desc], ...]
		[having 条件表达式]
		[order by 列名1/表达式1/位置1 [asc/desc], 列名2/表达式2/位置2 [asc/desc], ...]
		[limit 开始行号, 总行数]
		[
		into outfile '文件路径名' [character set 字符集名] 导出选项 /
		into dumpfile '文件路径名' /
		into 变量名1[, 变量名2, ...]
		]
		[for update / lock in share mode]
			--> 显示一张或多张表中的数据；
			--> all/distinct         声明，二选其一，all(默认)表示返回所有的结果行；distinct表示移除结果行中重复的行后返回；
			    hign_priority        声明，表示select操作的优先级高于update操作，建议仅在需要快速查询或立即返回结果时使用；
			    straight_join        声明，表示强制按照连表声明中表的出现顺序查询数据；
			    sql_buffer_result    声明，表示强制将结果放入一张临时表中，利于MySQL提早释放表锁；
			    sql_calc_found_rows  声明，表示让MySQL计算结果行的总行数(忽略limit声明)；
			    列表达式               声明，表示要获取哪些列的数据；若想获取某张表中的所有列，则为 表名.*（建议加上'.*'用于提升兼容性)；
				函数 / 操作符连接的表达式 声明，表示显示的并非表格中的数据，而是函数的结果或表达式的值(就是单纯地将结果显示出来)；
			    连表声明               声明，表示要从哪些表中获取对应的数据；
			    位置1 ...             声明，列的位置从1开始计算；
			    limit ...   		 声明，表示从'开始行号'开始(包括当前行)返回'总行数'行数据；行号从'0'开始计算；
			    into ...             声明，即select ... into语法；
			     						  into 变量名1[, 变量名2, ...] 将单行的列值储存至对应的变量(变量名大小写不敏感，避免同名)中，变量和列的数量要一致；
		     						  	  into outfile 将数据写入指定的文件(含后缀名)中；
			     						  into dumpfile 将一行数据写入指定的文件(含后缀名)中；
			--> 关键字:   select  [...distinct]       列表达式1... 	   from  连表声明  [where...]    [group by...]      [having...]     [order by...] [limit...]
			--> 编写顺序:   显示     【非重复的】    所有信息/指定信息/统计结果     从原始集     where结果集  where后的分组结果集  分组后的having结果集   按照...排序    分页的操作
			--> 执行顺序:    4          4                  4                  1            2               3                5                 6            7
		
		[(] select语句1 [)]
		union
		[(] select语句2 [)]
		...
		order by 列名 
		limit 数字
			--> union语法，即将2或多个select语法的结果汇总在一起；
			--> union语法的结果：
				1) 使用第1个select语句显示的列名作为最终结果的列名；
				2) 后续所有的select语句显示的每个列的类型，都要与第1个select语句显示的对应位置的列的类型相同；
				3) 仅限最后1个select语句能够声明'select ... into outfile'语法，但实际效果是将最终结果写入指定的文件；
				4) 所有的select语句禁止声明'hign_priority'关键字；
				5) 若单个select语句中出现'order by'或'limit'声明，则需要将整个select语句用'()'括起来；
				6) 单个select语句中的'order by'或'limit'声明，无法影响最终结果的排序；
				7) 若想影响最终结果，需要在最后使用'order by'或'limit'声明，其中'order by'声明的列名只能是'第1个select语句显示的列名'或其别名；
				   注意：
				       * 若第1个select语句显示的列名中使用了'as ..'的别名语法，则最后使用的'order by'声明的列名只能使用这些别名；
					   * 无论如何，最后使用的'order by'声明的列名不能使用'表名.列名'的格式，也不能使用'位置列名'；

		子查询语句
			* 子查询语句，是嵌套在其他SQL语句中的select语句，其他SQL语句可以是：select语句、insert语句、update语句、delete语句、set语句和do语句；
			* 子查询语句，必须使用()括号包裹；
			* 子查询语句，具有提高可读性、分解复杂语句的优点：
			* 子查询语句，按返回值的类型可以分为单值子查询(单个数据)、单行子查询(单行数据)、单列子查询(单列数据)，单表子查询(一行或多行数据，每行包括一列或多列数据)，因此：
				子查询语句可以用于'比较'，例如：
					... where col =/<=>/<>/!=/>/</>=/<= (子查询语句)
				
				子查询语句也可以用于'多值比较'，例如： 
					... where col =/<=>/<>/!=/>/</>=/<= any (子查询语句)
						1) '操作符 any'意味着只要满足子查询语句中的任意返回值，条件表达式就为true；
						2) '= any (子查询语句)' 等价于 'in (子查询语句)'；
						3) 若子查询语句为空，'... where col > any (子查询语句)'这个条件表达式为false，其他操作符可想而知；
					
					... where col =/<=>/<>/!=/>/</>=/<= all (子查询语句)
						1) '操作符 all'意味着需要满足子查询语句中的所有返回值，条件表达式才为true；
						2) '<> all (子查询语句)' 等价于 'not in (子查询语句)'；
						3) 若子查询语句为空，'... where col > all (子查询语句)'这个条件表达式为true，其他操作符可想而知；

				子查询语句也可以用于'行比较'，例如： 
					... where (col1, col2, ...) 操作符 any/all (子查询语句)

				子查询语句也可以用于'存在与否的判定'，例如：
					... where not exists / exists (子查询语句)

			* select语句要求自己from子句中的每张表都必须有名字，因此:
				* 若子查询语句出现在其他SQL语句的from子句中，则需要将其声明为'派生表'，例如：select ... from (子查询语句) as 派生表名；
				* 子查询语句要求自己select的所有列都必须有唯一的名字，否则需要为列声明一个唯一的名字，例如：select ... from (select col as 唯一列名, col2 as 唯一列名) as 派生表名；


	视图相关的操作(完)
	----------------------
		create [or replace]
		[algorithm=undefined/merge/temptable]
		[definer=current_user/'账户名'@'主机名']
		[sql security definer/invoker]
		view 视图名 [(列名1, 列名2, ...)] as 查询语句
		[with [cascade/local] check option]
			--> 创建一个视图；无法在临时表上创建视图；
			--> or replace   声明，表示替换一个已存在的视图；若视图不存在，加不加该声明都一样(即表示创建一个新视图)；
				definer      声明，表示使用哪个MySQL账号(默认为current_user，即执行当前创建操作者)，去核实是否有权限执行相关的视图操作；
				sql security 声明，表示是定义视图者(默认)还是使用视图者，必须持有必要的权限；
				视图名        声明，表示在默认的数据库中创建视图；若想指定数据库，则使用<数据库名.视图名>的命名方式；
								  视图和所在表共享命名空间，所以它们不能同名；

		alter
		[algorithm=undefined/merge/temptable]
		[definer=current_user/'账户名'@'主机名']
		[sql security definer/invoker]
		view 视图名 [(列名1, 列名2, ...)] as 查询语句
		[with [cascade/local] check option]
			--> 修改一个视图；与视图定义类似，但要求待修改的视图必须已经存在；

		drop view [if exists] 视图名1 [,视图名2, ...]
			--> 删除一个或多个视图；
			--> if exists    声明，可以在删除不存在的视图时阻止报错；

	存储程序相关的操作(完)
	----------------------
		触发器相关的操作(完)
		----------------------
			create [definer=current_user/'账户名'@'主机名'] trigger 触发器名
			before/after insert/update/delete on 表名 for each row [follows/precedes 已存在触发器名]
			begin
			声明语句1
			声明语句2
			...
			end
				--> 创建一个触发器；无法在临时表或视图上创建触发器；触发器与所在表共享命名空间，所以它们不能同名，也不能与所在表的其他触发器同名；触发器无法返回数据；
				--> before/after          声明，表示触发时机；
				    insert/update/delete  声明，表示触发由头；
				    表名                   声明，表示触发器所在的表；
				    follows/precedes      声明，表示同一张表中触发时机和触发由头相同，但名字不同的多个触发器之间执行的先后顺序；
				    						   follows  已存在触发器名 ->  表示当前创建的触发器会在已存在的之后执行；
				    						   precedes 已存在触发器名 ->  表示当前创建的触发器会在已存在的之前执行；
				  	begin...end           声明，表示触发器被触发时执行的语句；

			drop trigger [if exists] [数据库名.]触发器名
				--> 删除一个触发器；
				--> if exists             声明，可以在删除不存在的触发器时阻止报错；
					数据库名.               声明，可以删除指定数据库的一个触发器，否则都是删除默认的数据库；

		事件相关的操作(完)
		----------------------
			create [definer=current_user/'账户名'@'主机名'] event [if not exists] 事件名
			on schedule
			at 时间点 [+ interval 数量 单位 ...] /
			every 数量 单位 [+ interval 数量 单位 ...] [starts 时间点[+ interval 数量 单位 ...]] [ends 时间点[+ interval 数量 单位 ...]]
			[on completion [not] preserve]
			[enable / disable / disable on slave]
			[comment '最多64个字符']
			do
			SQL语句
			SQL语句
			...
				--> 创建事件
				--> definer             声明，表示事件执行时使用哪个账户去验证相关的权限，默认为current_user；
					事件名               声明，最多64个字符，对大小写不敏感；默认在当前数据库创建事件，若想在指定的数据库创建，事件名应为'数据库名.事件名'；
					at 时间点 [...]      声明，用于执行一次性的事件；它必须包括日期和时间内容(例如：at '2006-02-10 23:59:00')，包括但不限于：current_timestamp / datetime对象 / 时间
					戳对象 / 能输出日期和时间的表达式；
										     at 时间点                        ->  在某个时间点执行一次事件；
										     at 时间点 + interval 数量 单位 ... ->  在某个'时间点 + 数量 单位'时间点执行一次时间；
					every 数量 单位 ...   声明，在starts声明的时间点至ends声明的时间点期间，每隔'数量 单位'或'数量 单位 + 数量 单位'时间执行一次事件；
					单位                 声明，包括：year/year_month/quarter/month/week/day/day_hour/day_minute/day_second/hour/hour_minute /hour_second/minute/minute_second/second
												   n     n-m        n       n    n    n    n:m       n:m         n:m     n       n:m          n:m       n         n:m         n
											 注意：所有'n-m'或'n:m'形式的'数量'值都需要加上引号，例如：+ interval '2:01' minute_second
				    on completion ...   声明，指定事件执行后是否保存(默认事件执行后立即删除)；
				    enable              声明，重新启用事件；
				    disable             声明，禁用事件(即虽然创建，但不开启)；
				    disable on slave    声明，主从复制时，从服务器拷贝主服务器的事件，但不开启它们；
				    do   				声明，表示后续都是事件执行后需要执行的语句；

			alter [definer=current_user/'账户名'@'主机名'] event 事件名
			[on schedule 时间点配置]
			[on completion [not] preserve]
			[rename to 新事件名]
			[enable / disable / disable on slave]
			[comment '最多64个字符']
			[do
			SQL语句
			SQL语句
			...]
				--> 修改一个事件，事件必须存在；

			drop event [if exists] 事件名
				--> 删除一个事件；
				--> if exists            声明，可以在删除不存在的事件时阻止报错；

		存储程序相关的操作(完)
		----------------------
			create [definer=current_user/'账户名'@'主机名'] procedure 存储过程名
			([[in/out/inout] 参数名1 参数类型1, [in/out/inout] 参数名2 参数类型2, ...])
			[comment '字符串' /
			 language sql /
			 contains sql / no sql / reads sql data / modifies sql data /
			 [not] deterministic /
			 sql security definer/invoker]
			SQL语句
				--> 在默认数据库中创建一个存储过程(需要create routiue权限)；调用一个存储过程，使用call语法即可；
					为了SQL语句中的';'定界符能够使用，一般会在创建之前执行'delimiter 其他定界符'的操作；
				--> 存储过程名		  声明，若想在指定数据库中创建，可命名为'数据库名.存储过程名'；
					in              声明，表示对应的'参数'将被传入存储过程中，它可以被修改但不会被返回；
										 若在存储过程中想调用其他的存储过程，可以将其他的作为参数传入；
					out 			声明，表示对应的'参数'初始值为null，它最终会从存储过程中返回；
					inout 			声明，表示对应的'参数'将被传入存储过程中，它可以被修改，最终也会从存储过程中返回；
										 若在存储过程中想调用其他的存储过程，可以将其他的作为参数传入；
					comment         声明，表示当前存储过程的注释内容；
					language        声明，表示当前存储过程是用什么语言写成的(服务器会无视它)；
					deterministic   声明，若对当前的存储程序传入相同的参数一定得到相同的结果，则为deterministic(默认为not deterministic)；
					contains sql/...声明，表示接下来要执行的SQL语句是什么样的操作，总的来说：
											contains sql 	  ->  表示要执行的SQL语句包含'读取或写入数据'的操作；
											no sql 		  	  ->  表示要执行的SQL语句不包含SQL语句；
											reads sql data 	  ->  表示要执行的SQL语句包含'读取数据'的操作，但没有'写入数据'的操作；
											modifies sql data ->  表示要执行的SQL语句包含'写入数据'的操作；
					sql security    声明，表示在执行存储过程时，使用什么账号来验证相关的权限；


			alter procedure 存储过程名
			[comment '字符串' /
			 language sql /
			 contains sql / no sql / reads sql data / modifies sql data /
			 sql security definer/invoker]
			 	--> 修改一个存储过程；


			drop procedure [if exists] 存储过程名
				--> 删除一个存储过程；


			create [definer=current_user/'账户名'@'主机名'] function 存储函数名
			([参数名1 参数类型1, 参数名2 参数类型2, ...]) returns 任意的MySQL数据类型
			[comment '字符串' /
			 language sql /
			 contains sql / no sql / reads sql data / modifies sql data /
			 [not] deterministic /
			 sql security definer/invoker]
			SQL语句
				--> 在默认数据库中创建一个存储函数(需要create routiue权限)；调用一个存储函数，在表达式中使用它即可；
					为了SQL语句中的';'定界符能够使用，一般会在创建之前执行'delimiter 其他定界符'的操作；
				--> 参数名1          声明，存储函数中所有的参数都是'in'，所以无需显示声明；
					returns         声明，表示存储函数返回的数据类型(仅适用于存储函数，且必须指定)；
					comment         声明，表示当前存储过程的注释内容；
					language        声明，表示当前存储过程是用什么语言写成的(服务器会无视它)；
					deterministic   声明，若对当前的存储程序传入相同的参数一定得到相同的结果，则为deterministic(默认为not deterministic)；
					contains sql/...声明，表示接下来要执行的SQL语句是什么样的操作，总的来说：
											contains sql 	  ->  表示要执行的SQL语句包含'读取或写入数据'的操作；
											no sql 		  	  ->  表示要执行的SQL语句不包含SQL语句；
											reads sql data 	  ->  表示要执行的SQL语句包含'读取数据'的操作，但没有'写入数据'的操作；
											modifies sql data ->  表示要执行的SQL语句包含'写入数据'的操作；
					sql security    声明，表示在执行存储过程时，使用什么账号来验证相关的权限；
					SQL语句          声明，对于存储函数而言，必须提供return value的声明(若该value与声明的类型不同，会被强制转换)；


			alter function 存储函数名
			[comment '字符串' /
			 language sql /
			 contains sql / no sql / reads sql data / modifies sql data /
			 sql security definer/invoker]
			 	--> 修改一个存储函数；


			 drop function [if exists] 存储函数名
				--> 删除一个存储函数；

		复合声明相关的操作
		----------------------
			begin
			[SQL语句
			...]
			end
				--> 复合声明，即begin...end语句，一种用begin和end关键字定义的作用于存储程序的语句块；
							它可以嵌套复合声明或其他作用于存储程序的语句块(例如，declare语句、条件语句、游标语句和循环控制、条件测试语句等)；


			declare 变量名1 [,变量名2, ...] 变量类型 [default 变量默认值]
				--> declare语句，用于存储程序中定义局部变量(即作用于仅限begin和end之间的变量)；
				--> 变量名 			声明，最好不要与存储程序中出现的表中的列名相同；


			case 基值表达式
			when 比较值表达式1 
				then SQL语句1
			[when 比较值表达式2 
				then SQL语句2
			...]
			[else SQL语句]
			end case
				--> case语句，用于存储程序中实现复杂条件判断；执行第一个与'基值表达式'相等的'比较值表达式'所对应的'SQL语句'，
							 若所有的'比较值表达式'都不和'基值表达式'相等，则执行'else'所对应的语句(若有的话)；


			case 
			when 条件表达式1 
				then SQL语句1
			[when 条件表达式2 
				then SQL语句2
			...]
			[else SQL语句]
			end case
				--> case语句，用于存储程序中实现复杂条件判断；执行第一个为true的'条件表达式'所对应的'SQL语句'，
							 若所有的'条件表达式'都不为true，则执行'else'所对应的语句(若有的话)；


			if 条件表达式1 
				then SQL语句1
			[elseif 条件表达式2 
				then SQL语句2
			...]
			[else SQL语句]
			end if
				--> if语句，用于存储程序中实现简单条件判断；执行第一个为true的'条件表达式'所对应的'SQL语句'，
						   若所有的'条件表达式'都不为true，则执行'else'所对应的语句(若有的话)；


			[开始标签名:] loop
			SQL语句
			...
			[leave 标签名]
			end loop [结束标签名]
				--> loop语句，用于存储程序中实现循环；
				--> 标签，即用于控制循环的标记点，可以主动使用SQL语句<iterate 标签名>来开启循环，<leave 标签名>来结束循环；
						 若声明了，则开始标签和结束标签之间为一次循环；
						 若声明了，则标签名最多16个字符；
						 若声明了，则必须有开始标签且之后必须跟上':'，结束标签可以没有(但有的话必须与开始标签同名)；
						 若声明了，则同级的开始标签(及结束标签)与开始标签(及结束标签)之间不能同名，不同级的(即嵌套的)可以同名；


			[开始标签名:] repeat
			SQL语句
			...
			until 条件表达式
			end repeat [结束标签名]
				--> repeat语句，用于存储程序中实现循环；
				--> until之后的'条件表达式'为true时，循环结束，这也意味着repeat语句中循环至少执行一次；


			[开始标签名:] while 条件表达式
			do SQL语句
			...
			end while [结束标签名]
				--> while语句，用于存储程序中实现循环；


			declare 条件名 condition for MySQL错误码 / sqlstate MySQL状态值
				--> 定义条件测试语句，将某种MySQL错误绑定至'条件名'，以便对应的'处理器'操作；
				--> MySQL错误码        声明，表示整形错误码；
					sqlstate ...      声明，MySQL状态值为包含5个字符的字符串；

			declare continue / exit handler for 条件名 / MySQL错误码 / sqlstate MySQL状态值 / not found / sqlwarning / sqlexception
			SQL语句
				--> 定义条件处理器语句，当某种MySQL错误码或...或'条件名'(条件测试语句中已定义的)发生时，执行当前处理器中的SQL语句；
				--> continue          声明，表示存储程序执行完当前处理器的SQL语句后继续向下执行；
					exit 			  声明，表示存储程序执行完当前处理器的SQL语句后直接终止最外层的begin...end复合声明；

	展示相关的操作(完)
	----------------------
		show binary/master logs
			--> 展示服务器二进制log文件，展示列(2列)包括：
				文件名 | 文件大小；
			--> binary 等价于 master ，二选其一；

		show character set [like '模板' / where 表达式]
			--> 展示字符集，展示列(4列)包括：
			    字符集名 | 字符集描述信息 | 默认排序规则 | 储存当前字符集中单个字符所需的最大字节数；
			--> like     声明，若提供'模板'可进行模糊查询，则展示与'模板'匹配的字符集；
			    where    声明，根据提供的条件，展示符合的一行或多行字符集；

		show collation [like '模板' / where 表达式]
			--> 展示排序规则，展示列(6列)包括：
				排序规则名 | 所属字符集 | 排序规则ID | 是否是所属字符集的默认排序规则 | 是否被编译进服务器 | 排序时所需内存数；
			--> like     声明，若提供'模板'可进行模糊查询，则展示与'模板'匹配的排序规则；
			    where    声明，根据提供的条件，展示符合的一行或多行排序规则；

		show [full] tables [from 数据库名] [like '模板' / where 表达式]
			--> 展示[指定数据库中]或默认数据库中的非临时表信息；
			--> full     声明，若提供full声明，则额外展示view(即视图)信息；

		show [full] columns from 表名 [from 数据库名] [like '模板' / where 表达式]
			--> 展示[指定数据库中]指定表的列信息，展示列(6列或9列)包括：
				列名 | 列类型 | [列排序规则] | 列值中是否有null | 列索引类型 | 列默认值 | 列额外信息 | [当前用户操作列的权限] | [列注释]
			--> full     声明，若提供full声明，则额外展示[...]部分内容；
				表名      声明，若表名为'数据库名.表名'形式，则无需再提供'from 数据库名'的声明；
				like     声明，若提供'模板'可进行模糊查询，则展示与'模板'匹配的列；
			    where    声明，根据提供的条件，展示符合的列；

		show variables
			--> 展示服务器(运行期间)的系统变量信息；

		show grants [for '用户名'@['用户主机名']]
			--> 展示指定账户被授予的权限(默认展示当前账户被授予的权限)；
				若省略'用户主机名'，则账户默认为'用户名'@'%'；

		show create database/table/view/event/function/trigger/procedure/user/ 名字
			--> 展示被创建内容的基本信息；

		show databases [like '模板' / where 表达式]
			--> 展示服务器上所有的数据库名；

		show engines
			--> 展示服务器的引擎状态信息；

		show events [from 数据库名] [like '模板' / where 表达式]
			--> 展示[指定数据库]/默认数据库中的事件信息；

		show indexes from 表名 [from 数据库名] [where 表达式]
			--> 展示[指定数据库]中指定表的索引信息；

		show triggers [from 表名] [like '模板' / where 表达式]
			--> 展示[指定表]或当前表中的触发器信息；

		show privileges
			--> 展示服务器支持的权限类型和相关内容；
		
		show processlist 
			--> 展示服务器正在运行的所有线程信息；

		show slave hosts
			--> 展示当前主服务器的所有从服务器信息，展示列(不定长)包括：
				从服务器的唯一ID | 从服务器的主机名 | [从服务器的用户名] | [从服务器的密码] | [主服务器的端口号] | 主服务器的ID | 从服务器的UUID；

	事务相关的操作(完)
	----------------------
		start transaction [with consistent snapshot / read write / read only];
		commit [work] [and [no] chain] [[no] release];
		rollback [work] [and [no] chain] [[no] release];
		set autocommit=0/1;
			--> start transaction	开启一个新的事务；
				begin 				start transaction的别名，也表示开启一个新的事务(但begin无法设置修饰关键字，因此更推荐前者)；
									与begin...end复合语句不同，复合语句不会开启一个新的事务，因此这种情况下想开启事务也推荐使用前者；
				commit 				提交当前的事务，使其持久化(即无法回滚)；
				rollback 			回滚当前的事务，使其无效化；
				work 				该关键字仅用于搭配 and [no] chain 或 [no] release 声明使用：
									and chain声明，表示在当前事务结束后立即开启一个新的事务(与当前事务的隔离等级和访问模式相同)，[no]声明表示显示取消开启一个新的事务；
									release  声明，表示当前事务结束后立即断开本次客户端会话，[no]声明表示显示取消立即断开的操作；
				set autocommit 		设置当前的会话是否自动commit(默认为1，即自动commit)；
			--> start transaction   声明，具有3个修饰关键字：
					with consistent snapshot	，仅适用于InnoDB，不改变当前的'隔离等级'，开始重复读，唯一允许重复读的'隔离等级'是repeatable read'；
					read write / read only 		，规定当前事务访问表的模式，read only将阻止当前事务进行修改操作，它会锁住所有其他事务可见的事务及非事务性的表；

		savepoint 节点名
		rollback [work] to [savepoint] 节点名
		release savepoint 节点名
			--> savepoint 			在当前事务中设置一个节点(若该节点名与之前的同名，则旧的删除，新的创建)；
				rollback to 		在不终止当前事务的情况下，回滚至上一个节点，这期间对表中行数据的修改将无效，但InnoDB并不会立即释放这些行数据的行级锁，而是等到新的插入行操作才会释放；
				release savepoint   删除当前事务中的节点(不会发生commit或rollback)；
			--> 'commit'或'rollback'操作会删除当前事务中的所有节点；
				'存储函数'或'触发器'创建的节点被视作特殊级别的节点，它们会让普通级别的节点暂时无效，等到'存储函数'或'触发器'执行完毕后，普通级别的节点才会恢复功能；

		set [global / session] transaction 配置1[, 配置2, ...]
			--> 设置事务的某些特性；
			--> global / session    声明，表示当前设置的适用范围；
			--> 配置				 声明，包括：isolation level repeatabble read / read committed / read uncommitted / serializable | read wirte | read only


	其他语法相关的操作
	----------------------
		do 表达式1 [, 表达式2, ...]
			--> 执行一个或多个表达式；do语法不返回任何结果，所以速度更快；


		* explain 和 describe 是语法同义词，MySQL解析器将二者视作相同；
		实在要说差异，describe语法更多用于展示库表结构信息，而explain语法更多用于展示语句的执行计划；
		describe/desc 表名 [列名/'模板']
			--> 展示指定表的所有(或指定)列信息，等价于show columns语法；

		explain [extended / partitions / format=traditional/json]
		SQL语句 / for connection 连接ID
			--> 展示指定连接或语句的执行计划，输出的结果列依次为：
					id列		
						->   即SQL语句的select序号，其值为整数；
					
					select_type列	
						->   即select的类型，其值为：
							SIMPLE				->  未使用UNION语法或子查询的简单select
							PRIMARY				->  最外层的select
							UNION 				->  UNION语法中非最外层的select
							DEPENDENT UNION		->  UNION语法中非最外层的select，但依赖于外层的查询
							UNION RESULT		->  UNION语法的结果
							SUBQUERY 			->  子查询中的首个select
							DEPENDENT SUBQUERY	->  子查询中的首个select，但依赖于外层的查询
							DERIVED 			->  FROM子句中的子查询衍生出的表格select
							MATERIALIZED		->  实际的子查询
							...
					
					table列 
						->   即输出行对应的表名，其值为：
							<unionM,N>	
							<derivedN> 
							<subqueryN> 
					
					partitions列

					type列
						->   即SQL语句的关联类型，其值按对应的查询性能排，由高到低依次为：
							system				->  关联中，每张表都只需要查询一行数据(即系统内置表的查询)；
							const 				->  关联中，每张表都最多需要查询一行数据(即主键索引为常量的查询)；
							eq_ref				->  关联中，前一张表让本表只需要查询一行数据(即只包含唯一索引(含主键索引)或唯一索引为常量的查询)； 
							ref 				->  关联中，前一张表让本表只需要查询索引(即只包含普通索引或普通索引为常量的查询)；
							fulltext			->  关联中，使用全文索引(即只包含全文索引的查询)； 
							ref_or_null			->  关联中，前一张表让本表只需要查询索引(即只包含普通索引或普通索引为常量，但索引列的值可以为null的查询)；
							index_merge			->  关联中，对索引列的合并查询； 
							unique_subquery		->  关联中，子查询结果集为主键索引的in查询(即... in (select 主键索引列 from ...)；
							index_subquery		->  关联中，子查询结果集为普通索引的in查询(即... in (select 普通索引列 from ...)； 
							range 				->  关联中，对索引列的范围查询(即'索引列=常量'或'索引列 between M adn N'或'索引列 in (M, N, ...)'或上述的结合)；
							index 				->  关联中，对索引列的查询(即Extra列显示Using index)； 
							all 				->  关联中，对全表扫描的查询；

					possible_keys列
						->   即SQL语句执行过程中可能用到的索引，其值可以为null(表示并未使用任何索引)； 
					
					key列 
						->   即SQL语句执行过程中实际用到的索引；

					key_len列
						->   即SQL语句执行过程中实际用到的索引的字节长度；

					ref列 
						->   即SQL语句执行过程中使用哪些列或常量与索引进行对比；

					rows列
						->   即预估SQL语句执行需要检索的总数据行数；
					
					filtered列
						->   即预估SQL语句执行会被过滤的总数据行数；

					Extra列
						->   即反映SQL语句执行的额外信息，其重点值为；
							Using filesort
								->  表示SQL语句执行时将数据行进行了排序；
							Using index
								->  表示SQL语句执行时仅使用索引就获取了数据，而并未读取整个数据行；
							Using index for group-by
								->  表示SQL语句执行时仅使用索引就执行了group by或distinct操作，而并未读取整个数据行；
							Using where	
								->  表示SQL语句执行时通过条件过滤获取了数据(最为常见的查询)；
							Not exists 
								->  表示SQL语句执行left join时发现第二张表不匹配任何行；
							Distinct 		
								->  表示SQL语句执行时找到第一个匹配的数据行后就停止查询；
							Impossible HAVING	
								->  表示SQL语句中的having子句无法匹配任何数据行；
							Impossible WHERE	
								->  表示SQL语句中的where子句无法匹配任何数据行；
							Scanned N databases
								->  表示SQL语句执行时查询了N个数据库；
			--> format      声明，指定展示内容的格式是传统的表格形式(默认)，还是JSON格式；
				SQL语句      声明，包括select语句、delete语句、insert语句、update语句和replace语句等；


		call 存储过程名([参数1, 参数2, ...])
			--> 调用一个存储过程；


		set 变量关系式1[, 变量关系式2, ...]
			--> 将值绑定到变量；
			--> 变量关系式有多种形式，具体如下('='和':='都可以作为连接符)：
					@用户变量名=表达式
					参数名=表达式
					local 局部变量名=表达式 / @@local.局部变量名=表达式
					global 全局变量名=表达式 / @@global.全局变量名=表达式
					session 会话变量名=表达式 / @@session.会话变量名=表达式

		set character set 字符集名
			--> 将character_set_client和character_set_results的值修改为'字符集名'，character_set_connection修改为character_set_database的值；
				* character_set_client ，即客户端数据进入服务端之前，服务端统一将它们视作'该变量类型字符集'的数据;
				* character_set_connection ，即客户端数据进入服务端之后，服务端统一将它们转换成'该变量类型字符集'的数据，以便后续的内部处理；
				` character_set_results ，即客户端数据被返回之前，服务端统一将它们转换成'该变量类型字符集'的数据；
				
				* character_set_database ，即该变量的值就是'默认数据库的字符集'，并随其动态更新；
				* character_set_server ，即该变量的值就是未确定默认数据库之前客户端数据采用的字符集；
				* 以上变量默认值均为'utf8mb4'


MySQL与Python的交互
=============================================
	1) Connector/Python
		# pip3 install mysql-connector-python-rf
		import mysql.connector 

		mysql.connector.connect(.../**kwargs)
			--> ctype: cnx,即连接至对应服务器的'连接对象'；
			--> .../**kwargs ,即服务器的连接配置(可以通过关键字参数,也可以是字典形式)
					host='127.0.0.1'						->  指定MySQL服务器的IP地址
					port=3306										->  指定MySQL服务器的端口号
					user='...'									->  指定用于连接验证的用户名
					password='...'							->  指定用于连接验证的密码
					ssl_ca='...'								->  指定CA证书的保存路径
					ssl_cert='...'							->  指定SSL的证书的保存路径
					ssl_key='...'								->  指定SSL的密钥的保存路径
					ssl_verify_cert=False				->  指定是否用CA证书去验证SSL的证书
					connection_timeout=...			->  指定连接的超时时间

					pool_name='...'							->  隐式指定连接池的名字(长度不超过pooling.CNX_POOL_MAXNAMESIZE[默认为64])
					pool_size=5									->  隐式指定连接池的大小(大小不超过pooling.CNX_POOL_MAXSIZE[默认为32])
					autocommit=False 						->  指定是否自动提交事务
					allow_local_infile=True			->  指定是否允许'Load data local infile'语句
					charset='utf8'							->  指定服务器使用的字符编码
					collation='utf8_general_ci'	->  指定服务器使用的排序规则

				cnx.cmd_statistics()
					--> ctype: dict,即以字典形式返回MySQL服务器的运行时间、运行线程数、打开表数等等信息；

				cnx.config(**kwargs)
					--> ctype: none,即更改连接的配置项，通常搭配.reconnect()一同使用；

				cnx.reconnect([attempts=1, delay=0])
					--> ctype: none,即重新连接；
					--> attempts ,即重新连接失败时,最多尝试多少次；
					--> delay ,即重新连接失败时,间隔多少秒后再尝试；

				cnx.close()
					--> ctype: none,即关闭cnx连接(若该连接来自连接池,则不会真的关闭它而是放回连接池)；
				
				cnx.commit()
					--> ctype: none,即提交当前事务(默认不会自动提交)；
				
				cnx.rollback()
					--> ctype: none,即回滚当前事务(因为默认不会自动提交,所以允许回滚)；
				
				cnx.cmd_change_user(username='...', password='...', database='...')
					--> ctype: dict,即更改连接的用户和数据库；
				
				cnx.cmd_init_db('...')
					--> ctype: none,即指定默认数据库；
				
				cnx.start_transaction(consistent_snapshot=bool, isolation_level=level, readonly=access_mode)
					--> ctype: none,即开启一个事务；

				cnx.cursor([arg=value[, arg=value[, ...]]])
					--> ctype: cur,即返回一个MySQLCursor()对象,该对象中可以封装操作的结果,本身是iterable；
					--> name_tuple=True, 即指定每一行结果数据都以'命名元组'的形式返回；
							dictionary=True, 即指定每一行结果数据都以'字典'的形式返回；
							raw=True, 即指定每一行结果数据都以'原始格式'返回；
							buffered=True, 即指定cursor对象在操作执行后立即获取所有结果；

						cur.callproc(proc_name, args)
							--> ctype: new_args,即将args实际参数传入proc_name存储过程执行,然后将args实际参数的更新值返回；
											所谓更新,即in类型参数的值原封不动,out/inout类型参数为存储过程执行后的值；
							--> proc_name ,即字符串形式的存储过程名；
							--> args ,即序列形式的参数(对应存储过程定义的先后顺序)
											  out类型的参数可以用0来占位； 
												out类型的参数可以额外执行结果类型,例如: (xx, xx, 0) -> (xx, xx, (0, 'char')) 指定原本用0占位的out类型参数在结果中以char类型的形式出现；

						cur.stored_results()
							--> ctype: iterator,即以迭代器形式返回cur对象执行存储过程后的结果值；这些结果直到cur对象执行其他操作或存储过程后才会失效；

						cur.execute(operation, params=None)
							--> 执行operation操作；
							--> operation ,即待执行的操作,可以使用占位符
										若操作代码有多行,则每行都必须用""括起来；
										若占位符形如%s,则实际参数对应元组,形如%(key)s,则实际参数对应字典；
							--> params ,即传入operation中的实际参数,可以是元组或字典；

						cur.executemany(operation, seq_params)
							--> 将seq_params解包,每组参数放入operation中执行一遍；
								  注意: 该方法不能执行'多个操作'；

						cur.fetchone()
							--> ctype: row_data,即获取cur中的下一行结果数据；
						
						cur.fetchmany(size=1)
							--> ctype: list,即获取cur中的下size行结果数据(每行数据以元组形式返回)；

						cur.fetchall()
							--> ctype: list,即获取cur中的所有(剩余)行结果数据(每行数据以元组形式返回)；
						
						cur.close()
							--> ctype: none,即关闭cursor对象,重置结果数据并确保没有对原连接的引用；

		# 连接池的特点
			1) 一个连接池预先打开了多个连接,可以线程安全的处理即将到来的请求；
			2) 一个连接池的大小在创建时指定,一旦创建就无法更改；
			3) 一个连接池的名字在创建时指定,若未指定则根据连接参数自动生成；
			4) 一个连接池只是单纯的提供下一个连接给即将到来的请求,没有用到轮循或其他算法；
			5) 来自连接池的连接在调用.close()方法后会返回至连接池而不是消亡,也无法调用.config()方法更新配置；
		mysql.connector.pooling.MySQLConnectionPool(...)
			--> ctype: cnxpool,即显式创建连接池；
			--> pool_name=None, 即指定连接池的名字(若未指定,则根据host、post、user、database等连接参数自动生成)； 
			--> pool_size=5, 即指定连接池的大小；
			--> pool_reset_session=True, 即当连接返回连接池时是否重置会话变量；
			--> kwargs ,即同.connector(...)方法； 

				cnxpool.pool_name
					--> ctype: str,即返回cnxpool连接池的名字(只读属性)；

				cnxpool.add_connection(cnx=None)
					--> ctype: none/PoolError,即向cnxpool连接池中添加一个新连接或指定的连接；
						  若cnxpool连接池已满,则raise PoolError；
						
				cnxpool.get_connection()
					--> ctype: cnx/PoolError,即从cnxpool连接池中获取一个连接；
							若cnxpool连接池已空,则raise PoolError；
					
				cnxpool.set_config(**kwargs)
					--> ctype: none,即更改连接池的配置(对未分配的和后续返回的连接有效)；
				
	2) PyMySQL
	import pymysql.connections as pc （同时也导入了pymysql包中cursors.py文档中的Cursor类）

	pc.Connection(各种参数) --> return 实例对象 --> 即创建Connection类的实例对象
	                 |--> host='xx' --> 即数据库的主机（如果是本地，则为localhost；如果是其他，则为指定的IP值）
	                 |--> port=3306 --> 即数据库主机的端口
	                 |--> user='xx' --> 即用户名（如果是本地，则为root；如果是其他，则为指定的用户名）
	                 |--> passwd='xx' --> 即数据库的密码（参数名也可以写成password）
	                 |--> db='xx' --> 即要连接哪个数据库（参数名也可以写成database，也可以不写）
	                 |--> charset='utf8' --> 即使用的字符集
					 |
					 |--> 全部的参数有：host=None, user=None, password="",
					                  database=None, port=0, unix_socket=None,
					                  charset='', sql_mode=None,
					                  read_default_file=None, conv=None, use_unicode=None,
					                  client_flag=0, cursorclass=Cursor, init_command=None,
					                  connect_timeout=10, ssl=None, read_default_group=None,
					                  compress=None, named_pipe=None, no_delay=None,
					                  autocommit=False, db=None, passwd=None, local_infile=False,
					                  max_allowed_packet=16*1024*1024, defer_connect=False,
					                  auth_plugin_map={}, read_timeout=None, write_timeout=None,
					                  bind_address=None, binary_prefix=False

	Connections对象.close() --> return None --> 即关闭数据库的连接
	Connections对象.cursor() --> return 实例对象 --> 即创建Cursor类的实例对象
												  （同时将Connection对象作为参数传入了Cursor类的__init__方法中）

	Cursor对象.close() --> return None --> 即关闭游标
	Cursor对象.execute(sql语句[,语句涉及的参数]) --> return sql语句的返回值 --> 执行一条sql语句
	Cursor对象.executemany(sql语句[,语句涉及的参数]) --> return sql语句生效的数量 --> 执行多条insert或update的sql语句

	Cursor对象.fetchone() --> return sql语句结果的第一行
	Cursor对象.fetchmany(size=xx) --> return sql语句结果的xx行
	Cursor对象.fetchall() --> return sql语句结果的所有

"""