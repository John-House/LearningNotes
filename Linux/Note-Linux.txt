Linux系统的基础概念
===============================================
	Linux中'一切皆文件'
		1) Linux没有'文件扩展名'的概念,文件的内容和用途由其它方式决定；
		2) Linux支持长文件名,即文件名中允许包含'标点符号'(仅支持'.'和'－'和'_'),以及'空格'(强烈建议不要使用'空格',哪怕用'_'代替)；
		3) Linux中文件名是大小写敏感的；
		4) Linux中隐藏文件以'.'开头命名；

	Linux中常见的目录:
		/				根目录,万物起源。
		/bin			包含系统启动和运行所必须的二进制程序。
		/boot			包含Linux内核、初始RAM磁盘映像(用于启动时所需的驱动)和启动加载程序。
						有趣的文件:
						/boot/grub/grub.conf或menu.lst,被用于配置启动加载程序。
						/boot/vmlinuz,Linux内核。
		/dev			这是一个包含设备结点的特殊目录。'一切都是文件',也适用于设备。 
						在这个目录里,内核维护着所有设备的列表。
		/etc			这个目录包含所有系统层面的配置文件。它也包含一系列的shell脚本,在系统启动时,这些脚本会开启每个系统服务。
						这个目录中的任何文件应该是可读的文本文件。
						有趣的文件:虽然/etc目录中的任何文件都有趣,但这里只列出了一些我一直喜欢的文件:
						/etc/crontab  包含计划任务脚本。
						/etc/fstab    包含存储设备的列表,以及与他们相关的挂载点。
						/etc/passwd   包含用户帐号列表。
		/root			root帐户的家目录。
		/home			在通常的配置环境下,系统会在/home下,给每个用户分配一个目录。普通用户只能在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。
		/lib			包含核心系统程序所使用的共享库文件。这些文件与Windows中的动态链接库相似。
		/lost+found		每个使用Linux文件系统的格式化分区或设备,例如,ext3文件系统,都会有这个目录。
						当部分恢复一个损坏的文件系统时,会用到这个目录。这个目录应该是空的,除非文件系统 真正的损坏了。
		/media			在现在的Linux系统中,/media目录会包含可移动介质的挂载点,例如:USB驱动器,CD-ROMs等等。
						这些介质连接到计算机之后,会自动地挂载到这个目录结点下。
		/mnt			在早些的Linux系统中,/mnt目录包含可移动介质的挂载点。
		/opt			这个/opt目录被用来安装'可选的'软件。这个主要用来存储可能安装在系统中的商业软件产品。
		/proc			这个/proc目录很特殊。从存储在硬盘上的文件的意义上说,它不是真正的文件系统。 
						相反,它是一个由Linux内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的,它们会告诉你内核是怎样监管计算机的。
		/sbin			这个目录包含'系统'二进制文件。它们是完成重大系统任务的程序,通常为超级用户保留。
		/tmp			这个/tmp目录,是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次重新启动时,都会清空这个目录。
		/usr			在Linux系统中,/usr目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。
		/usr/bin		/usr/bin目录包含系统安装的可执行程序。通常,这个目录会包含许多程序。
		/usr/lib		包含由/usr/bin目录中的程序所用的共享库。
		/usr/local		这个/usr/local目录,是非系统发行版自带程序的安装目录。通常,由源码编译的程序会安装在/usr/local/bin目录下。
						新安装的Linux系统中会存在这个目录,并且在管理员安装程序之前,这个目录是空的。
		/usr/sbin		包含许多系统管理程序。
		/usr/share		/usr/share目录包含许多由/usr/bin目录中的程序使用的共享数据。其中包括像默认的配置文件、图标、桌面背景、音频文件等等。
						例如:/usr/share/dict目录下可能找到字典文件,其内容是一份很长的单词列表(每行一个单词,按照字母顺序排列)。
		/usr/share/doc	大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc目录下,我们可以找到按照软件包分类的文档。
		/var			除了/tmp和/home目录之外,相对来说,目前我们看到的目录是静态的,它们的内容不会改变。
						/var目录存放的是动态文件。各种数据库,假脱机文件,用户邮件等等,都位于在这里。
		/var/log		这个/var/log目录包含日志文件、各种系统活动的记录。这些文件非常重要,并且应该时时监测它们。
						其中最重要的一个文件是/var/log/messages。注意:为了系统安全,在一些系统中你必须是超级用户才能查看这些日志文件。
	
	Linux中的组合键:
		clear		清空当前屏幕的内容。
		history 	显示命令的历史记录。

		Ctrl-a		移动光标到行首。
		Ctrl-e		移动光标到行尾。
		
		Ctrl-u		剪切从光标位置到行首的文本。
		Ctrl-k		剪切从光标位置到行尾的文本。
		Ctrl-y		把剪切环中的文本粘贴到光标位置。

		Alt-d		剪切从光标位置到词尾的文本。
		Alt-Backspace	剪切从光标位置到词头的文本。如果光标在一个单词的开头,剪切前一个单词。
		
		Tab			当你敲入一个命令时,按下tab键,自动补全就会发生
		
	Linux的软件包管理
		Linux发行版本质量最重要的决定因素是'软件包管理系统'和'其支持社区的持久性'。

		软件包管理是指系统中一种'安装和维护软件'的方法。大多数的Linux发行版使用两大包管理技术阵营:Debian的'.deb'和红帽的'.rpm':
			包管理系统					  发行版 (部分列表)
			Debian Style (.deb)			Debian, Ubuntu, Xandros, Linspire
			Red Hat Style (.rpm)		Fedora, CentOS, Red Hat Enterprise Linux, OpenSUSE, Mandriva, PCLinuxOS

		在软件包管理系统中,软件的基本单元是包文件。包文件是一个构成软件包的文件压缩集合。一个软件包可能由大量程序以及支持这些程序的数据文件组成。
		除了安装文件之外,软件包文件也包括关于这个包的元数据,如软件包及其内容的文本说明。另外,许多软件包还包括预安装和安装后脚本,这些脚本用来在软件安装之前和之后执行配置任务。

		程序很少独立工作,它们需要依靠其他程序的组件来完成工作。例如,程序所共有的活动——输入/输出,就是由一个被多个程序调用的子例程处理的,这些子例程存储在动态链接库中。
		动态链接库为多个程序提供基本服务。如果一个软件包需要一些共享的资源,如一个动态链接库,它就被称作有一个依赖。
		现代的软件包管理系统都提供了一些依赖项解析方法,以确保安装软件包时,其所有的依赖也被安装。

		软件包管理系统通常由两种工具类型组成:底层工具(用来处理安装和删除软件包文件等)和上层工具(用来完成元数据搜索和依赖解析)。常见的包管理工具有:
			发行版								 		 底层工具	  上层工具
			Debian-Style								dpkg		apt-get, aptitude
			Fedora, Red Hat Enterprise Linux, CentOS 	rpm			yum

			查找'资源库'中的软件包
				yum search 软件包名
				apt-get update;apt-cache search 软件包名

			安装'资源库'中的软件包
				yum install 软件包名
				apt-get update;apt-get install 软件包名

			通过'软件包源文件'安装
				rpm -i 软件包源文件名
				dpkg --install 软件包源文件名

			卸载软件包
				yum erase 软件包名
				apt-get remove 软件包名

			更新'资源库'中的软件包
				yum update
				apt-get update;apt-get upgrade

			通过'软件包源文件'更新
				rpm -U 软件包源文件名
				dpkg --install 软件包源文件名

			显示安装的所有软件包
				rpm -qa
				dpkg --list

			显示是否安装某个软件包
				rpm -q 软件包名
				dpkg --status 软件包名

			显示某个软件包的详情
				yum info 软件包名
				apt-cache show 软件包名

			显示某个文件所属的软件包
				rpm -qf 文件名
				dpkg --search 文件名

			yum [...] [子命令]
				--> 使用上层工具yum执行各种操作(yum,即Yellowdog Update Modifier的缩写,该工具的配置文件位于/etc/yum.conf)；
				--> [-q]选项,即安静模式,不显示操作的过程信息；
					[-y]选项,即对后续的操作提示全部选yes；
					[--assumeno]选项,即对后续的操作提示全部选no；
					[--installroot=路径名]选项,即指定'install'子命令的根路径；
				
				--> [check-update],即检查后显示所有可更新的软件包；
					[update [软件包名]],即升级[指定的]软件包；
					[upgrade [软件包名]],即升级[指定的软件包,包括过时的软件包；
					
					[search 字符串],即搜索与'字符串'相关的软件包；
					[deplist 软件包名],即列出'软件包'的依赖；
					[install 软件包名],即安装'软件包'；
					[reinstall 软件包名],即重装'软件包'；
					[erase 软件包名],即卸载'软件包'；
					
					[list [updates/installed]],即显示所有可安装[可更新/已安装]的软件包；
					
					[info [软件包名/updates/installed]],即显示所有软件包[指定软件包/可更新软件名/已安装软件包]的详细信息；
					[provides 软件包名],即显示'软件包'提供的文件信息；
					
					[clean [packages/headers/oldheaders]],即清除缓存目录(即/var/cache/yum目录)下所有的数据[软件包/headers/过时的headers]；
					
					[downgrade],即回滚一个包；
					
	编译程序
		为什么要编译软件？
		1) 可用性。尽管系统发行版仓库中已经包含了大量的预编译程序,但是一些发行版本不可能包含所有期望的应用。在这种情况下,得到所期望程序的唯一方式是编译程序源码。
		2) 及时性。虽然一些系统发行版专门打包前沿版本的应用程序,但是很多不是。这意味着,为了拥有一个最新版本的程序,编译是必需的。

		编译就是把源码(一个由程序员编写的人类可读的程序的说明)翻译成计算机处理器的语言的过程。
		
		计算机处理器(或CPU)工作在一个非常基本的水平,执行用机器语言编写的程序。这是一种数值编码,描述非常小的操作,比如"加这个字节"、"指向内存中的这个位置"或者"复制这个字节"。
		这些指令中的每一条都是用二进制表示的(1和0)。最早的计算机程序就是用这种数值编码写成的,这可能就解释了为什么编写它们的程序员据说吸很多烟,喝大量咖啡并带着厚厚的眼镜。
		随着汇编语言的出现,这个问题得到克服。汇编语言使用诸如CPY(复制)和 MOV(移动)之类(略微)易用的字符助记符代替了数值编码。用汇编语言编写的程序通过汇编器处理为机器语言。
		
		虽然有许多流行的编程语言,两个占主导地位。大多数为现代系统编写的程序,要么用C编写,要么是用C++编写。 
		用高级语言编写的程序,经过另一个称为编译器的程序的处理,会转换成机器语言。一些编译器把高级指令翻译成汇编语言,然后使用一个汇编器完成翻译成机器语言的最后阶段。

		一个称为链接的过程经常与编译结合在一起。有许多常见的由程序执行的任务。以打开文件为例。许多程序执行这个任务,但是让每个程序实现它自己的打开文件功能,是很浪费资源的。
		更好的办法是,拥有单独的一段知道如何打开文件的程序,并允许所有需要它的程序共享它。对常见任务提供支持由所谓的库完成。这些库包含多个程序,每个程序执行一些可以由多个程序共享的常见任务。
		如果我们看一下/lib和/usr/lib目录,我们可以看到许多库定居在那里。一个叫做链接器的程序用来在编译器的输出结果和要编译的程序所需的库之间建立连接。这个过程的最终结果是一个可执行程序文件,准备使用。

		所有的程序都是可编译的吗？
		不是。正如我们所看到的,有些程序比如shell脚本就不需要编译。它们直接执行。这些程序是用所谓的脚本或解释型语言编写的。近年来,这些语言变得越来越流行,包括Perl、Python、PHP、Ruby和许多其它语言。
		脚本语言由一个叫做解释器的特殊程序执行。一个解释器输入程序文件,读取并执行程序中包含的每一条指令。通常来说,解释型程序执行起来要比编译程序慢很多。
		这是因为每次解释型程序执行时,程序中每一条源码指令都需要翻译,而一个已经编译好的程序,一条源码指令只翻译了一次,翻译后的指令会永久地记录到最终的执行文件中。

		那么为什么解释型程序这样流行呢？对于许多编程任务来说,原因是"足够快",但是真正的优势是:一般来说,开发解释型程序要比编译程序快速且容易。通常程序开发需要经历一个不断重复的写码、编译和测试周期。
		随着程序变得越来越大,编译阶段会变得相当耗时。解释型语言删除了编译步骤,这样就加快了程序开发。

		让我们编译一些东西。在我们编译之前,然而我们需要一些工具,像编译器、链接器以及make。 
		在Linux环境中,普遍使用的C编译器叫做gcc(即GNU C编译器),最初由Richard Stallman写出来的。
		大多数Linux系统发行版默认不安装gcc。我们可以这样查看该编译器是否存在:
			[me@linuxbox ~]$ which gcc
			/usr/bin/gcc
		通常提供的源码形式是一个压缩的tar文件。有时候称为tarball,这个文件包含源码树或者是组成源码的目录和文件的层次结构。

Shell编程
===============================================
	shell的基础概念
		1) shell是一种解释器,它接收输入的命令并将其传递给操作系统执行,然后返回执行结果；
		   从命令行接收命令的方式称为'交互式shell',从文件接收命令的方式称为'非交互式shell'；
		
		2) shell分为两大类:
		       Bourne Shell,细分为:Bourne shell(即sh)、Korn shell(即ksh)和Bourne again shell(即bash)>
			   C Shell,细分为csh和tcsh；
		   Linux系统默认的shell是bash；Solaris和FreeBSD系统默认的是sh；AIX系统默认的ksh；
		   用户可以通过环境变量SHELL来获取当前系统默认的shell是什么；

		3) shell编程主要是编写命令或脚本文件,shell的命令分为四类:
		       a) 可执行命令
				  可以是用诸如C和C++语言写成的程序'编译好的二进制文件',也可以是由诸如shell,perl,python,ruby等等'脚本语言写好的脚本文件'。
			   b) 内建shell命令
				  bash支持若干命令,内部叫做shell内部命令(builtins)。例如,cd 命令,就是一个shell内部命令。
			   c) shell函数
				  这些是小规模的shell脚本,它们混合到环境变量中。
			   d) 别名命令
				  我们可以定义自己的命令,建立在其它命令之上。
		   在终端,如果想一次性输入并执行多个命令,可以用';'分隔它们,例如:cd /usr; ls -a; cd -

	shell的命令详解
		1) 用户和用户组管理
			在Unix安全模型中,一个用户可能拥有文件和目录。
			当一个用户拥有一个文件或目录时,用户对这个文件或目录的访问权限拥有控制权；
			反过来,用户又属于一个由一个或多个用户组成的用户组,用户组成员由文件和目录的所有者授予对文件和目录的访问权限。
			除了对一个用户组授予权限之外,文件所有者可能会给每个人一些权限。

			那么这些信息来源于哪里呢？像Linux系统中的许多东西一样,来自一系列的文本文件:
			/etc/passwd文件中储存了'用户信息',/etc/shadow文件中储存了'用户密码信息',/etc/group文件中储存了'用户组信息'
				/etc/passwd文件内容格式详解:
					形如,用户名:用户密码:用户ID:用户组ID:用户简介:用户家目录:用户使用的shell程序
					实例,root:x:0:0:root:/root:/bin/bash
					注意,1) 用户密码,默认为'x',表示具体数据储存在/etc/shadow文件中
						 2) 用户ID,通常0~499为系统账户ID,500~65535为可配置账户(可配置区间因操作系统而异)
						 3) 用户使用的shell程序,如果为'/sbin/nologin/',表示默认无登录环境
				
				/etc/shadow文件内容格式详解:
					形如,用户名:加密密码:最近一次修改密码天数:至少几天后允许修改密码:至多几天后必须修改密码:密码过期预警天数:密码过期宽容天数:密码过期天数:保留字段
					实例,root:$6$PDbWAEITDxjjwFCQ$xnG8ZWS1tpbBkb//mxgqCcryO25NLXVs4wQjjJ6Qiz6LmAsefaOt7C/XtLm7Pc4zwZpFLpVF7KIg4rDF/6Rpo.::0:99999:7:::
					注意,1) 无对应设置要求,其值可以为空
						 2) 最近一次修改密码的天数,从1970年1月1日开始算起
						 3) 密码过期预警天数,在密码过期前多少天提示用户密码即将过期
						 4) 密码过期宽容天数,在密码过期后账户仍可使用多少天
						 5) 密码过期的天数,从1970年1月1日开始算起
						 6) 保留字段,默认为空
			
			在不同的时候,我们会发现很有必要具有另一个用户的身份。
			经常地,我们想要得到超级用户特权来执行一些管理任务,但是也有可能'变为'另一个普通用户,比如说测试一个帐号。
			有三种方式,可以拥有多重身份:
				1) 注销系统并以其他用户身份重新登录系统。
				2) 使用 su 命令。
				3) 使用 sudo 命令。
			
			在我们自己的shell会话中,
			su命令允许你假定为另一个用户的身份,以这个用户的ID启动一个新的shell会话,或者是以这个用户的身份来发布一个命令。
			sudo命令允许一个管理员设置一个叫做/etc/sudoers的配置文件并且定义了一些具体命令,在假定的身份下特殊用户可以执行这些命令。
			
			su [-l] [用户名]
				--> 使用'指定的用户名'来启动shell程序(即加载对应用户的shell环境,并将当前工作目录更改为对应用户的'家目录');
				--> [-l]选项,即如果省略,则默认为使用'超级用户'来启动shell程序;
		
			管理员能够配置sudo命令,从而允许一个普通用户以不同的身份(通常是超级用户),通过一种非常可控的方式来执行命令。 
			另一个重要差异是sudo命令不要求超级用户的密码。使用sudo命令时,用户使用他/她自己的密码来认证。
			su和sudo之间的一个重要区别是sudo不会重新启动一个shell,也不会加载另一个用户的shell运行环境。
			
			uname [...]
				--> 显示当前系统的'操作系统名'；
				--> [-a]选项,即显示当前系统的所有相关信息(内核版本、硬件架构、主机名和操作系统等)； 
					
					[-s]选项,即显示当前系统的'操作系统名',例如:Darwin、Linux；
					[-r]选项,即显示当前系统的'操作系统发行编号'；
					[-m]选项,即显示当前系统的'电脑类型',例如:x86_64(64位)、x86(32位)；
					
					[-n]选项,即显示当前系统的'主机名'；
					
					[-p]选项,即显示当前系统的'处理器类型'/unknown；
					[-i]选项,即显示当前系统的'硬件平台'/unknown；
					
			id [用户名]
				--> 显示当前用户的ID方面的信息
				--> [用户名]选项,即显示'用户'的ID方面的信息
				实例,[root@localhost ~]# id
					uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)
				说明,当前用户root的UID为0,GID为0,在root组的GID是0,在bin组的GID是1,在daemon组的GID是2,
					在sys组的GID是3,在adm组的GID是4,在disk组的GID是6,在wheel组的GID是10

			groups [用户名]
				--> 显示当前用户所属的工作组列表
				--> [用户名]选项,即显示'用户'所属的工作组列表

			logname 
				--> 显示当前用户的用户名

			chsh [...] [用户名]
				--> 手动输入当前用户的新shell程序
				--> [-l]选项,即显示当前用户可用的所有shell程序
					[-s shell路径]选项,即更改当前用户的shell程序
				注意,echo $SHELL可以查看当前的shell程序

			useradd [...] 用户名
				--> 新建用户
				--> [-u 用户ID]选项,即设置'用户ID'
					[-g 用户组ID]选项,即设置'用户组ID'
					[-c 用户简介]选项,即设置'用户简介'
					[-d 家目录]选项,即设置'用户家目录'
					[-s shell路径]选项,即设置'用户使用的shell程序'

					[-e 天数]选项,即设置'用户过期天数'
					[-f 天数]选项,即设置'密码过期宽容天数'

					[-r]选项,即创建系统账户

			usermod [...] 用户名
				--> 修改'用户'的相关信息
				--> [-l 新用户名]选项,即为'用户'设置'新用户名'
					[-u 新用户ID]选项,即为'用户'设置'新用户ID'
					[-g 新用户组ID]选项,即为'用户'设置'新用户组ID'
					[-c 新用户简介]选项,即为'用户'设置'新用户简介'
					[-d 新家目录]选项,即为'用户'设置'新用户家目录'
					[-s 新shell路径]选项,即为'用户'设置'新用户使用的shell程序'

					[-e 新天数]选项,即为'用户'设置'新用户过期天数'
					[-f 新天数]选项,即为'用户'设置'新密码过期宽容天数'

					[-L]选项,即锁定'用户'
					[-U]选项,即解锁'用户'

			userdel [...] 用户名
				--> 删除用户
				--> [-r]选项,即删除'用户'及其相关的所有文件
					[-f]选项,即强制删除'用户'(即使它处于已登录状态)

			passwd [...] [用户名]
				--> 新建或修改当前用户的密码(passwd命令会强迫你使用'强密码',即拒绝太短、太简单或与之前太相似的密码)
				--> [-d]选项,即具有超级用户权限后,删除当前用户的密码
					[-l]选项,即锁定当前用户的密码(无法被修改)
					[-u]选项,即解锁当前用户的密码
				--> [用户名]选项,即具有超级用户权限后,你可以指定'用户名'作为参数,修改该用户的密码
			
			chage [...] 用户名
				--> 修改'用户'的密码配置
				--> [-l]选项,即显示'用户'的密码配置信息
					
					[-d 天数]选项,即修改'用户'的'最后一次修改密码天数'
					[-m 天数]选项,即修改'用户'的'至少几天后允许修改密码'
					[-M 天数]选项,即修改'用户'的'至多几天后必须修改密码'
					[-w 天数]选项,即修改'用户'的'密码过期预警天数'
					[-i 天数]选项,即修改'用户'的'密码过期宽容天数'
					[-E 天数]选项,即修改'用户'的'密码过期天数'

			groupadd [...] 用户组名
				--> 创建用户组
				--> [-g 用户组ID]选项,即设置新用户组的ID
					[-r]选项,即创建系统工作组(通常系统工作组的ID小于500)

			groupmod [...] 用户组名
				--> 修改'用户组'信息
				--> [-n 新用户组名]选项,即为'用户组'设置新的用户组名
					[-g 新用户组ID]选项,即为'用户组'设置新的用户组ID

			groupdel 用户组名
				--> 删除用户组

		2) 其他命令
			man 命令名
				--> 浏览'命令'的手册内容；

			type 命令名
				--> 显示命令所属的类型(因此,也常用于检测'自定义命令名'是否与'已有命令名'冲突),结果通常是:
					... is a shell builtins
					... is aliased to ...
					... is /bin/...

			echo [-e] 变量/字符串/..
				--> 将内容显示到标准输出
				--> [-e]选项,即激活转义字符,让以下转义字符生效(默认会将它们视作普通字符输出):
						字符	 含义
						\a 		发出警告声；
						\b 		删除前一个字符；
						\c 		最后不加上换行符号；
						\f 		换行但光标仍旧停留在原来的位置；
						\n 		换行且光标移至行首；
						\r 		光标移至行首,但不换行；
						\t 		插入tab；
						\v 		与\f相同；
						\\ 		插入\字符；
						\nnn 	插入nnn(八进制)所代表的ASCII字符；

			which 可执行命令
				--> 显示'可执行命令'的路径信息

			alias 命令别名='一个或多个命令'
				--> 为对应的命令起别名(如果在终端中执行该操作,命令别名的作用域仅限于当前会话)

			unalias 命令别名
				--> 删除一个命令别名

			pwd
				--> 显示当前工作目录

			cd [路径名]
				--> 将当前工作目录更改为'家目录'
				--> [路径名]选项,即将当前工作目录更改为'路径名'(可以是绝对路径,也可以是相对路径)
			
				cd ~[用户名]
					--> 将当前工作目录更改为'当前用户的家目录'
					--> [用户名]选项,即将当前工作目录更改为'指定用户的家目录'
				
				cd -
					--> 将当前工作目录更改为变量'OLDPWD'对应的目录(即上个工作目录)

			read [...] [变量1 变量...]
				--> 从标准输入读取'单行'数据(默认使用'换行符'界定分隔数据),并赋值给shell变量'REPLY';
					read命令被用来从标准输入读取单行数据,这个命令可以用来读取键盘输入(当使用重定向的时候,则读取文件中的一行数据)
				--> [...]选项,即具体如下: 
						选项		说明
						-a 数组名	将输入数据赋值给'数组名'数组(从索引0开始)。
						-d 分隔符	将'分隔符'中的首个字符用作输入结束的标志,而不再是默认的'换行符'。
						-e		   使用Readline来处理输入。这使得与命令行相同的方式编辑输入。
						-n 字符数	读取'前字符数'个字符,而不再是整行数据。
						-p 提示		为输入显示'提示'字符串。
						-r		   源数据模式,即'反斜杠字符'不会被解释为'转义字符'。
						-s		   静默模式,即不会在屏幕上显示输入的字符,常用于密码和其它确认信息的输入,
						-t 秒数		超时设置。多少秒后终止输入,若超时则read命令会返回一个非0的退出状态。
						-u fd	   使用文件描述符fd中的输入数据,而不再是标准输入的数据。
				--> [变量1 变量...]选项,即将读取的数据不再赋值给shell变量'REPLY',而是依次赋值给'变量1'、'变量2'...；
					若'变量名'有多,则多余的'变量名'全部为空；
					若'读取的数据'有多,则多余的数据全部赋值给'最后一个变量名'；
				注意1:
					read命令之所以能够将'读取的数据'赋值给'多个变量',得益于shell会根据'分隔符'将读取的数据分离成独立的个体。
					默认使用shell变量'IFS'作为'分隔符'(即1个空格、1个tab或1个换行符,它们都被视作'分隔符')。
				注意2:
					你不能把管道用在read上,即虽然read命令接受标准输入,但你不能这样做:echo "foo" | read
					这个命令会显示成功,但REPLY变量总是为空。为什么会这样？答案与shell处理管道线的方式有关系。
					在bash(和其它shell程序,例如sh)中,管道操作会创建子shell。这个子shell是为了执行管道中的命令而创建的'shell和及其环境的副本'。
					在类Unix的系统中,子shell执行的时候会为进程创建父环境的副本。当进程结束之后,该副本就会被破坏掉。
					这意味着一个子shell永远不能改变父进程的环境,像管道操作中的read命令赋值变量,但该变量会成为(副本)环境的一部分。
					在上面的例子中,read命令在它的子shell环境中,把foo赋值给变量REPLY,但是当命令退出后,子shell和它的环境将被破坏掉,这样赋值的影响就会消失。
					使用here字符串是解决此问题的一种方法。

			exec 命令
				--> 不开启子shell的前提下,中途转去执行其他的命令(执行完毕后,父shell进程结束)。
			
			exit [n]
				--> 退出shell程序；
				--> [n]选项,即退出的同时设置退出状态；

			let 赋值表达式
				--> 更适用于数字,等价于(( 赋值表达式 )),但没有(( ... ))效率高；

			expr 表达式
				--> 求值表达式；

			cal [...] [[[日]月]年]
				--> 显示'当月'的日历信息(默认'星期天'为每周的第一天)；
				--> [-3]选项,即显示'上月'、'当月'和'下月'的日历信息；
					[-y]选项,即显示'当年'的日历信息；
					[-m]选项,即显示时'星期一'作为每周的第一天；
					[-j]选项,即显示时'日'用'年计日'表示；

			date [...] [+"格式字符串"]
				--> 显示当前的日期和时间；
				--> [-r 文件名]选项,即显示'文件'最后的修改日期和时间；
					[-d "字符串"]选项,即显示'字符串'对应的日期和时间,而不是当前的；
					[-s "字符串"]选项,即根据'字符串'设置日期和时间；
					[-u]选项,即显示UTC时间(即格林威治时间)；
				--> [+格式字符串],即'+'必须有,且与'格式字符串'之间没有空格；
						字符		说明
						%x 			xxxx年xx月xx日
						%X  		xx时xx分xx秒

						%Y  		年-四位数字
						%y  		年-后两位数字

						%m			月-两位数字
						%b			月-英文简写
						%B 			月-英文全称

						%d			日-两位数字
						%e			日-省0表示

						%a			星期-英文简写
						%A 			星期-英文全称

						%H			时-24制两位数字
						%k 			时-24制省0表示
						%I 			时-12制两位数字
						%l  		时-12制省0表示

						%M 			分-两位数字

						%S  		秒-两位数字

						%z  		时区-数字形式
						%Z  		时区-字符代号

						%p 			AM和PM标识
						
						%V 			年计星期(以星期一为第1天)
						%U 			年计星期(以星期天为第1天)
						%j			年计日三位数字
						
						%n 			换行
						%t 			制表符
						%%			%转义

		3) 文件/目录和文件/目录权限管理
			ls [...] [路径名1] [路径名...] 
				--> (按字母升序依次)显示当前目录下的文件和子目录,注意:'ls'命令本身是'ls --color=tty'命令的别名
				--> [-a]选项,即显示所有文件(包括文件名以'.'开头的隐藏文件)
					[-l]选项,即以'长格式'显示(显示详情),'长格式'通常包括:访问权限、文件的硬链接数、文件所有者名、文件所属用户组、文件按字节计的大小、文件最后一次修改的日期和文件名等信息
					访问权限,由10个字符组成:
					第1个字符表示'文件类型':
						-	表示'普通文件'
						d	表示'目录'
						l 	表示'符号链接'(若是符号链接,其余的9个字符总是'rwxrwxrwx')
						s   表示'套接字'文件
						c 	表示'字符设备文件'(即按照字节流来处理数据的设备,例如终端机或调制解调器)
						b 	表示'块设备文件'(即按照数据块来处理数据的设备,例如硬盘或CD-ROM 盘)
					其余9个字符表示'文件模式',即文件所有者(3个字符)、文件组所有者(3个字符)和其他人(3个字符)的读、写、执行权限(没有对应的权限用'-'补位来表示):
						r 	表示'文件-允许打开并读取文件内容','目录-允许列出目录中的内容,前提是目录必须设置了可执行属性(x)'
						w 	表示'文件-允许写入文件内容或截断文件。但是不允许对文件进行重命名或删除,重命名或删除是由目录的属性决定的','目录-允许在目录下新建、删除或重命名文件,前提是目录必须设置了可执行属性(x)'
						x 	表示'文件-允许将文件作为程序来执行,使用脚本语言编写的程序必须设置为可读才能被执行','目录-允许进入目录'
					八进制表示法:
						八进制数	二进制数	对应文件模式
							0		000			---
							1		001			--x
							2		010			-w-
							3		011			-wx
							4		100			r--
							5		101			r-x
							6		110			rw-
							7		111			rwx
					[-t]选项,即按文件的修改时间排序后显示
					[-h]选项,即以'人类可读'的形式显示文件大小信息
					[-r]选项,即将最终结果按照倒序显示
				--> [路径名]选项,即'绝对路径'和'相对路径',显示'一个或多个指定目录'下的文件和子目录

			file 文件名
				--> 显示'文件'的类型

			split [...] [文件名] [结果文件前缀]
				--> 将标准输入的内容按一定方式分割并写入多个'结果文件'中(结果文件默认命名为'xaa'、'xab'、'xac'...)；
				--> [-a 后缀位数]选项,即设置'结果文件'的后缀位数,默认为2；
					[-b 字节数]选项,即每个结果文件中仅包含'字节数'的原内容,'字节数'的单位可取:B、KB、MB...、M、G...；
					[-C 行字节数]选项,即每个结果文件中每行最多包含'字节数'的原内容；
					[-l 行数]选项,即每个结果文件中仅包含'行数'的原内容,默认为1000；
					[-n 块数]选项,即每个结果文件中仅包含'1/块数'的原内容；
					[-d]选项,即使用'数字后缀'(从0开始),默认使用'字符后缀'命名；
				--> [文件名],即从一个文件中读取待分割的内容,默认从标准输入读取；
					[结果文件前缀],即设置结果文件名的前缀,默认为'x'；

			uptime [...]
				--> 显示系统已运行的时间,输出结果形如:
					当前时间 up 已运行小时:已运行分钟, 当前登录用户数 user, 系统平均负载: 过去1分钟, 过去10分钟, 过去15分钟
					10:57:11 up 17:55, 1 user, load average: 0.00, 0.01, 0.05
						-> 系统平均负载,是指某一时段内系统运行队列中的平均进程数,没有等待I/O操作、没有主动进入等待状态或没有终止的进程都会进入运行队列；
				--> [-p]选项,即可读形式仅显示系统已运行的时间,形如:'up xx hours, xx minutes' -> up 17 housrs, 55 minutes；
					[-s]选项,即显示最近一次系统启动的日期和时间,例如:'2018-10-30 09:30:57'；

			ifup
				--> 启动网络接口；

			ifdown
				--> 关闭网络接口；
			
			shutdown [...] [时间] [信息1] [信息...] 
				--> 默认1分钟后,关机、切断电源或重启当前系统；
				--> [-P]选项,即切断电源(默认)；
					[-H]选项,即关机；
					[-r]选项,即重启；
					[-c]选项,即取消关机/切断电源/重启操作,前提是[时间]参数不为'0'/'now'；
					[-k]选项,即不真正执行关机/切断电源/重启操作,只是向所有的登录用户发送对应的信息；
					[--no-wall]选项,即不向所有的登录用户发送对应的信息；
				--> [时间],即设置'时间'过后再执行对应的操作,时间格式为:"hh:mm"(24制)或者"+m"(注意:"+0"等价于"now")；
						   若声明了'时间'参数,则当前系统会在'时间'到来前5分钟开始禁止任何用户登录；
				--> [信息...],即执行对应操作时,向所有登录用户发送的信息,注意:若想声明'信息'参数,则必须先声明'时间'参数；

			lsof [...] [文件名]
				--> 显示当前系统所有已打开文件的信息,包括:普通文件、目录、块设备文件、字符设备文件、可执行文本文件、库文件和套接字或网络流文件等；注意:CentOS系统下需要手动安装,形如:yum install lsof；
				--> [-i 网络地址]选项,即显示当前系统所有符合'网络地址'的已打开文件；'网络地址'格式为:[4/6][协议名][@IP地址][:端口号]
					[-c 文件前缀]选项,即显示当前系统所有以'文件前缀'开头的已打开文件；
				--> [文件名],即显示已打开的'指定文件'的信息；

			whereis
			ss

			
			nmap
			mutt
			mail
			mount
			umount
			fsck
			dd 
			fdisk
			parted 
			mkfs
			logout
			pkill
			nice 
			pgrep

			systemd
			init 

			service

			crontab [-u 用户名] 脚本文件名
				--> 向当前用户的cron守护进程提交'计划任务脚本',提交的同时系统会拷贝一份副本至/var/spool/cron目录下；
				--> [-u 用户名]选项,即向'指定用户'的cron守护进程提交计划任务脚本；
			
			crontab [-u 用户名] [...]
				--> 操作当前用户的crontab,该命令必须指定一个[...]选项；
				--> [-u 用户名]选项,即操作'指定用户'的crontab；
				--> [-l]选项,即将当前用户的'脚本文件'内容输出至'标准输出',提示:该操作可以借助'重定向'对脚本文件备份； 
					[-r]选项,即删除当前用户的'脚本文件'；
					[-i]选项,即搭配[-r],在实际删除之前,提示用户进行确认；
					[-e]选项,即编辑当前用户的'脚本文件'(默认使用环境变量EDITOR对应的编辑器,退出编辑器后crontab自动保存并生效)； 

				cron守护进程是Linux中的一个系统服务(操作系统安装后会自动安装并启动它),该守护进程被用于周期性执行任务,启动后它会每分钟检索一次是否有待执行的任务,如果有就执行它；
				Linux中的任务调度分为:
					1) 系统任务调度,即系统周期性要执行的任务,例如:将缓存数据写入磁盘、日志清理等；/etc/crontab文件则是系统任务调度的配置文件；
					2) 用户任务调度,即用户周期性要执行的任务,用户可以通过crontab命令来设置这些任务；
						当然,并非所有用户都可以使用crontab命令:
							/etc/cron.deny文件中定义了无法使用该命令的用户列表,
							/etc/cron.allow文件中定义了可以使用该命令的用户列表,
						此外,/var/spool/cron目录会保存用户设置的每个'计划任务脚本',这些脚本都以用户名命名；
						脚本的内容格式为每一行都对应一个计划任务,每一行的每个字段都对应一个配置项,
							形如:分钟字段 小时字段 日字段 月字段 星期字段 命令字段
							范围:0~59    0~23    1~31  1~12  0~7
							注意1:星期字段中的'0'和'7'均表示'星期天'；
							注意2:每个字段设置值时,都可以使用特殊字符
									*    表示所有合理的值
									,    表示多个非连续的值
									-    表示多个连续的值
									/    表示频率设置,例如:0-23/2,若0-23是小时字段,则表示每天当中每隔2小时执行一次

			md5sum [...] [文件名1] [文件名...]
				--> 读取'标准输入'的内容,并将它的MD5摘要(128位,共16个字符)输出至标准输出,结果形如:'MD5摘要' + '*/ ' + '-',
					其中'*'表示以二进制模式读取,'空格'表示以文本模式读取,'-'表示从标准输入文件读取)；
				--> [-c]选项,即从一个或多个文件中读取内容进行校验；
					[-b]选项,即以二进制模式读取内容；
					[-t]选项,即以文本模式读取内容(默认)；
				--> [文件名...],即显示一个或多个'文件'的MD5摘要,每行输出形如:'MD5摘要' + '*/ ' + '文件名'；
							    注意:若同时声明[-c],则表示从文件中读取内容进行校验,每行内容形如:'MD5摘要' + '*/ ' + '文件名'；
			
			touch [...] 文件名
				--> 将'文件'的'修改日期'和'访问日期'更新为'现在'(若'文件'不存在,则自动创建并更新它)；
				--> [-c]选项,即若'文件'不存在,则不自动创建并更新它；
					[-r]选项,即递归性地更新；
					[-m]选项,即仅更新'文件'的'修改日期'为'现在'； 
					[-a]选项,即仅更新'文件'的'访问日期'为'现在'；
					[-t YYYYMMDDhhmm[.ss]]选项,即默认将'文件'的'修改日期'和'访问日期'更新为'YYYY年MM月DD日hh时mm分[.ss秒]'；

			df
			du [...] [文件名1] [文件名...]
				--> 显示标准输入的大小；
					该命令会递归性地显示'标准输入目录或参数目录'及它们'所有子孙目录'的大小,但对'文件'不会；
				--> [-a]选项,即额外递归性地显示'所有子孙文件'的大小；
					[-d]选项,即设置递归性显示的最大深度；
					[-c]选项,即在结果最后加上所有参数文件的总大小；
					[-s]选项,即仅显示每个'参数文件/目录'的总大小,不显示子孙文件/目录的信息；
					[-D]选项,即对于符号连接,显示它的源文件大小；
					[-h]选项,即以可读形式显示结果,例如:K、M、G为单位；
					[-b]选项,即以'1B'为单位显示结果；
					[-k]选项,即以'1KB'为单位显示结果；
					[-m]选项,即以'1MB'为单位显示结果；

			stat [...] 文件名1 文件名...
				--> 显示一个或多个文件/文件所在文件系统的状态信息；
				--> [-f]选项,即仅显示文件所在文件系统的状态信息；
					[-L]选项,即显示符号链接的状态信息；
					[-c "格式化字符串"]选项,即显示格式对应部分的状态信息；
						文件格式标识	  对应的状态信息
						%n				文件名
						%N				带引号的文件名(用于区分该文件的符号连接)
						%F 				文件类型
						%s 				文件大小(按字节计)
						%a 				文件的访问权限(八进制表示)
						%A				文件的访问权限(可读表示)

						%U 				文件所有者的用户名
						%u 				文件所有者的用户ID
						%G 				文件所有者的用户组名
						%g 				文件所有者的用户组ID

						%w				文件的创建日期(可读表示,未知时用'-'表示)
						%x  			文件的最后访问日期(可读表示)
						%y 				文件的最后修改日期(可读表示)
						%z    			文件元数据(即权限或属性)的最后修改日期(可读表示)

						%W  			文件的创建日期(从Epoch至今的秒数,未知时用'0'表示)
						%X  			文件的最后访问日期(从Epoch至今的秒数)
						%Y 				文件的最后修改日期(从Epoch至今的秒数)
						%Z    			文件元数据(即权限或属性)的最后修改日期(从Epoch至今的秒数)

			chattr [...] [-V 文件编号] [属性表达式] 文件或目录名1 [文件或目录名...]
				--> 修改一个或多个文件的'文件属性'； 
				--> [-R]选项,即递归性地修改；
					[-V]选项,即显示详细的修改结果和chattr命令的版本；
					[-f]选项,即忽略错误信息；
				--> [-V 文件编号],即修改文件编号；
				--> 属性表达式,形如:+/-/=flags,flags包括以下的一个或多个常见的字符:
					a 该文件只能被'追加'数据,无法被'重写'或'截断',只有'超级用户'或'具有'CAP_LINUX_IMMUTABLE'能力的进程才能设置/清除该'文件属性'； 
					A 该文件的'访问日期'被锁定、无法被修改；
					c 该文件会被内核自动压缩(从该文件读取,数据会被自动解压；写入该文件,数据会先被压缩再保存至磁盘)；
					C 该文件不会被'写时拷贝'； 
					d 转储程序(即dump程序)运行时,该文件不会被备份；
					i 该文件无法被操作,包括:重命名、修改内容、删除文件和创建软链接等；
					S 对该文件的'写操作'立即生效至磁盘；
					s 该文件被彻底删除(用0填充磁盘上该文件所在的区域)；

			lsattr [...] [文件或目录名1] [文件或目录名...]
				--> 显示当前目录下所有可见文件的'文件属性'； 
				--> [-R]选项,即递归性地显示；
					[-a]选项,即显示所有文件的'文件属性',包括隐藏文件；
					[-d]选项,即显示所有文件的'文件属性',包括目录；
					[-v]选项,即显示所有文件的文件编号；
					[-V]选项,即显示lsattr命令的版本；

			basename [...] 路径名 [后缀名]
				--> 输出一个路径名的基本名；
				--> [-a]选项,即支持输出多个路径名的基本名(默认该命令最多接收2个参数)； 
					[-s 后缀名]选项,即搭配[-a],最终输出时额外去掉基本名中的'后缀名'；
				--> [后缀名],即最终输出时额外去掉基本名中的'后缀名'；

			dirname [...] 路径名1 路径名...
				--> 输出一个或多个路径名的父级路径,规则如下:
					若'路径名'中包含多个'/',则输出'路径名'中除最后一个'/'及其右侧所有字符之外的剩余字符；
					若'路径名'中仅含一个'/',则输出'/'；
					若'路径名'中不含任何'/',则输出'.'；

			rename [-v] 原字符 新字符 文件1 文件...
				--> 通过'字符替换'的方式对一个或多个文件重命名；
				--> [-v]选项,即显示替换详情,例如:xxx -> xxxxx
				--> [文件...],即一个或多个文件,可以使用'通配符'确定文件；

			mkdir [...] 目录1 目录...
				--> 创建一个或多个目录；
				--> [-m 权限数字]选项,即创建目录的同时设置目录权限；
					[-p]选项,即创建'多层级目录'时,若上级目录不存在,则一并创建它；

			rmdir [...] 空目录1 空目录...
				--> 删除一个或多个空目录；
				--> [-p]选项,即删除'多层级目录'时,若上级目录也是空目录,则一并删除它；
			
			diff [...] 文件或目录名1 文件或目录名2
				--> 一行行地比较两个文件或目录(默认比较双方相同时不显示结果),
					若比较一方为目录,则在该目录中搜索与另一方同名的文件进行比较,但不会搜索该目录中的子目录；
					比较双方不同时的输出结果形如:
						m1,n1cm2,n2				-> m1,n1表示文件或目录1的m~n行与2的不同；同理m2,n2表示文件或目录2的m~n行与1的不同；
						文件或目录1的m~n行内容
						---
						文件或目录2的m~n行内容
						p1,q1cp2,q2
						文件或目录1的p~q行内容
						---
						文件或目录2的p~q行内容
						...
				--> [-q]选项,即当比较双方不同时仅显示异同结论,不显示异同详情；
					[-s]选项,即即使比较双方相同也显示结果；
					[-r]选项,即递归性地比较子目录；
					[-y]选项,即并排显示结果(左:文件或目录1,右:文件或目录2)；
					[-W 数字]选项,即搭配[-y],左或右结果允许显示的最大宽度(默认130)；
					
					[-w]选项,即比较时无视空格；
					[-i]选项,即忽略大小写带来的不同；
					[-b]选项,即忽略空格数量带来的不同；
					[-Z]选项,即忽略行尾空格产生的不同；
					[-B]选项,即忽略空白行带来的不同；

					[-c 行数]选项,即使用'上下文模式'输出；
					[-u 行数]选项,即使用'统一模式'输出；
					
					[-a]选项,即将所有文件视作文本进行比较；

			cp [...] 源文件或目录名1 源文件或目录名... 目的文件或目录名 
				--> 将'一个或多个源文件或目录'拷贝至'目的文件或目录名':
					cp 文件1 文件... 目的文件    -> 复制'文件1 文件...'至'目的文件',若'目的文件'已存在,则会被重写；若不存在,则会被新建
					cp 文件1 文件... 目的目录    -> 复制'文件1 文件...'至'目的目录',要求'目的目录'必须已存在
					cp 目录1 目录... 目的目录 	 -> 复制'目录1 目录...'至'目的目录',若'目的目录'不存在,则会被新建
				--> [-a]选项,即完全拷贝,额外包括文件或目录的属性、权限和所有权等内容
				--> [-r]选项,即递归性地拷贝'源文件或目录'
				--> [-i]选项,即当该操作会重写'目的文件或目录'时,提示用户进行确认
				--> [-u]选项,即该操作仅向'目的文件或目录'中拷贝不存在或过时的内容

			mv [...] 源文件或目录名1 源文件或目录名... 目的文件或目录名 
				--> 将'一个或多个源文件或目录'移动至'目的文件或目录名',无论如何,'源文件或目录'都会在该操作后被删除:
					mv 文件1 文件... 目的文件    -> 移动'文件1 文件...'至'目的文件',若'目的文件'已存在,则会被重写；若不存在,则会被新建
					mv 文件1 文件... 目的目录    -> 移动'文件1 文件...'至'目的目录',要求'目的目录'必须已存在
					mv 目录1 目录... 目的目录 	 -> 移动'目录1 目录...'至'目的目录',若'目的目录'不存在,则会被新建
				--> [-i]选项,即当该操作会重写'目的文件或目录'时,提示用户进行确认
				--> [-u]选项,即该操作仅向'目的文件或目录'中移动不存在或过时的内容

			rm [...] 文件或目录名1 文件或目录名... 
				--> 删除'一个或多个文件或目录',类Unix的操作系统例如Linux中,没有复原命令。一旦你用rm删除了一些东西,它就消失了。
				--> [-r]选项,即递归性地删除,如果删除的是'目录',则必须指定[-r]选项
				--> [-f]选项,即忽略不存在的文件,不显示提示信息
				--> [-i]选项,即在删除已存在的文件前,提示用户确认信息；如果不指定这个选项,rm会默默地删除文件

			umask [新掩码值]
				--> 显示当前的掩码值(常用的掩码值为0002和0022)；
					当创建一个文件时,umask命令控制着文件的默认权限。
					umask命令使用八进制表示法来表达'从文件模式属性中删除一个位掩码'。
					把掩码展开成二进制形式,然后与文件属性相比较,先忽略掉开头的三个零,注意掩码中若出现一个数字1,则删除文件模式中和这个1在相同位置的属性,即取消一个文件模式属性。
				--> [掩码]选项,即将当前的掩码值设置为'新掩码值'；

			chmod 授权表达式 文件或目录名
				--> (仅限'超级用户'或'文件所有者')更改'指定文件或目录'的文件模式；
				--> 授权表达式分为'字符式'和'数字式'两种:
						字符式,即'一个或多个被授权者标志' + '授权行为标志' + '一个或多个行为权限标志'
							被授权者标志  -> u	  表示'文件或目录的所有者'
										   g 	表示'用户组'
										   o    表示'其他所有人'
										省略/a   表示'u+g+o'		

							授权行为标志  -> +    表示'添加xxx权限'
										   -    表示'删除xxx权限'
										   =    表示'仅添加xxx权限'

							行为权限标志  -> r    表示'读权限'
										   w 	表示'写权限'
										   x    表示'可执行权限'
						数字式,即'文件或目录的所有者权限' + '用户组权限' + '其他所有人权限',三者均用'数字'表示:
							4 表示 r 
							2 表示 w
							1 表示 x
							6 表示 rw
							5 表示 rx 
							3 表示 wx 
							7 表示 rwx
							0 表示 ---

			sudo chown [新所有者][:[新用户组]] 文件1 文件...
				--> (仅限'超级用户权限')将'一个或多个文件'的所有者(和用户组)更改为'新所有者'和'新用户组'
				--> [新所有者]选项,即如果省略,则不更改'一个或多个文件'的所有者;
				--> [:[新用户组]]选项,即如果省略,则仅更改'一个或多个文件'的所有者;
				--> [新用户组]选项,即如果省略,则'一个或多个文件'的用户组更改为'新所有者'所属的用户组;

			head [...] [文件名]
				--> 如果head没有给出任何参数,它会从标准输入读取数据
				--> [-n 行数]选项,即显示'文件'中的前'行数'文本
				--> [文件名]选项,即显示'文件'中的前10行文本

			tail [...] [文件名]
				--> 如果tail没有给出任何参数,它会从标准输入读取数据
				--> [-n 行数]选项,即显示'文件'中的后'行数'文本
				--> [文件名]选项,即显示'文件'中的后10行文本

			wc [...] [文件名]
				--> 显示'标准输入'文本的行数、单词数和字节数信息
				--> [-l]选项,即仅显示行数
				--> [-w]选项,即仅显示单词数
				--> [-c]选项,即仅显示字节数
				--> [文件名]选项,即依次显示'文件'的行数、单词数和字节数

			less 文件名
				--> 浏览'文件'的文本内容
				--> 浏览控制:Page Up / b     -> 向上翻一页
							Page Down / 空格 -> 向下翻一页  
							上箭头 			 -> 向上翻一行
							下箭头     		 -> 向下翻一行
							g    			-> 移动到开始行
							G     			-> 移动到结尾行
							q     			-> 退出浏览 

			zless 压缩文件名
				--> 其他同less

			** 硬链接 & 软链接 **
				硬链接是最初Unix创建链接的方式。每个文件默认会有一个硬链接,这个硬链接给予文件名字。每创建一个硬链接,就为一个文件创建了一个额外的目录项。
				硬链接有两个重要局限性:
					1) 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联与链接本身不在同一个磁盘分区上的文件。
					2) 一个硬链接不能关联一个目录。
				一个硬链接和文件本身没有什么区别。不像符号链接,当你列出一个包含硬链接的目录内容时,你会看到没有特殊的链接指示说明。
				当一个硬链接被删除时,这个链接被删除,但是文件本身的内容仍然存在(这是说,它所占的磁盘空间不会被重新分配),直到所有关联这个文件的链接都删除掉。

				创建符号链接是为了克服硬链接的局限性。符号链接生效,是通过创建一个特殊类型的文件,这个文件包含一个关联文件或目录的文本指针。
				在这一方面,它们和 Windows 的快捷方式差不多,当然,符号链接早于 Windows 的快捷方式很多年
				一个符号链接指向一个文件,而且这个符号链接本身与其它的符号链接几乎没有区别。例如,如果你往一个符号链接里面写入东西,那么相关联的文件也被写入。
				然而,当你删除一个符号链接时只有这个链接被删除,而不是文件自身。如果先于符号链接删除文件,这个链接仍然存在,但是不指向任何东西。
				在这种情况下,这个链接被称为坏链接。在许多实现中,ls命令会以不同的颜色展示坏链接,比如说红色,来显示它们的存在。
			
			ln 文件名 硬链接名
				--> 创建一个硬链接

			ln -s 文件或目录名 软链接名
				--> 创建一个软链接

			rm [-i] 链接名 
				--> 删除一个硬链接或软链接
				--> [-i]选项,即在删除已存在的链接前,提示用户确认信息；如果不指定这个选项,rm 会默默地删除链接

		4) 文件/目录的查找
			locate 文件路径名
				--> 执行一次快速的路径名数据库搜索,并且输出每个与'给定字符串'相匹配的路径名；
					通常'文件路径名'会借助'通配符'和'正则表达式'使用；

				--> locate命令已经存在了很多年了,它有几个不同的变体被普遍使用着。
					在现在Linux发行版中两个最常见的变体是slocate命令和mlocate命令,尽管它们通常被名为locate的符号链接访问。
					你可能注意到了,在一些发行版中仅在系统安装之后,locate命令不能工作,但是如果你第二天再试一下,它就正常工作了。怎么回事呢？
					locate命令搜索的数据库由另一个叫做updatedb的程序所创建。通常,这个程序作为一个定时任务(jobs)周期性运转；
					也就是说,一个任务在特定的时间间隔内被cron守护进程执行。大多数具有locate命令的系统会每隔一天运行一次updatedb程序。
					因为数据库不能被每时每刻地更新,所以当使用locate时,你会发现目前最新的文件不会出现。
					为了克服这个问题,通过更改为超级用户身份,在提示符下运行updatedb命令,就可以手动运行updatedb程序。

			find [...] [预定义操作]
				--> find命令能基于各种各样的属性,搜索一个给定目录(以及它的子目录)从而查找文件,而locate命令只能依据文件名来查找文件；
				--> [...]选项,即'各种各样的属性',常用的如下:
					[-type 类型标志] -> 根据'文件类型'来查找文件
						类型标志	 代表含义
						f			普通文件
						d 			目录
						l			软链接
						c			字节流设备
						b 			块设备

					[-name "文件路径名"]	-> 根据'文件名'来查找文件
						可以使用'通配符'和'正则表达式'； 
						使用""是为了避免shell的字符展开影响结果；
					
					[-size 大小]	-> 根据'文件大小'来查找文件
						大小,即'+/ /-' + '数字' + '单位':
							+ 表示'查找大于...容量的文件'
							表示'查找等于...容量的文件'
							- 表示'查找小于...容量的文件'
							
							c 表示'1字节'为1个单位
							w 表示'2字节'为1个单位,2字节
							b 表示'512字节'为1个单位,512字节
							k 表示'1024字节'为1个单位,千字节
							M 表示'1024*1024字节'为1个单位,兆字节
							G 表示'1024*1024*1024字节'为1个单位,千兆字节
					
					其他的选项:
						-iname pattern		就像-name测试条件,但是忽略大小写。

						-mmin n				匹配'内容'被修改于'n分钟'之前的文件或目录。
						-mtime n			匹配'内容'被修改于'n*24小时'之前的文件或目录。
						-cmin +/ /-n		匹配'内容或属性'最后修改时间'多于/正好在/少于'n分钟之前的文件或目录。
						-ctime n			匹配'内容和属性'最后修改时间在'n*24小时'之前的文件和目录。

						-newer file			匹配内容晚于指定的文件的文件和目录。这在编写执行备份的shell脚本的时候很有帮。
											每次你制作一个备份,更新文件(比如说日志),然后使用find命令来判断哪些文件自从上一次更新之后被更改了。
						-cnewer file		匹配内容或属性最后修改时间晚于file的文件或目录。

						-empty				匹配空文件和目录。
						-user name			匹配属于某个用户的文件或目录。这个用户可以通过用户名或用户ID来表示。
						-group name			匹配属于一个组的文件或目录。组可以用组名或组ID来表示。
						-perm mode			匹配权限已经设置为指定的mode的文件或目录。mode可以用八进制或符号表示法。

						-inum n				匹配inode号是n的文件。这对于找到某个特殊inode的所有硬链接很有帮助。
						-samefile name		类似于[-inum]。匹配和文件name享有同样inode号的文件。
						-nouser				匹配不属于一个有效用户的文件和目录。这可以用来查找属于被删除的帐户的文件或监测攻击行为。
						-nogroup			匹配不属于一个有效的组的文件和目录。

					多个选项同时查找文件
						-and				如果操作符两边的测试条件都是真,则匹配。可以简写为'-a'。注意:若没有使用操作符,则默认使用'-and'。
						-or					若操作符两边的任一个测试条件为真,则匹配。可以简写为'-o'。
						-not				若操作符后面的测试条件是真,则匹配。可以简写为一个感叹号'(!)'。
						()					把测试条件和操作符组合起来形成更大的表达式,这用来控制逻辑计算的优先级。
											默认情况下,find命令按照从左到右的顺序计算。经常有必要重写默认的求值顺序,以得到期望的结果。 
											即使没有必要,有时候包括组合起来的字符,对提高命令的可读性是很有帮助的。
											注意:因为圆括号字符对于shell来说有特殊含义,所以在命令行中使用它们的时候,它们必须用引号引起来,才能作为实参传递给find命令。
											通常反斜杠字符被用来转义圆括号字符。
				--> [预定义操作]选项,即找到文件后进一步的处理；
						处理参数	 		 描述
						-print				把匹配文件的全路径名输送到标准输出。如果没有指定其它操作,这是默认操作。
						-print0 			同-print,唯一的区别是在输送之前,将<用'空格'分隔的匹配结果>转换成<用'null'字符分隔的匹配结果>。
						-delete				删除当前匹配的文件。(注意:每当使用-delete参数时,都应该首先用-print测试一下匹配结果)
						-ls					对匹配的文件执行等同的'ls -dils'命令,并将结果发送到标准输出。
						-quit				一旦找到一个匹配就退出。
						-exec 自定义命令;     用户自定义的操作,详情如下:
												1) 自定义命令中若需要用到'当前文件的路径',可以使用"'{}'"表示(注意:必须加上''引号,因为{}在shell中有特殊含义)
												2) 自定义命令最后必须加上';'分隔符,用于表示命令的结束。例如,上述的< -delete >等价于< -exec rm '{}'; >
												3) 若所有的匹配结果都可以作为'自定义命令'的参数(例如:ls命令),则可以使用'+'替代最后的';',
												从而将匹配结果作为统一的'参数列表'传递给'自定义命令',这样可以避免每找到一次就执行一遍自定义命令带来的繁琐；
												另一种解决方式是:使用'管道'和'xargs命令':
													xargs [-show-limits] 命令
														--> xargs命令从'标准输入'接收数据,并将其构建成'参数列表'作用于'命令'；
														--> [-show-limits]选项,即显示xargs命令能够接收的最大数据量；
													类Unix的系统允许在文件名中嵌入空格(甚至换行符)。这就给一些程序,如为其它程序构建参数列表的xargs程序造成了问题。
													一个嵌入的空格会被看作是一个分隔符,生成的命令会把每个空格分离的单词解释为单独的参数。
													find命令和xarg命令允许使用一个可选的null字符作为参数分隔符,一个null字符被定义在ASCII码中,由数字0来表示(相反的,空格字符在ASCII码中由数字32表示)。
													find命令提供的[-print0]选项会产生由null字符分离的输出,并且xargs命令有一个[–null]选项,这个选项会接受由null字符分离的输入。这里有一个例子:
														find ~ -iname ‘*.jpg’ -print0	xargs –null ls -l
													这样,我们就可以保证所有文件(即使是文件名中包含空格的文件)都能被正确处理。
						-ok 自定义命令;		  同-exec,唯一的区别是在执行'自定义命令'之前,会提示用户并获得许可。
										
		5) 归档和备份
			计算机系统管理员的一个主要任务就是保护系统的数据安全,其中一种方法是通过时时备份系统文件来保护数据。

			数据压缩就是一个删除冗余数据的过程,应该注意'不要强迫性压缩',压缩已经压缩过的文件,实际上你会得到一个更大的文件。
			因为所有的压缩技术都会涉及一些开销,文件中会被添加描述此次压缩过程的信息。如果你试图压缩一个已经不包含多余信息的文件,那么再次压缩不会节省空间,以抵消额外的花费。
			
			让我们考虑一个假想的例子,比方说我们有一张100*100像素的纯黑的图片文件。
			根据数据存储方案(假定每个像素占24位,即3个字节),则该图像将占用30,000个字节的存储空间
			一张单色图像包含的数据全是多余的。我们要是聪明的话,可以用这种方法来编码这些数据:我们只要简单地描述这个事实,我们有3万个黑色的像素数据块。
			所以我们不存储包含3万个0(通常在图像文件中,黑色由0来表示)的数据块,取而代之,我们把这些数据压缩为'数字30000,后跟一个0'来表示我们的数据。这种数据压缩方案被称为'游程编码',是一种最基本的压缩技术。

			压缩算法(数学技巧被用来执行压缩任务)分为两大类:'无损压缩'和'有损压缩'。
			无损压缩保留了原始文件的所有数据。当还原一个压缩文件的时候,还原的文件与原文件一模一样。
			有损压缩,执行压缩操作时会删除数据,允许更大的压缩。当一个有损文件被还原的时候,它与原文件不相匹配而是一个近似值,例如:JPEG文件、MP3文件。

				gzip命令被用来压缩一个或多个文件,其语法如下:
					gzip [...] 文件名1 文件名...
						--> 压缩指定的一个或多个文件,压缩后的文件会覆盖原文件；
						--> [-数字]选项,即设置压缩指数,默认为6。'数字'的范围是1(最快,最小压缩)~9(最慢,最大压缩)之间的整数。
							[-r]选项,即若待压缩的文件是目录,则递归地压缩目录中的文件,子目录仍然不会被压缩。
							[-f]选项,即强制压缩,即使原文件的压缩文件已存在也会执行。
							[-v]选项,即显示压缩过程中的信息。
							[-d]选项,即解压文件,同gunzip命令。
								gunzip命令则被用来把压缩文件复原为没有被压缩的版本。这里有个例子:
									[me@linuxbox ~]$ ls -l /etc > foo.txt
									[me@linuxbox ~]$ ls -l foo.*
									-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt
									[me@linuxbox ~]$ gzip foo.txt
									[me@linuxbox ~]$ ls -l foo.*
									-rw-r--r-- 1 me     me 3230 2008-10-14 07:15 foo.txt.gz
									[me@linuxbox ~]$ gunzip foo.txt.gz
									[me@linuxbox ~]$ ls -l foo.*
									-rw-r--r-- 1 me     me 15738 2008-10-14 07:15 foo.txt
							[-l]选项,即列出每个压缩文件的压缩信息。
							[-t]选项,即测试压缩文件的完整性。
							[-c]选项,即将输出写入到标准输出,并且保留原始文件。
				
				bzip2命令,与gzip命令相似,但使用了不同的压缩算法,它舍弃了压缩速度,实现了更高的压缩级别。
					bzip2命令,除了[-r]选项和[-数字]选项,其他的gzip选项都支持:
					[-r]选项,bzip2命令中没有；[-数字]选项,bzip2命令中具有不同的含义。 

				xz命令被用于解压缩.xz文件,是Linux系统自带的压缩工具,压缩比率较大,其语法如下:
					xz [...] 文件名1 文件名...
						--> 压缩指定的一个或多个文件,压缩后的文件(以'.xz'结尾)会覆盖原文件；
						--> [-数字]选项,即设置压缩指数,默认为6。'数字'的范围是1(最快,最小压缩)~9(最慢,最大压缩)之间的整数。
							[-f]选项,即强制压缩,即使原文件的压缩文件已存在也会执行。
							[-v]选项,即显示压缩过程中的信息。
							[-d]选项,即解压文件；
							[-l]选项,即列出每个压缩文件的压缩信息。
							[-t]选项,即测试压缩文件的完整性。
							[-c]选项,即将输出写入到标准输出,并且保留原始文件。

			常见地,与文件压缩结合一块使用的文件管理任务是归档。归档就是收集许多文件,并把它们捆绑成一个大文件的过程。
			归档经常作为系统备份的一部分来使用。当把旧数据从一个系统移到某种类型的长期存储设备中时,也会用到归档程序。

			tar命令(即tape archive),是类Unix中用于'归档文件'的经典工具。最初,它是一款制作磁带备份的工具,而如今它仍然被用来完成传统任务,同样也适用于其它的存储设备。
			我们经常看到扩展名为.tar或者.tgz的文件,它们各自表示"普通"的tar包和被gzip程序压缩过的tar包。一个tar包可以由一组独立的文件,一个或多个目录,或者两者混合体组成。
			
			命令语法如下:
				tar mode[options] pathname...

				这里的mode是指以下模式(仅展示了部分)之一:
					模式	 	 说明
					-c			将'一个或多个文件和/或目录'(即归档文件)写入tar包中,
									形如:tar -cf tar包路径名 file1 file...
					-x			相对于当前工作目录,解压(即'抽取')tar包中的所有归档文件(或单个归档文件),
									形如:tar -xf tar包路径名 [单个归档文件]
					-r			向tar包中追加'新的归档文件',
									形如:tar -rf tar包路径名 追加的file1 追加的file...
					-t			显示tar包中的所有文件,
									形如:tar -tf tar包路径名
				这里的options是指以下选项(仅展示了部分)之一:
					选项		 说明
					-f 文件名 	 将归档文件写入'文件名'tar包中,或者从'文件名'tar包中解压缩所有的归档文件
									'文件名'tar包通常以'.tar'结尾,且与'f'选项之间禁止任何其他参数
					-v 			显示tar包的详细信息,通常搭配'-cf'或'-xf'使用
					-m 			解压缩tar包时,将所有归档文件的修改时间更新为当下(默认为完成归档时)
					-z  		归档文件的同时,执行gzip命令压缩它们
					-j 			归档文件的同时,执行bzip2命令压缩它们
				
				* 必须先指定'模式',再跟上'选项'。
				* '模式'和'选项'可以连写,且'部分'不需要开头的'-'短横线,但推荐始终都加上'-'。

		6) 文件/目录的同步
			维护系统备份的常见策略,是保持一个或多个目录与另一个本地系统(通常是某种可移动的存储设备)或者远端系统中的目录(或多个目录)同步。
			在类Unix系统中,能完成此任务且备受人们喜爱的工具是rsync。
			这个程序能同步本地与远端的目录,通过使用rsync远端更新协议,此协议允许rsync快速地检测两个目录的差异,执行最小量的复制来达到目录间的同步。
			语法如下:
				rsync options source destination
					--> 同步destination和source:
							如果destination是目录,则在destination下创建一个source的'镜像副本'；
							如果destination是文件,则保持destination和source的内容一样；

					--> source和destination可以是:
							1) 本地文件或目录
							2) 远端文件或目录,以 '[user@]host:path' 的形式存在
							3) 远端rsync服务器,由 'rsync://[user@]host[:port]/path' 指定
						注意:source和destination两者之一必须是'本地文件'(因为rsync不支持'远端到远端'的复制)。
							source可以有'一个或多个',但destination只能有'一个'。
				
					--> 这里的options是指以下选项(仅展示了部分)之一:
							选项		 说明
							-a 			递归和保护文件属性
							-v 			冗余输出
							--delete 	删除source中不再存在,而destination中仍然存在的文件
							--rsh=ssh   利用远程shell程序ssh进行远程复制
										远程复制可以通过两种方法完成:
										方法一
											要求另一个系统已经安装了rsync程序和远程shell程序(例如:ssh)；
											[--rsh=ssh]选项,指示rsync使用ssh程序作为它的远程shell,使用一个ssh加密通道把数据安全地传送到远程主机中。
															同时,通过在'目标路径名'前面加上'远端主机名'来指定远端主机。
										方法二
											rsync可以被用来在网络间同步文件的第二种方式是通过借助'rsync服务器'。
											rsync可以被配置为一个'守护进程',来监听即将到来的同步请求,这样做经常是为了进行一个远程系统的镜像操作。



		7) 通配符、正则表达式和'三个命令'
			通配符
				在需要'文件名'的命令中,可以使用'通配符'来对应'某些文件名':
				*			匹配0或多个字符
				?			匹配任意1个字符
				[...]		匹配...中的任意1个
				[!...]		匹配不在...中的
				[:alpha:]	匹配任意1个字母
				[:digit:]	匹配任意1个数字
				[:alnum:]	匹配任意1个字母或数字
				[:upper:]	匹配任意1个大写字母
				[:lower:]	匹配任意1个小写字母

			正则表达式
				正则表达式是一种符号表示法,被用于识别文本模式。在某种程度上,它们与匹配文件和路径名的'shell通配符'相似,但正则表达式的规模更庞大。
				不同工具和不同语言之间的正则表达式大都略有差异。我们这里仅讨论POSIX标准中描述的正则表达式(其包括了大多数的命令行工具)。

				grep命令(即'global regular expression print'),会在文本文件中查找一个指定的正则表达式,并将匹配行输出到标准输出。
				例如:ls /usr/bin | grep zip,这个命令会列出位于目录/usr/bin中,且文件名中包含子字符串"zip"的所有文件。grep命令的语法如下:
				grep [...] regex [file...]
					-->
					--> [...]选项,即常见的有:
							选项	 描述
							-i		忽略大小写,即不区分大小写字符。也可用--ignore-case来指定。
							-v		不匹配。通常,grep命令会打印包含匹配项的文本行,该选项导致grep命令只会打印不包含匹配项的文本行。也可用--invert-match来指定。
							-c		打印匹配的数量(或不匹配的数量,若指定了-v选项),而不是文本行本身。也可用--count选项来指定。
							-l		打印包含匹配项的文件名,而不是文本行本身,也可用--files-with-matches选项来指定。
							-L		类似于-l选项,但是只是打印不包含匹配项的文件名。也可用--files-without-match来指定。
							-n		在每个匹配行之前打印出其位于文件中的相应行号。也可用--line-number选项来指定。
							-h		应用于多文件搜索,不输出文件名。也可用--no-filename选项来指定。

					--> 元字符(Metacharacters)和原义字符(Literals)
							元字符:. ^ $ [ ] - { } ? * + ( ) | \
								.		匹配'任意一个字符'
								^		匹配'文本的开头',例如:^$ 将匹配'空行'
								$		匹配'文本的结尾',例如:^$ 将匹配'空行'
								[...]	匹配'...中的任意一个字符','...'也可以是除'^'和'-'之外的元字符
								[.-..]	匹配'.至..之间的任意一个字符',例如:[a-zA-Z0-9]

										Unix开发之初只知道ASCII字符。在ASCII中:
										前32个字符(数字0－31)都是控制码(例如:tabs、backspaces和回车等)。
										随后的32个字符(数字32－63)包含可打印的字符、大多数标点符号,以及数字0-9。
										再随后的32个字符(数字64－95)包含大写字符和更多的标点符号。
										最后的31个字符(数字96－127)包含小写字母和更多的标点符号。

										注意字符排序对[.-..]匹配结果的影响:
											'传统字符排序'(即ASCII排序)是:ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz
											'字典字符顺序'确是:aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ
										因此,采用不同的'字符排序'规则,会导致[A-Z]匹配的范围不一样。

										此外,随着Unix系统的知名度在美国之外的国家传播开来,就需要支持不在'U.S.'英语范围内的字符。
										于是就扩展了这个ASCII字符表,使用了整个8位,添加了字符(数字128－255),这样就容纳了更多的语言。
										为了支持这种功能,POSIX标准引入了"locale"概念,它能针对不同地区选择合适的字符集。
										locale命令将显示当前使用的'字符排序'规则,其中涉及变量LANG,当变量LANG为POSIX时,会遵循'传统字符排序'(即export LANG=POSIX)
											[me@linuxbox ~]$ echo $LANG
											en_US.UTF-8

										同时,为兼容二者,POSIX标准定义了大量的字符集:
											字符集		 说明
											[:alnum:]	'字母 & 数字'。等价于'传统字符排序'(即ASCII排序)的[A-Za-z0-9]
											[:word:]	'字母 & 数字 & _'
											[:alpha:]	'字母'。等价于'传统字符排序'(即ASCII排序)的[A-Za-z]
											[:upper:]	'大写字母'
											[:lower:]	'小写字母'
											[:digit:]	'数字0-9'

											[:space:]	空白字符,包括空格、tab、回车、换行、vertical tab 和 form feed。等价于'传统字符排序'(即ASCII排序)的[ \t\r\n\v\f]
											[:blank:]	包含空格和tab字符。
											[:punct:]	标点符号字符。等价于'传统字符排序'(即ASCII排序)的[-!"#$%&'()*+,./:;<=>?@[\\\]_`{|}~]

											[:cntrl:]	ASCII的控制码。包含了数字0-31和数字127的ASCII字符。
											[:graph:]	可视字符。在ASCII中,它包含数字33-126的字符。
											[:print:]	可打印的字符。在[:graph:]中的所有字符,再加上空格字符。
											
											[:xdigit:]	用来表示十六进制数字的字符。等价于'传统字符排序'(即ASCII排序)的[0-9A-Fa-f]
								[^...]	匹配'除...之外的任意一个字符'
								'|'		匹配'|'左边或右边的正则表达式,注意使用引号包裹,以便和管道区别
								?		匹配0个或1个前面的表达式
								*		匹配0个或多个前面的表达式
								+		匹配1个或多个前面的表达式
								{n}		匹配前面的表达式,如果它确切地出现了 n 次。
								{n,m}	匹配前面的表达式,如果它至少出现了 n 次,但是不多于 m 次。
								{n,}	匹配前面的表达式,如果它出现了 n 次或多于 n 次。
								{,m}	匹配前面的表达式,如果它出现的次数不多于 m 次。
							
							POSIX 把正则表达式的实现分成了两类:基本正则表达式(BRE)和扩展的正则表达式(ERE)。
							BRE可以辨别以下元字符:^ $ . [ ] *	其它的所有字符被认为是'文本字符'。
							ERE添加了以下元字符(以及与其相关的功能):( ) { } ? + |
							
							在BRE中,字符"(" ")" "{" 和 "}"用反斜杠转义后,被看作是元字符, 
							在ERE中,在任意元字符之前加上反斜杠会导致其被看作是一个文本字符。
							因此,在个别情况下,反斜杠会被用来创建元序列,元字符也可以被转义为原义字符,而不是被解释为元字符。
							
							原义字符:其他所有字符

				sed [...] [文件名]
					--> sed是'Stream Editor'(即流编辑器)的简称,该指令对来自标准输入、管道或文件的输入流执行文本编辑,尤其是通过管道进行文本过滤的功能特别有用；


		8) 重定向和'三个标准'
			通常,命令从'标准输入'文件(用'STDIN'表示)中接收内容,将运行结果输送至'标准输出'文件(用'STDOUT'表示),将状态信息输送至'标准错误'文件(用'STDERR'表示)；
			默认情况下,'标准输入'对应键盘,'标准输出'和'标准错误'对应屏幕；
			在命令中,'-'对应'标准输入(文件)'或'标准输出(文件)',因此许多命令中都可以使用'-'作为参数。
			
			此外,为了让命令能够操作其他的文件,我们可以使用'I/O重定向'来更改输入来源和输出地点。
				使用'重定向符' + '文件名'的方式将'标准输出'更改为非屏幕的其他文件,例如:命令 > filename。这种方式输出结果时,
				目标文件filename总是从开头被重写,因此如果我们需要清空一个文件(或创建一个新文件),可以省去命令直接键入'> filename'。
				如果不想filename总是从开头被重写,我们可以使用'>>'重定向符,这样会将输入结果'追加'进filename,例如:命令 >> filename。

			还需要知道,shell绑定了'标准输入'文件、'标准输出'文件和'标准错误'文件的描述符,分别是0、1和2；
				因此也可以使用文件描述符进行重定向,例如:将标准错误都重定向至ls-error.txt文件(文件描述符'2'需要紧跟定向符'>'):'命令 2> ls-error.txt'。

				对应地,如果将标准输出和标注错误重定向至同一文件:
				旧版本(重定向的顺序安排非常重要,标准错误必须出现在标准输出之后):
					命令 > 文件名 2>&1

				新版本:
					命令 &> 文件名

				垃圾桶文件
					有时候,我们不想要命令的输出结果,只想把它们扔掉,特别是输出结果是各种错误或状态信息。我们可以借助特殊文件'/dev/null',该文件接受输入但对输入不做任何处理。
					例如:为了隐瞒命令错误信息:命令 2> /dev/null

			cat [...] [文件名1] [文件名...]
				--> 从标准输入拷贝内容并'正序一行行地输出'至标准输出(键入'Ctrl+d'提示该命令以结束标准输入)；
				--> [-b]选项,即显示时给'非空行'编号,行号从数字1开始；
					[-n]选项,即显示时给'所有行'编号,行号从数字1开始；
					
					[-s]选项,即无论多少'连续空行',显示时只显示一个空行；
					[-t]选项,即显示时Tab符显示为^I,且除LFD和Tab之外的控制符均显示为^和M-；
					[-e]选项,即显示时每行结尾显示$,且除LFD和Tab之外的控制符均显示为^和M-；
				--> [文件名]选项,即不再从标准输入拷贝内容,而是从一个或多个文件拷贝；

			zcat [压缩文件名]
				--> 其他同cat；

			tac [-s] [文件名1] [文件名...]
				--> 从标准输入拷贝内容并'倒序一行行地输出'至标准输出(键入'Ctrl+d'提示该命令以结束标准输入)；
				--> [-s 字符]选项,即以'字符'作为行与行之间的界定符,而不再是'换行符'(但'换行符'的效果依然在)；
				--> [文件名]选项,即不再从标准输入拷贝内容,而是从一个或多个文件拷贝；

			rev [文件名1] [文件名...]
				--> 从标准输入读取内容并'一行行地字符倒序'至标准输出(键入'Ctrl+d'提示该命令以结束标准输入)；例如:
					原文件内容: 
						How are you?
						I'm fine.
					输出结果:
						?uoy era woH 
						.enif m'I
				--> [文件名]选项,即不再从标准输入读取内容,而是从一个或多个文件读取；

			paste [...] 文件名1 文件名...
				--> 将一个或多个文件的内容'一行行地合并'后输出至标准输出；
				--> [-d 字符]选项,即一行行合并时,不同文件的内容之间使用'字符'连接(默认使用Tab连接)；
					[-s]选项,即合并时,按照'文件名'参数的先后顺序,将同一文件的所有行内容合并后,再轮到下个文件；
					例如,file1 -> a		file2 -> 1
								  b 				2
								  c					3
								  					4
					paste file1 file2 -> a	1
										 b 	2
										 c 	3
										  	4
					paste -d : file1 file2 -> a:1
											  b:2
											  c:3
											  :4
					paste -s file1 file2 -> a	b 	c 
											1	2	3	4

			cut [...] [文件名1] [文件名...]
				--> 从标准输入'一行行地选取'内容并输出至标准输出(键入'Ctrl+d'提示该命令以结束标准输入)； 
				--> [-n]选项,即搭配[-b]选项,选取时不分隔多字节内容；
					[-b n/n-/n-m/-m]选项,即按字节数计,选取每行的'第n个/n至行尾个/n至m个/行首至m个'内容并输出；
					
					[-c n/n-/n-m/-m]选项,即按字符数计,选取每行的'第n个/n至行尾个/n至m个/行首至m个'内容并输出；
					
					[-f n/n-/n-m/-m]选项,即按字段数计,选取每行的'第n个/n至行尾个/n至m个/行首至m个'内容并输出(默认使用Tab作为字段的界定符)；
					[-d 字符]选项,即搭配[-f]选项,使用'字符'作为字段的界定符,而不再是Tab；
					
					[--complement]选项,即取反,选取内容不输出,输出其他所有内容；
				--> [文件名]选项,即不再从标准输入选取内容,而是从一个或多个文件选取；

			sort [...] [文件1] [文件...]
				--> 将标准输入的内容进行排序后输出至标准输出(默认对整行进行排序,从每行的第一个字符开始)；
				--> [-b]选项,即排序时忽略每行开头的空格(即从第一个'非空白字符'开始排序)。
					[-f]选项,即排序时不区分大小写。
					[-n]选项,即基于字符串的数字值排序,而不是字母值。
					[-r]选项,即最终结果按照降序排列,而不是升序。
					[-k	field1[,field2]]选项,即对从field1到field2之间的字符排序,而不是整个文本行。
					[-m]选项,即把每个命令参数视作预先排好序的文件,把多个文件合并成一个排好序的文件,而没有执行额外的排序。
					[-o 文件名]选项,即将排序结果输出至'文件'中。
					[-t	char]选项,即定义域分隔字符,默认域由空格或制表符分隔。
				--> [文件...],即若声明了文件参数,则将一个或多个文件的内容进行排序(而不再是标准输入)；

			有些命令既能从'标准输入'接收内容,又能输送结果至'标准输出',在使用它们时我们可以借助'管道'这一高阶重定向进行更复杂的操作:
			使用管道操作符'|',一个命令的标准输出可以通过管道送至另一个命令的标准输入,例如:command1 | command2

			可以把几个命令放在一起组成一条管道线(也叫'过滤器')。过滤器接受输入,以某种方式改变它,然后输出它。
				例如,我们想把目录/bin 和/usr/bin中的可执行程序都联合在一起,再把它们排序,然后浏览执行结果:ls /bin /usr/bin | sort | less
				我们指定了两个目录'/bin'和'/usr/bin',ls命令的输出结果由有序列表组成,各自针对一个目录。通过在管道线中包含sort,我们改变输出数据从而产生一个有序列表。

				例如,uniq命令经常和sort命令结合在一起使用。
				uniq命令从标准输入或单个文件名参数接受数据有序列表,默认情况下它从数据列表中删除任何重复行。
				我们添加uniq命令到我们的管道线中:ls /bin /usr/bin | sort | uniq | less
				这样,我们就使用uniq命令从sort命令的输出结果中删除了任何重复行。
				如果我们想看到重复的数据列表,让uniq命令带上'-d'选项,就像这样:ls /bin /usr/bin | sort | uniq -d | less

			Here文档和Here字符串
				here document是另外一种I/O重定向形式,我们在脚本文件中嵌入正文文本,然后把它发送给一个命令的标准输入。它这样工作:
					command << token
					text
					token
				这里的command是一个可以接受标准输入的命令名,token是一个用来指示嵌入文本结束的字符串。例如如下脚本:
					#!/bin/bash
					# Program to output a system information page
					TITLE="System Information Report For $HOSTNAME"
					CURRENT_TIME=$(date +"%x %r %Z")
					TIME_STAMP="Generated $CURRENT_TIME, by $USER"
					cat << _EOF_
					<HTML>
							<HEAD>
									<TITLE>$TITLE</TITLE>
							</HEAD>
							<BODY>
									<H1>$TITLE</H1>
									<P>$TIME_STAMP</P>
							</BODY>
					</HTML>
					_EOF_

				取代echo命令,现在我们的脚本使用cat命令和一个here document。
				这个字符串_EOF_(意思是"文件结尾",一个常见用法)被选作为token,并标志着嵌入文本的结尾。
				注意:这个token必须在一行中单独出现,并且文本行中没有末尾的空格。同时,我们在一个here document中可以随意的嵌入引号。

				Here documents可以和任意能接受标准输入的命令一块使用。
				在这个例子中,我们使用了一个here document将一系列的命令传递到这个ftp程序中,为的是从一个远端FTP服务器中得到一个文件:
					#!/bin/bash
					# Script to retrieve a file via FTP
					FTP_SERVER=ftp.nl.debian.org
					FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom
					REMOTE_FILE=debian-cd_info.tar.gz
					ftp -n << _EOF_
					open $FTP_SERVER
					user anonymous me@linuxbox
					cd $FTP_PATH
					hash
					get $REMOTE_FILE
					bye
					_EOF_
					ls -l $REMOTE_FILE

				如果我们把重定向操作符从"<<"改为"<<-",shell会忽略在此here document中开头的'tab'字符。
				这就能缩进一个 here document,从而提高脚本的可读性:
					#!/bin/bash
					# Script to retrieve a file via FTP
					FTP_SERVER=ftp.nl.debian.org
					FTP_PATH=/debian/dists/lenny/main/installer-i386/current/images/cdrom
					REMOTE_FILE=debian-cd_info.tar.gz
					ftp -n <<- _EOF_
						open $FTP_SERVER
						user anonymous me@linuxbox
						cd $FTP_PATH
						hash
						get $REMOTE_FILE
						bye
					_EOF_
					ls -l $REMOTE_FILE

				<<<操作符表示一个here字符串。一个here字符串就像一个here document,只是比较简短由单个字符串组成。

		9) 进程管理
			现在的操作系统都支持多任务,意味着操作系统通过在一个执行中的程序和另一个程序之间快速地切换造成了一种它同时能够做多件事情的假象。
			Linux内核通过使用进程来管理多任务。进程,就是Linux组织安排正在等待使用CPU的各种程序的方式。

			当系统启动的时候:
				a) 内核先把一些它自己的活动初始化为进程；
				b) 然后运行init程序；
				c) init程序再依次运行一系列init脚本(它们位于/etc目录下,可以启动所有的系统服务)；
			其中许多系统服务以守护(daemon)程序的形式实现,守护程序仅在后台运行,没有任何用户接口(User Interface)。 

			在进程方案中,一个程序可以启动另一个程序,被表述为一个父进程可以产生一个子进程。
			内核维护每个进程的信息,以此来保持事情有序。例如,系统分配给每个进程一个数字,这个数字叫做进程(process)ID或PID。
			PID号按升序分配,init进程的PID总是1。
			内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。
			像文件一样,进程也有所有者和用户ID,有效用户ID,等等。

			ps [x] [aux]
				--> 显示与当前会话相关的所有进程(结果信息中,PID表示进程ID,TTY表示进程的控制终端,TIME表示进程消耗CPU的时间,CMD表示进程对应的命令)；
				--> [x]选项,即注意没有'-'符号,显示所有无控制终端的进程(这也意味着TTY一栏会显示'?'；同时会新增STAT一栏,用于反映进程的当前状态,具体如下)
						R		表示运行中,即进程正在运行或准备运行。
						S		表示正在睡眠。进程没有运行,而是等待一个事件,例如,一个按键或者网络分组。
						D		表示不可中断睡眠。进程正在等待I/O,例如,一个磁盘驱动器的I/O。
						T		表示已停止. 已经指示进程停止运行。
						Z		表示一个死进程或'僵尸进程'。这是一个已经终止的子进程,但是它的父进程还没有清空它(即父进程没有把子进程从进程表中删除)。
						<		表示一个高优先级进程。这可能会授予一个进程更多重要的资源,给它更多的CPU时间。进程的这种属性叫做niceness。
								具有高优先级的进程据说是不好的(less nice),因为它占用了比较多的CPU时间,这样就给其它进程留下很少时间。
						N		表示低优先级进程。一个低优先级进程(即'nice'进程),只有当其它高优先级进程被服务了之后,才会得到处理器时间。
				--> [aux]选项,即显示额外的辅助信息,具体如下:
						USER	表示用户ID,即进程的所有者。
						%CPU	表示以百分比表示的CPU使用率。
						%MEM	表示以百分比表示的内存使用率。
						VSZ		表示虚拟内存大小。
						RSS		表示进程占用的物理内存的大小,以千字节为单位。
						START	表示进程启动的时间。若它的值超过24小时,则用天表示。		
								
			虽然ps命令能够展示许多计算机运行状态的信息,但是它只是提供ps命令执行时刻的机器状态快照。
			为了看到更多动态的信息,我们使用top命令。top命令以进程活动顺序显示连续更新的系统进程列表(默认情况下,每三秒钟更新一次)；
			"top"这个名字来源于top程序是用来查看系统中"顶端"进程的。top命令的结果由两部分组成:最上面是系统概要,下面是进程列表,以CPU的使用率排序。
				top命令结果说明:
				行号	 字段		 含义	
				1		top			程序名。
						14:59:20	当前时间。
						up 6:30		这是正常运行时间。它是计算机从上次启动到现在所运行的时间。 在这个例子里,系统已经运行了六个半小时。
						2 users		有两个用户登录系统。
					load average:	加载平均值是指,等待运行的进程数目,也就是说,处于可以运行状态并共享CPU的进程个数。 
									这里展示了三个数值,每个数值对应不同的时间段。第一个是最后60秒的平均值,下一个是前5分钟的平均值,最后一个是前15分钟的平均值。
									若平均值低于1.0,则指示计算机 工作不忙碌。
				2		Tasks:		总结了进程数目和这些进程的各种状态。
				3		Cpu(s):		这一行描述了CPU正在进行的活动的特性。
						0.7%us		0.7%的CPU被用于用户进程。这意味着进程在内核之外。
						1.0%sy		1.0%的CPU时间被用于系统(内核)进程。
						0.0%ni		0.0%的CPU时间被用于"nice"(低优先级)进程。
						98.3%id		98.3%的CPU时间是空闲的。
						0.0%wa		0.0%的CPU时间来等待 I/O。
				4		Mem:		展示物理内存的使用情况。
				5		Swap:		展示交换分区(虚拟内存)的使用情况。
			在终端中,输入<Ctrl+C>,可以'暂停'许多(但不是全部)命令行程序；输入 <Ctrl+Z>,可以'终止'程序。

			一个在后台运行的进程对一切来自键盘的输入都免疫,也不能用 <Ctrl+C> 来中断它。
			为了让一个进程返回前台(foreground),这样使用fg命令:
			jobs
				--> 显示所有后台运行的命令信息(其中包括任务序号)；

			fg %任务序号
				--> 将后台运行的命令返回至前台；

			bg %任务序号
				--> 将前台运行的命令移动至后台(此外,形如:'命令 &',在命令后面跟上'&'也可以让该命令在后台执行)；

			kill命令不是真的"杀死"程序,而是给程序发送信号。信号是操作系统与程序之间进行通信时所采用的几种方式中的一种。
			在使用 <Ctrl+C> 和 <Ctrl+Z> 的过程中我们已经看到信号的实际用法。当终端接受了其中一个按键组合后,它会给在前端运行的程序发送一个信号。
			在使用 <Ctrl+C> 的情况下,会发送一个叫做 INT(Interrupt,中断)的信号；当使用<Ctrl+Z>时,则发送一个叫做TSTP(Terminal Stop,终端停止)的信号。
			程序,相应地,监听信号的到来,当程序接到信号之后,则做出响应。一个程序能够监听和响应信号这件事允许一个程序做些事情,比如,当程序接到一个终止信号时,它可以保存所做的工作。

			kill [-信号] PID/%任务序号
				--> 通过'PID'或'任务序号'终止对应的进程(实际上,是向'一个进程'发送信号)；
					你必须拥有超级用户权限才能给不属于你的进程发送信号；
				--> [-信号]选项,向'一个进程'发送'指定的信号',该信号可以用'数字'表示,也可以是'字符缩写',具体如下:
					1	HUP		挂起	 这是美好往昔的残留部分,那时候终端机通过电话线和调制解调器连接到远端的计算机。
										这个信号被用来告诉程序,控制的终端机已经"挂断"。通过关闭一个终端会话可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。
										许多守护进程也使用这个信号来重新初始化。这意味着,当一个守护进程收到这个信号后,这个进程会重新启动并且重新读取它的配置文件。
										Apache网络务器守护进程就是一个例子。
					18	CONT	继续	在一个停止信号后,这个信号会恢复进程的运行。
					19	STOP	停止	这个信号导致进程停止运行,而不是终止。像KILL信号,它不被发送到目标进程,因此它不能被忽略。
					15	TERM	终止	这是kill命令发送的默认信号。如果程序仍然"活着"(可以接受信号),那么它会终止。
					2	INT		中断	实现和<Ctrl+C>一样的功能。由终端发送,它会终止一个程序。
					9	KILL	杀死	这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的信号(包含忽略信号),但KILL信号从不被发送到目标程序,而是内核立即终止这个进程。
									   当一个进程以这种方式终止的时候,它没有机会去做些"清理"工作或保存工作。所以把KILL信号看作最后一招,当其它终止信号失败后再使用它。

			killall [-信号] [-u 用户名] PID1/%任务序号1 PID1/%任务序号1...
				--> 通过'PID'或'任务序号'终止'一个或多个'进程；

			pstree	
				--> 输出一个树型结构的进程列表(processtree),这个列表展示了进程间父/子关系。

		10) 网络管理
			ifconfig命令
				示例:
					[root@localhost ~]# ifconfig
					eth0    Link encap:Ethernet  HWaddr 00:16:3E:00:1E:51  
							inet addr:10.160.7.81  Bcast:10.160.15.255  Mask:255.255.240.0
							UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
							RX packets:61430830 errors:0 dropped:0 overruns:0 frame:0
							TX packets:88534 errors:0 dropped:0 overruns:0 carrier:0
							collisions:0 txqueuelen:1000
							RX bytes:3607197869 (3.3 GiB)  TX bytes:6115042 (5.8 MiB)

					lo      Link encap:Local Loopback  
							inet addr:127.0.0.1  Mask:255.0.0.0
							UP LOOPBACK RUNNING  MTU:16436  Metric:1
							RX packets:56103 errors:0 dropped:0 overruns:0 frame:0
							TX packets:56103 errors:0 dropped:0 overruns:0 carrier:0
							collisions:0 txqueuelen:0
							RX bytes:5079451 (4.8 MiB)  TX bytes:5079451 (4.8 MiB)
				说明:
					"""
					ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
					inet 192.168.0.200  netmask 255.255.255.0  broadcast 192.168.0.255
					inet6 fe80::cc05:f9e3:9f85:16e4  prefixlen 64  scopeid 0x20<link>
					ether 00:0c:29:09:36:40  txqueuelen 1000  (Ethernet)
					RX packets 644  bytes 142521 (139.1 KiB)
					RX errors 0  dropped 0  overruns 0  frame 0
					TX packets 242  bytes 33298 (32.5 KiB)
					TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

					lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
							inet 127.0.0.1  netmask 255.0.0.0
							inet6 ::1  prefixlen 128  scopeid 0x10<host>
							loop  txqueuelen 1  (Local Loopback)
							RX packets 879  bytes 80840 (78.9 KiB)
							RX errors 0  dropped 0  overruns 0  frame 0
							TX packets 879  bytes 80840 (78.9 KiB)
							TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

					virbr0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
							inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255
							ether 52:54:00:5a:f0:d7  txqueuelen 1000  (Ethernet)
							RX packets 0  bytes 0 (0.0 B)
							RX errors 0  dropped 0  overruns 0  frame 0
							TX packets 0  bytes 0 (0.0 B)
							TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
					"""

			ping命令
				ping命令发送一个特殊的网络数据包(即'ICMP ECHO_REQUEST')到一台指定的主机。大多数接收这个包的网络设备将会回复它,来允许网络连接验证。
				注意:大多数网络设备(包括Linux主机)都可以被配置为忽略这些数据包,这样做是出于网络安全原因,部分地遮蔽一台主机免受一个潜在攻击者地侵袭。
					配置防火墙来阻塞IMCP流量也很普遍。
				
				例如,看看我们能否连接到网站linuxcommand.org,我们可以这样使用ping命令:
					[me@linuxbox ~]$ ping linuxcommand.org
				一旦启动,ping命令会持续在特定的时间间隔内(默认是1秒)发送数据包,直到它被中断:
					[me@linuxbox ~]$ ping linuxcommand.org
					PING linuxcommand.org (66.35.250.210) 56(84) bytes of data.
					64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=1
					ttl=43 time=107 ms
					64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=2
					ttl=43 time=108 ms
					64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=3
					ttl=43 time=106 ms
					64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=4
					ttl=43 time=106 ms
					64 bytes from vhost.sourceforge.net (66.35.250.210): icmp\_seq=5
					ttl=43 time=105 ms
					...
				按下组合键<Ctrl+C>中断这个命令之后,ping命令打印出运行统计信息。一个正常工作的网络会报告0个数据包丢失。
				一个成功执行的"ping"命令会意味着网络的各个部件(网卡,电缆,路由,网关)都处于正常的工作状态。

			traceroute命令
				traceroute命令(一些系统使用相似的tracepath程序来代替)会显示从本地到指定主机要经过的所有"跳数"的网络流量列表。
				例如,看一下到达slashdot.org需要经过的路由,我们将这样做:
					[me@linuxbox ~]$ traceroute slashdot.org
				命令输出看起来像这样:
					traceroute to slashdot.org (216.34.181.45), 30 hops max, 40 byte
					packets
					1 ipcop.localdomain (192.168.1.1) 1.066 ms 1.366 ms 1.720 ms
					2 * * *
					3 ge-4-13-ur01.rockville.md.bad.comcast.net (68.87.130.9) 14.622
					ms 14.885 ms 15.169 ms
					4 po-30-ur02.rockville.md.bad.comcast.net (68.87.129.154) 17.634
					ms 17.626 ms 17.899 ms
					5 po-60-ur03.rockville.md.bad.comcast.net (68.87.129.158) 15.992
					ms 15.983 ms 16.256 ms
					6 po-30-ar01.howardcounty.md.bad.comcast.net (68.87.136.5) 22.835
					...
				从输出结果中,我们可以看到连接测试系统到 slashdot.org 网站需要经由16个路由器。
				对于那些提供标识信息的路由器,我们能看到它们的主机名、IP地址和性能数据,这些数据包括三次从本地到此路由器的往返时间样本。
				对于那些没有提供标识信息的路由器(由于路由器配置,网络拥塞,防火墙等方面的原因),我们会看到几个星号。

			netstat命令
				netstat命令被用来检查各种各样的网络设置和统计数据。通过此命令的许多选项,我们可以看看网络设置中的各种特性。使用"-ie"选项,我们能够查看系统中的网络接口:
					[me@linuxbox ~]$ netstat -ie
					eth0    Link encap:Ethernet HWaddr 00:1d:09:9b:99:67
							inet addr:192.168.1.2 Bcast:192.168.1.255 Mask:255.255.255.0
							inet6 addr: fe80::21d:9ff:fe9b:9967/64 Scope:Link
							UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
							RX packets:238488 errors:0 dropped:0 overruns:0 frame:0
							TX packets:403217 errors:0 dropped:0 overruns:0 carrier:0
							collisions:0 txqueuelen:100 RX bytes:153098921 (146.0 MB) TX
							bytes:261035246 (248.9 MB) Memory:fdfc0000-fdfe0000

					lo      Link encap:Local Loopback
							inet addr:127.0.0.1 Mask:255.0.0.0
					...
				在上述实例中,我们看到我们的测试系统有两个网络接口:第一个叫做eth0,即以太网接口；第二个叫做lo,即内部回环网络接口(它是一个虚拟接口,系统用它来"自言自语")。
				当执行日常网络诊断时,要查看的重要信息是每个网络接口第四行开头出现的单词"UP"(说明这个网络接口已经生效),还要查看第二行中inet addr字段出现的有效IP地址。
				对于使用DHCP(动态主机配置协议)的系统,在这个字段中的一个有效IP地址则证明了DHCP工作正常。

				使用这个"-r"选项会显示内核的网络路由表。这展示了系统是如何配置网络之间发送数据包的。
					[me@linuxbox ~]$ netstat -r
					Kernel IP routing table
					Destination     Gateway     Genmask         Flags    MSS  Window  irtt Iface

					192.168.1.0     *           255.255.255.0   U        0    0          0 eth0
					default         192.168.1.1 0.0.0.0         UG       0    0          0 eth0
				在这个简单的例子里面,我们看到了位于防火墙之内的局域网中,一台客户端计算机的典型路由表。 
				第一行显示了目的地'192.168.1.0'。IP地址以0结尾是指网络,而不是独立主机,所以这个目的地意味着局域网中的任何一台主机。
				下一个字段Gateway,是网关(路由器)的名字或IP地址,用它来连接当前的主机和目的地的网络。若这个字段显示一个星号,则表明不需要网关。
				最后一行包含目的地default,指的是发往任何表上没有列出的目的地网络的流量。 
				在我们的实例中,我们看到网关被定义为地址192.168.1.1的路由器,它应该能知道怎样来处理目的地流量。

			ftp命令
				ftp命令属于真正的"经典"程序之一,它的名字来源于其所使用的协议,即文件传输协议。 
				FTP被广泛地用来从因特网上下载文件。大多数但并非所有的网络浏览器都支持FTP,你经常可以看到它们的URI以协议ftp://开头。
				在出现网络浏览器之前,ftp程序已经存在了。ftp程序可用来与FTP服务器进行通信,FTP服务器就是存储文件的计算机,这些文件能够通过网络下载和上传。
				FTP(它的原始形式)并不是安全的,因为它会以明码形式发送帐号的姓名和密码。这就意味着这些数据没有加密,任何嗅探网络的人都能看到。
				因此,几乎因特网中所有FTP服务器都是匿名的。一个匿名服务器能允许任何人使用注册名"anonymous"和无意义的密码登录系统。

				在下面的例子中,我们将展示一个典型的会话,从匿名FTP服务器(名字为fileserver)的/pub/_images/Ubuntu-8.04的目录下,使用ftp程序下载一个Ubuntu系统映像文件。
					[me@linuxbox ~]$ ftp fileserver
					Connected to fileserver.localdomain.
					220 (vsFTPd 2.0.1)
					Name (fileserver:me): anonymous
					331 Please specify the password.
					Password:
					230 Login successful.
					Remote system type is UNIX.
					Using binary mode to transfer files.
					ftp> cd pub/cd\_images/Ubuntu-8.04
					250 Directory successfully changed.
					ftp> ls
					200 PORT command successful. Consider using PASV.
					150 Here comes the directory listing.
					-rw-rw-r-- 1 500 500 733079552 Apr 25 03:53 ubuntu-8.04- desktop-i386.iso
					226 Directory send OK.
					ftp> lcd Desktop
					Local directory now /home/me/Desktop
					ftp> get ubuntu-8.04-desktop-i386.iso
					local: ubuntu-8.04-desktop-i386.iso remote: ubuntu-8.04-desktop-
					i386.iso
					200 PORT command successful. Consider using PASV.
					150 Opening BINARY mode data connection for ubuntu-8.04-desktop-
					i386.iso (733079552 bytes).
					226 File send OK.
					733079552 bytes received in 68.56 secs (10441.5 kB/s)
					ftp> bye
				这里是对会话期间所输入命令的解释说明:
					命令				 命令说明
					ftp fileserver		唤醒ftp程序,让它连接到FTP服务器'fileserver'。
					anonymous			登录名。输入登录名后会出现一个密码提示。
										一些服务器将会接受空密码,其它一些则会要求一个邮件地址形式的密码。如果是这种情况,试着输入"user@example.com"。
					cd pub/cd_images	跳转到远端系统中要下载文件所在的目录下。注意:在大多数匿名的FTP服务器中,支持公共下载的文件都能在目录pub下找到。
						/Ubuntu-8.04
					ls					列出远端系统中的目录。
					lcd Desktop			跳转到本地系统中的~/Desktop目录下。在实例中,ftp程序在工作目录~下被唤醒。这个命令把工作目录改为~/Desktop
					get ubuntu-8.04		告诉远端系统传送文件到本地。因为本地系统的工作目录已经更改到了~/Desktop,所以文件会被下载到此目录。
						-desktop-i386.iso
					bye					退出远端服务器,结束ftp程序会话。也可以使用命令 quit 和 exit。
				在"ftp>"提示符下输入"help",会显示所支持命令的列表。使用ftp登录到一台授予了用户足够权限的服务器中,则可以执行很多普通的文件管理任务。虽然很笨拙,但它真能工作。

				ftp并不是唯一的命令行形式的FTP客户端,其它比较好是lftp程序,由Alexander Lukyanov编写完成。
				虽然lftp工作起来与传统的ftp程序很相似,但是它带有额外的便捷特性,包括多协议支持(包括HTTP)、若下载失败会自动地重新下载、后台处理、用tab按键来补全路径名等等。

			wget命令
				另一个用于下载文件的命令行程序是wget。该命令不仅能从FTP网站上下载,还能从网络上下载(包括单个文件、多个文件,甚至整个网站)。
					例如,下载linuxcommand.org网站的首页, 我们可以这样做:
					[me@linuxbox ~]$ wget http://linuxcommand.org/index.php
					--11:02:51-- http://linuxcommand.org/index.php=> `index.php'
					Resolving linuxcommand.org... 66.35.250.210
					Connecting to linuxcommand.org|66.35.250.210|:80... connected.
					HTTP request sent, awaiting response... 200 OK
					Length: unspecified [text/html]
					[ <                        => ]        3,120       --.--K/s
					11:02:51 (161.75 MB/s) - 'index.php' saved [3120]

				wget [...] URL地址
					--> 从指定的'URL地址'下载文件；
						wget非常稳定,如果网络出现问题,它会不断重启下载,直到文件下载完毕；如果服务器出现问题,它也会重新连接,并从中断处恢复下载；
					--> [--spider]选项,即下载前测试'URL地址'是否有效；
						[-i 文件名]选项,即从指定的'文件'中获取URL地址；
						[-O 文件名]选项,即下载指定文件,并重命名为'文件名'(默认为URL地址最后一个'/'之后的所有字符)；
						[-c]选项,即继续(而非重新)从'URL地址'下载文件(适用于网络中断和大型文件的下载)；
						[--limit-rate=数字k]选项,即限制文件下载的速度(默认会占用全部带宽);

						[-b]选项,即将wget命令置于后台运行(适用于大型文件的下载)；
						
						[-o 日志文件名]选项,即设置记录(重写)命令执行过程的日志文件；
						[-a 日志文件名]选项,即设置记录(追加)命令执行过程的日志文件；
						[-v]选项,即显示命令的详细执行过程；
						[-nv]选项,即仅显示命令的更新和错误信息(而非详细执行过程)；
						[-q]选项,即不显示命令的执行过程；

			ssh命令
				SSH(即Secure Shell协议),避免了'明码传输'带来的潜在风险,目的机认证和通信加密等优点让其广泛用于远端登录和远程操作。
				本质上,SSH连接是在本地与远端系统间创建一条加密通道。这条通道被用来将本地系统中输入的命令安全地传输到远端系统,反过来再将执行结果安全地返回。

				SSH分为SSH1版本和SSH2版本(默认版本):
					1) SSH1没有对客户端的密钥进行校验,容易被植入恶意代码 
					2) SSH2增加了确认联机正确性的Diffe_Hellman机制；每次数据的传输,Server都会检查数据来源的正确性,以避免黑客入侵。 

				SSH由'SSH客户端'和'SSH服务端'组成:
					1) SSH客户端,即主动连接远程主机的一方,连接方式分为'口令连接'和'公钥连接'；
					   注意1:当SSH客户端发起连接后,本地的known_hosts文件(路径为'~/.ssh/known_hosts')中会写入远程主机的相关信息；
					   注意2:SSH客户端'首次连接'某台远程主机时会出现是否连接提示,如下所示:
							[me@linuxbox ~]$ ssh remote-sys
							The authenticity of host 'remote-sys (192.168.1.4)' can't be established.
							RSA key fingerprint is
							41:ed:7a:df:23:19:bf:3c:a5:17:bc:61:b3:7f:d9:bb.
							Are you sure you want to continue connecting (yes/no)?
					   		这是因为客户端程序以前从没有看到过这个远端主机。为了接受远端主机的身份验证凭据,输入"yes"。一旦建立了连接,会提示用户输入他或她的密码:
							Warning: Permanently added 'remote-sys,192.168.1.4' (RSA) to the list
							of known hosts.
							me@remote-sys's password:
					   		成功地输入密码之后,我们会接收到远端系统的shell提示符:
							Last login: Sat Aug 30 13:00:48 2008
							[me@remote-sys ~]$
					   		shell会话一直存在,直到用户输入exit命令才会关闭连接。届时,本地的shell会话恢复。
					   注意3:SSH客户端连接成功后,重定向等操作时加上''引号作用于远程主机,不加''引号可能会因展开特性而作用于本地；
					2) SSH服务端,即在远程主机上监听连接的一方,它以'sshd'守护进程的方式在远程主机上运行,监听22号端口,并借助OpenSSH(提供连接服务)和OpenSSL(提供加密服务)完成各种操作；
					3) 连接检测,即which ssh和which sshd；
				
				ssh	[...] [远程用户名@]远程主机IP地址 [命令]
					--> 使用OpenSSH软件SSH客户端进行远程连接；
					--> [-1]选项,即强制使用ssh协议版本1
						[-2]选项,即强制使用ssh协议版本2
						[-4]选项,即强制使用IPv4地址
						[-6]选项,即强制使用IPv6地址
						[-C]选项,即请求压缩所有数据
						[-b IP地址]选项,即绑定本机的IP地址(仅当本机存在多个IP地址时有效)；
						[-F 配置文件路径]选项,即为本次连接指定'配置文件',而不再使用系统级的配置文件；
						[-p 端口号]选项,即连接远程主机的指定端口；
					--> [命令],即连接后在远程主机上执行'命令'；
				
				ssh-keygen [...]
					--> 为远程连接工具生成、管理和转换'认证密钥'；
					
				ssh-copy-id [-i [密钥文件]] 远程用户名@远程主机IP地址
					--> 将本地的公钥文件'追加至'远程主机的~/.ssh/authorized_keys文件(若远程主机没有对应的目录或文件,则自动创建它们)；
						注意:若未声明[-i [...]]选项,该命令默认先看'ssh-add -L'命令是否有结果,以及结果中的公钥是否可用；
							 若'ssh-add -L'命令无结果,则指定'default_ID_file'文件(即本地系统上最新的~/.ssh/id*.pub文件)作为待追加的'公钥文件'；
					--> [-i [密钥文件]]选项,即手动指定待追加的'密钥文件'(若该'密钥文件'不是以'.pub'结尾,则自动加上'.pub')；
										   若省略'密钥文件'参数,则视作手动指定'default_ID_file'文件为待追加的'公钥文件'；
		
				SCP命令 
					scp(安全复制)命令被用于复制文件,与cp命令非常相似,区别是源或者目标路径名以'远端主机名'+':'开头。
					例如,如果我们想要从remote-sys远端系统的家目录下复制文档document.txt,到我们本地系统的当前工作目录下:
						[me@linuxbox ~]$ scp remote-sys:document.txt .
						me@remote-sys's password:
						document.txt
						100%        5581        5.5KB/s         00:00
						[me@linuxbox ~]$
					
					scp [...] 文件或目录名1 文件或目录名... 远程用户名@远程主机IP地址:目的文件或目录
						--> [-1]选项,即强制使用scp协议版本1
							[-2]选项,即强制使用scp协议版本2
							[-4]选项,即强制使用IPv4地址
							[-6]选项,即强制使用IPv6地址
							[-P 端口号]选项,即连接远程主机的指定端口；
							[-i 密钥文件名]选项,即指定本次连接使用的密钥文件；
							[-r]选项,即递归性地拷贝所有子目录(如果有的话)；
							[-p]选项,即拷贝前后,保持文件的访问日期、修改日期和文件模式不变；
							[-B]选项,即使用批处理模式传输(传输期间不询问口令)；
							[-v]选项,即显示反映整个传输过程的调试信息；
							[-F 配置文件路径]选项,即为本次连接指定'配置文件',而不再使用系统级的配置文件；		

				SFTP命令
					sftp命令是ftp命令的安全替代品。sftp与ftp很相似,但使用地是加密的SSH通道并且sftp不需要远端主机中运行FTP服务端,它仅仅需要SSH服务端。
					这意味着任何一台能用SSH客户端连接的远端机器,也可被当作FTP的服务器使用。

					sftp [...] 远程用户名@远程主机IP地址
						--> 连接远程的sftp服务器；
							连接成功后本地的shell提示符会变成'sftp>',在该环境下执行各种sftp操作；

						help
							--> 显示'sftp>'会话中可执行的命令列表；
						
						!	
							--> 中途切换至本地的shell会话,输入'exit'命令将切回至'sftp>'会话；

						!'命令'
							--> 在本地的shell会话中执行'命令'；

						exit
							--> 退出sftp；

						get [...] 远程文件名 [本地文件名]
							--> 将远程主机的'远程文件'下载至本地的'本地文件'；
							--> [-r]选项,即递归性地下载；
							--> [本地文件名],若未指定该参数,则下载至本地的'远程文件同名'文件；
						
						put [...] 本地文件名 [远程文件名]
							--> 将本地的'本地文件'上传至远程主机的'远程文件'；
							--> [-r]选项,即递归性地上传；
							--> [远程文件名],若未指定该参数,则上传至远程的'本地文件同名'文件； 
						
						...
							--> 其他命令在远程主机上执行不加'l',例如:cd 或 ls 或 mkdir 等等；
								其他命令在本地主机上执行加上'l',例如:lcd 或 lls 或 lmkdir 等等；

		11) shell的环境配置
			shell在会话中保存着大量信息,这些信息统称为shell环境。常见的环境变量如下:
				DISPLAY 	如果你正在运行图形界面环境,那么这个变量就是你显示器的名字。通常,它是":0",意思是由 X 产生的第一个显示器。
				EDITOR		文本编辑器的名字。
				SHELL		shell程序的名字。
				HOME		用户家目录。
				LANG		定义了字符集以及语言编码方式。
				OLD_PWD		先前的工作目录。
				PAGER		页输出程序的名字。这经常设置为/usr/bin/less。
				PATH		由冒号分开的目录列表,当你输入可执行程序名后,会搜索这个目录列表。
				PS1			即Prompt String 1,这个变量定义了shell提示符的格式。
				PS3			即Prompt String 3,这个变量定义了select循环提示符的内容。
				PWD			当前工作目录。
				TERM		终端类型名。类Unix的系统支持许多终端协议；这个变量设置你的终端仿真器所用的协议。
				TZ			指定你所在的时区。大多数类Unix的系统按照协调时间时 (UTC) 来维护计算机内部的时钟 ,然后应用一个由这个变量指定的偏差来显示本地时间。
				USER		你的用户名

			显示环境变量:
				set
					--> 显示所有的全局变量、局部变量、自定义变量和函数；

				env
					--> 显示所有的全局变量；

			自定义环境变量
				1) export var=value
				2) var=value
				   export var

			当我们登录系统后:
				1) 先是bash程序启动,并读取一系列配置脚本(即'启动文件',这些文件定义了所有用户共享的shell环境)。 
				2) 然后读取用户家目录中的'启动文件'(这些文件定义了该用户的shell环境)。
				
				注意:确切的启动顺序依赖于要运行的shell会话类型,是登录shell会话,还是非登录shell会话？
					登录shell会话会在其中提示用户输入用户名和密码,例如:启动虚拟控制台；
					非登录shell会话通常当我们在GUI下启动终端会话时出现。

				登录shell会读取一个或多个启动文件,例如:
					/etc/profile		应用于所有用户的全局配置脚本。
					/etc/profile.d/ 	该目录用于存放登录启动脚本。
					~/.bash_profile		用户个人的启动文件,可以用来扩展或重写全局配置脚本中的设置。
										注意:该文件会自动读取~/.bashrc文件,~/.bashrc文件又会自动读取/etc/bashrc文件。

				非登录shell会话会读取以下启动文件,例如:
					~/.bashrc			用户个人的启动文件。可以用来扩展或重写全局配置脚本中的设置。
										注意:该文件会自动读取/etc/bashrc文件(即应用于所有用户的全局配置文件)。
					
				设置登录提示
					方法一:在/etc/motd文件中添加提示内容；
					方法二:在/etc/profile.d/目录中添加提示脚本；
		
			是否曾经对shell怎样知道在哪里找到我们在命令行中输入的命令感到迷惑？
			例如,当我们输入ls后,shell不会查找整个计算机系统来找到/bin/ls(ls命令的全路径名),相反,它查找一个目录列表,这些目录包含在PATH变量中。
			PATH变量经常(但不总是,依赖于发行版)在/etc/profile启动文件中设置,通过这些代码:PATH=$PATH:$HOME/bin
			我们可以把文本附加到一个变量值的末尾。通过添加字符串$HOME/bin到PATH变量值的末尾,则目录$HOME/bin就添加到了命令搜索目录列表中。

			Shell脚本和bash启动文件都使用 "#" 符号来开始注释。其它配置文件可能使用其它的符号。大多数配置文件都有注释。把它们作为指南。
			注意:很多发行版默认地提供了这个PATH设置。一些基于Debian的发行版,例如 Ubuntu,在登录的时候会检测目录~/bin是否存在,若找到目录则把它动态地加到PATH变量中。
			'export PATH',这个export命令告诉shell让这个shell的子进程可以使用PATH变量的内容。

			既然我们知道了启动文件所在的位置和它们所包含的内容,我们就可以修改它们来定制自己的shell环境。
			按照通常的规则,添加目录到你的PATH变量或者是定义额外的环境变量,要把这些更改放置到.bash_profile文件中(或者其替代文件中,例如,Ubuntu使用.profile文件)。 
			对于其它的更改,要放到.bashrc文件中。除非你是系统管理员,需要为系统中的所有用户修改默认设置,那么则限定你只能对自己家目录下的文件进行修改。
			当然,有可能会更改/etc目录中的文件,比如说profile文件,而且在许多情况下,修改这些文件也是明智的,但要谨慎行事。

			我们对于文件.bashrc的修改不会生效,直到我们关闭终端会话,再重新启动一个新的会话,因为.bashrc文件只是在刚开始启动终端会话时读取。
			然而,我们可以强迫bash重新读取修改过的.bashrc文件,使用下面的命令:'source .bashrc'或者'. .bashrc'(因为source命令和.命令是等价的,后者是一个内建于shell自身的命令)

			shell的特殊状态变量
				?
					--> 命令执行成败、脚本exit和函数return的值,即退出状态值；
					--> echo $?

				$
					--> 执行当前脚本的进程ID；
					--> echo $$
				
				!
					--> 最近一次执行脚本的进程ID；
					--> echo $!

				_
					--> 最近一条命令的最后一个参数值；
					--> echo $_

		12) shell的提示符
			shell提示符(形如:[me@linuxbox ~]$),通常包括你的用户名@主机名,再跟上当前的工作目录,最后跟上一个'$'(如果最后一个是'#',则表示当前终端拥有超级用户权限)。
			我们默认的提示符看起来像这样:[me@linuxbox ~]$
			注意它包含我们的用户名,主机名和当前工作目录,但是它又是怎样得到这些东西的呢？结果证明非常简单。
			提示符是由一个shell变量定义的,叫做PS1(是"prompt string one" 的简写),我们可以通过echo命令来查看PS1的内容:
			[me@linuxbox ~]$ echo $PS1
			[\u@\h \W]\$
			从输出结果中,我们看到那个PS1环境变量包含一些这样的字符,比方说中括号,@符号,和美元符号,但是剩余部分就是个谜。
			我们中一些机敏的人会把这些看作是由反斜杠转义的特殊字符。以下是部分字符列表,在提示符中shell会特殊对待这些字符:
				\a	以ASCII格式编码的铃声。当遇到这个转义序列时,计算机会发出嗡嗡的响声。
				
				\d	以'星期 月 日'格式来表示当前日期。例如,"Mon May 26."
				\t	以24小时制,hours:minutes:seconds 的格式表示当前时间。
				\A	以24小时制,hours:minutes 格式表示当前时间。
				\T	以12小时制表示当前时间。
				\@	以12小时制,AM/PM 格式来表示当前时间。
				
				\u	当前用户名。
				\h	本地机的主机名,但不带末尾的域名。
				\H	完整的主机名。
				
				\l	当前终端设备名。

				\w	当前工作目录名。
				\W	当前工作目录名的最后部分。

				\$	这会显示一个"$"字符,除非你拥有超级用户权限。在那种情况下,它会显示一个"#"字符。
				
				\j	运行在当前shell会话中的工作数。
				\s	shell程序名。
				\v	shell程序的版本号。
				\V	Version and release numbers of the shell。
				\#	当前shell会话中的命令数。
				
				\n	一个换行符。
				\r	一个回车符。
				
				\!	当前命令的历史号。
				
				\[	标志着一系列一个或多个非打印字符的开始。这被用来嵌入非打印的控制字符,这些字符以某种方式来操作终端仿真器,比方说移动光标或者是更改文本颜色。
				\]	标志着非打印字符序列结束。

			大多数终端仿真器程序支持一定的非打印字符序列来控制,比方说字符属性(颜色、黑体、可怕的闪烁)和光标位置。
			字符颜色是由发送到终端仿真器的一个嵌入到了要显示的字符流中的ANSI转义编码来控制的。 
			这个控制编码不会"打印"到屏幕上,而是被终端解释为一个指令。正如我们在上表看到的字符序列,这个 [ 和 ] 序列被用来封装这些非打印字符。
			一个ANSI转义编码以一个八进制033(这个编码是由退出按键产生的)开头,其后跟着一个可选的字符属性,在之后是一个指令。
			例如:把文本颜色设为正常(attribute = 0),黑色文本的编码如下:\033[0;30m

			以下是一个可用的文本颜色列表。注意这些颜色被分为两组,由应用程序粗体字符属性(1)分化开来,这个属性可以描绘出"较浅色"文本。
			序列		 文本颜色	 序列	      文本颜色
			\033[0;30m	黑色		\033[1;30m	深灰色
			\033[0;31m	红色		\033[1;31m	浅红色
			\033[0;32m	绿色		\033[1;32m	浅绿色
			\033[0;33m	棕色		\033[1;33m	黄色
			\033[0;34m	蓝色		\033[1;34m	浅蓝色
			\033[0;35m	粉红		\033[1;35m	浅粉色
			\033[0;36m	青色		\033[1;36m	浅青色
			\033[0;37m	浅灰色		\033[1;37m	白色

			让我们试着制作一个红色提示符。我们将在开头加入转义编码:
			<me@linuxbox ~>$ PS1='\[\033[0;31m\]<\u@\h \W>\$'
			我们的提示符生效了,但是注意我们在提示符之后输入的文本也是红色的。为了修改这个问题,我们将添加另一个转义编码到这个提示符的末尾来告诉终端仿真器恢复到原来的颜色:
			<me@linuxbox ~>$ PS1='\[\033[0;31m\]<\u@\h \W>\$\[\033[0m\]'

			也有可能要设置文本的背景颜色,使用下面列出的转义编码。这个背景颜色不支持黑体属性。
			\033[0;40m	蓝色	\033[1;44m	黑色
			\033[0;41m	红色	\033[1;45m	紫色
			\033[0;42m	绿色	\033[1;46m	青色
			\033[0;43m	棕色	\033[1;47m	浅灰色

			注意:除了正常的(0)和黑体(1)字符属性之外,文本也可以具有下划线(4),闪烁(5)和反向(7)属性。为了拥有好品味,然而,许多终端仿真器拒绝使用这个闪烁属性。

			转义编码也可以用来定位光标。这些编码被普遍地用来,每次当提示符出现的时候,会在屏幕的不同位置比如说上面一个角落,显示一个时钟或者其它一些信息。
			这里是一系列用来定位光标的转义编码:
			\033[l;cH	把光标移到第 l 行,第 c 列。
			\033[nA		把光标向上移动 n 行。
			\033[nB		把光标向下移动 n 行。
			\033[nC		把光标向前移动 n 个字符。
			\033[nD		把光标向后移动 n 个字符。
			\033[2J		清空屏幕,把光标移到左上角(第零行,第零列)。
			\033[K		清空从光标位置到当前行末的内容。
			\033[s		存储当前光标位置。
			\033[u		唤醒之前存储的光标位置。

			使用上面的编码,我们将构建一个提示符,每次当这个提示符出现的时候,会在屏幕的上方画出一个包含时钟(由黄色文本渲染)的红色长条。
			构建好的提示符的编码就是这串看起来令人敬畏的字符串:
			PS1='\[\033[s\033[0;0H\033[0;41m\033[K\033[1;33m\t\033[0m\033[u\]<\u@\h \W>\$ '
			字符串说明:
			\[				开始一个非打印字符序列。其真正的目的是为了让 bash 能够正确地计算提示符的大小。如果没有这个转义字符的话,命令行编辑功能会弄错光标的位置。
			\033[s			存储光标位置。这个用来使光标能回到原来提示符的位置,当长条和时钟显示到屏幕上方之后。当心一些终端仿真器不推崇这个编码。
			\033[0;0H		把光标移到屏幕左上角,也就是第零行,第零列的位置。
			\033[0;41m		把背景设置为红色。
			\033[K			清空从当前光标位置到行末的内容。因为现在背景颜色是红色,则被清空行背景成为红色,以此来创建长条。
							注意虽然一直清空到行末,但是不改变光标位置,它仍然在屏幕左上角。
			\033[1;33m		把文本颜色设为黄色。
			\t				显示当前时间。虽然这是一个可"打印"的元素,但我们仍把它包含在提示符的非打印部分,因为我们不想 bash 在计算可见提示符的真正大小时包括这个时钟在内。
			\033[0m			关闭颜色设置。这对文本和背景都起作用。
			\033[u			恢复到之前保存过的光标位置处。
			\]				结束非打印字符序列。
			<\u@\h \W>\$	提示符字符串。

		13) shell的函数
			声明语法:
				function 函数名(){
					命令
					...
					return 退出状态
				}
				* 当声明了'function'时可省略'()',但不推荐这么做；
				* shell函数必须在调用之前先定义或加载(例如,source命令可以加载)；
				* 'return'表示退出函数并返回退出状态；
			
			调用语法:
				函数名
				函数名 参数1 参数...
				* 调用shell函数无需加上'()'；
				* '参数1...'必须都在shell函数中定义了；

		14) shell的展开
			展开(初级篇)
				字符展开
					每当你输入命令并按下enter键,shell会在执行命令之前对你'输入的字符'进行处理,这背后的的过程就叫做(字符)展开。
					通过展开,你输入的字符,在shell对它起作用之前,会被展开成其他的字符。例如:
						[me@linuxbox ~]$ echo *
						Desktop Documents ls-output.txt Music Pictures Public Templates Videos
					'*'会被展开成'当前工作目录的所有文件或子目录名'

				花括号展开
					通过它,你可以从一个包含花括号的模式中创建多个文本字符串。例如:
						[me@linuxbox ~]$ echo Front-{A,B,C}-Back
						Front-A-Back Front-B-Back Front-C-Back
					花括号展开模式可能包含一个开头部分叫做'报头',一个结尾部分叫做'附言'。
					花括号表达式本身可能包含一个由'逗号分开'的字符串列表,或者一个整数区间,或者单个的字符的区间。
					这种模式不能嵌入空白字符。例如,使用了一个整数区间:
						[me@linuxbox ~]$ echo Number_{1..5}
						Number_1  Number_2  Number_3  Number_4  Number_5
					花括号展开可以嵌套:
						[me@linuxbox ~]$ echo a{A{1,2},B{3,4}}b
						aA1b aA2b aB3b aB4b

				参数展开
					[me@linuxbox ~]$ echo $USER
					me

				命令替换
					命令替换允许我们把一个命令的输出作为一个展开模式来使用:
						[me@linuxbox ~]$ echo $(ls)
						Desktop Documents ls-output.txt Music Pictures Public Templates Videos

					这里我们把 which cp 的执行结果作为一个参数传递给 ls 命令,因此可以在不知道 cp 命令 完整路径名的情况下得到它的文件属性列表。
						[me@linuxbox ~]$ ls -l $(which cp)
						-rwxr-xr-x 1 root root 71516 2007-12-05 08:58 /bin/cp

				算术表达式展开
					算术表达式只支持整数(全部是数字,不带小数点),但是能执行很多不同的操作,其展开格式为:$((算术表达式))。
					以下是一些算术表达式支持的操作符:
						操作符	说明
						+		加
						-		减
						*		乘
						/		除(但是记住,因为展开只是支持整数除法,所以结果是整数。)
						%		取余,只是简单的意味着,"余数"
						**		取幂
					在算术表达式中,空格并不重要并且表达式可以嵌套。例如:
						# 5的平方乘以3
						[me@linuxbox ~]$ echo $(($((5**2)) * 3))
						75
					
				引用
					我们已经知道shell有许多方式可以完成展开,现在是时候学习怎样来控制展开了。
					以下面例子来说明:
						[me@linuxbox ~]$ echo this is a    test
						this is a test
					或者:
						[me@linuxbox ~]$ echo The total is $100.00
						The total is 00.00
					在第一个例子中,shell利用单词分割删除掉 echo 命令的参数列表中多余的空格。
					在第二个例子中,参数展开把 $1 的值替换为一个空字符串,因为 1 是没有定义的变量。

					shell提供了一种叫做'引用'的机制,来有选择地禁止不需要的展开。

					我们将要看一下引用的第一种类型'双引号'。
					如果你把文本放在双引号中,shell使用的特殊字符都失去它们的特殊含义,被当作普通字符来看待。有几个例外: $,\ (反斜杠),和 `(倒引号)。
					这意味着单词分割、路径名展开、波浪线展开和花括号展开都将失效,然而参数展开、算术展开和命令替换仍然执行。
					使用双引号,我们可以处理包含空格的文件名。比方说我们是不幸的名为 two words.txt 文件的受害者。
					如果我们试图在命令行中使用这个文件,单词分割机制会导致这个文件名被看作两个独自的参数,而不是所期望的单个参数:
						[me@linuxbox ~]$ ls -l two words.txt
						ls: cannot access two: No such file or directory
						ls: cannot access words.txt: No such file or directory
					记住,在双引号中,参数展开、算术表达式展开和命令替换仍然有效:
						[me@linuxbox ~]$ echo "$USER $((2+2)) $(cal)"
						me 4    February 2008
						Su Mo Tu We Th Fr Sa
						....

					在默认情况下,单词分割机制会在单词中寻找空格,制表符,和换行符,并把它们看作单词之间的界定符。
					这意味着无引用的空格,制表符和换行符都不是文本的一部分,它们只作为分隔符使用。
					由于它们把单词分为不同的参数,所以在上面的例子中,命令行包含一个带有四个不同参数的命令。如果我们加上双引号:
						[me@linuxbox ~]$ echo "this is a    test"
						this is a    test

					单词分割被禁止,内嵌的空格也不会被当作界定符,它们成为参数的一部分。一旦加上双引号,我们的命令行就包含一个带有一个参数的命令。
					事实上,单词分割机制把换行符看作界定符,对命令替换产生了一个虽然微妙但有趣的影响。考虑下面的例子:
						[me@linuxbox ~]$ echo $(cal)
						February 2008 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29
						[me@linuxbox ~]$ echo "$(cal)"
						February 2008
						
						....
					在第一个实例中,没有引用的命令替换导致命令行包含38个参数。
					在第二个例子中,命令行只有一个参数,参数中包括嵌入的空格和换行符。

					如果需要禁止所有的展开,我们要使用单引号。以下例子是无引用,双引号,和单引号的比较结果:
						[me@linuxbox ~]$ echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER
						text /home/me/ls-output.txt a b foo 4 me

						[me@linuxbox ~]$ echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"
						text ~/*.txt   {a,b} foo 4 me

						[me@linuxbox ~]$ echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'
						text ~/*.txt  {a,b} $(echo foo) $((2+2)) $USER

					有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠,在这里叫做转义字符。经常在双引号中使用转义字符,来有选择地阻止展开。
						[me@linuxbox ~]$ echo "The balance for user $USER is: \$5.00"
						The balance for user me is: $5.00
					使用转义字符来消除文件名中一个字符的特殊含义是很普遍的。
					例如,在文件名中可能使用一些对于shell来说有特殊含义的字符。这些字符包括"$", "!", " "等字符。在文件名中包含特殊字符,你可以这样做:
						[me@linuxbox ~]$ mv bad\&filename good_filename
					为了允许反斜杠字符出现,输入"\"来转义。注意在单引号中,反斜杠失去它的特殊含义,它被看作普通字符。

					反斜杠除了作为转义字符外,也可以构成一种表示法,来代表某种特殊字符,这些特殊字符叫做控制码。
					ASCII编码表中前32个字符被用来把命令转输到电报机之类的设备。一些编码是众所周知的(制表符,退格符,换行符,和回车符),而其它一些编码就不熟悉了(空值,传输结束码,和确认)。
						转义序列  含义
						\a		响铃("警告"－导致计算机嘟嘟响)
						\b		退格符
						\n		新的一行。在类 Unix 系统中,产生换行。
						\r		回车符
						\t		制表符
				
				shell提供了一个称为位置参数的变量集合,这个集合包含了命令行中所有独立的单词。
				这些变量按照从0到9给予命名。可以以这种方式讲明白:
					#!/bin/bash
					# posit-param: script to view command line vars
					echo "
					\$0 = $0
					\$1 = $1
					\$2 = $2
					\$3 = $3
					\$4 = $4
					\$5 = $5
					\$6 = $6
					\$7 = $7
					\$8 = $8
					\$9 = $9
					"
				一个非常简单的脚本,显示从$0到$9所有变量的值。当不带命令行参数执行该脚本时,输出结果如下:
					[me@linuxbox ~]$ posit-param
					$0 = /home/me/bin/posit-param
					$1 =
					$2 =
					$3 =
					$4 =
					$5 =
					$6 =
					$7 =
					$8 =
					$9 =
				即使不带命令行参数,位置参数$0总会包含命令行中出现的第一个单词,也就是已执行程序的路径名。
				当带参数执行脚本时,我们看看输出结果:
					[me@linuxbox ~]$ posit-param a b c d
					$0 = /home/me/bin/posit-param
					$1 = a
					$2 = b
					$3 = c
					$4 = d
					$5 =
					$6 =
					$7 =
					$8 =
					$9 =
				注意:
					1) 实际上通过参数展开方式你可以访问的参数个数多于9个。
					只要指定一个大于9的数字,用花括号把该数字括起来就可以。例如 ${10}、${55}、${211}等等。
					2) 另外shell还提供了一个名为$#,可以得到命令行参数个数的变量。
					3) shift命令可以依次访问每个参数,例如:
					假设某个命令中通配符*展开成了82个参数。我们如何处理那么多的参数？
					我们可以执行一次shift命令,这会导致所有的位置参数"向下移动一个位置"。
					每次shift命令执行时,变量$2的值会移动到变量$1中,变量$3的值会移动到变量$2中,依次类推。 相应地,变量$#的值也会减1。
					4) 有时候,把所有的位置参数作为一个集体来管理是很有用的。例如,我们可能想为另一个程序编写一个"包裹程序"。 
					这意味着我们会创建一个脚本或shell函数,来简化另一个程序的执行。包裹程序提供了一个神秘的命令行选项列表,然后把这个参数列表传递给下一级的程序。
					为此,shell提供了两种特殊的参数,都能扩展成完整的位置参数列表,但以相当微妙的方式略有不同。它们是:
						参数	 描述
						$*		展开成一个从1开始的位置参数列表。当它被用双引号引起来的时候,展开成一个由双引号引起来的字符串,包含了所有的位置参数,每个位置参数由shell变量IFS的第一个字符(默认为一个空格)分隔开。
						$@		展开成一个从1开始的位置参数列表。当它被用双引号引起来的时候,它把每一个位置参数展开成一个由双引号引起来的分开的字符串。

			展开(高级篇)
				最简单的参数展开形式反映在平常使用的变量上。
				$var
				当$var展开后,会变成变量var所包含的值。

				${var}
				虽然这对展开没有影响,但若该变量var与其它的文本相邻,可能会把shell搞糊涂了。
				在这个例子中,我们试图创建一个文件名,通过把字符串"_file"附加到变量var的值的后面。
					[me@linuxbox ~]$ var="foo"
					[me@linuxbox ~]$ echo "$var_file"
				如果我们执行这个序列,没有任何输出结果,因为shell会试着展开一个称为"var_file"的变量,而不是 var。通过添加花括号可以解决这个问题:
					[me@linuxbox ~]$ echo "${var}_file"
					foo_file

				我们已经知道通过把数字包裹在花括号中,可以访问大于9的位置参数。
				例如,访问第十一个位置参数,我们可以这样做:
					${11}

				几种用来处理不存在和空变量的参数展开形式。这些展开形式对于解决丢失的位置参数和给参数指定默认值的情况很方便。
				${var:-word}
					若var没有设置或者为空,展开结果是word的值。
					若var不为空,则展开结果是var的值。
						[me@linuxbox ~]$ foo=
						[me@linuxbox ~]$ echo ${foo:-"substitute value if unset"}
						if unset
						substitute value
						[me@linuxbox ~]$ echo $foo
						[me@linuxbox ~]$ foo=bar
						[me@linuxbox ~]$ echo ${foo:-"substitute value if unset"}
						bar
						[me@linuxbox ~]$ echo $foo
						bar

				${var:=word}
					若var没有设置或为空,展开结果是word的值。另外,word的值会赋值给var。 
					若var不为空,展开结果是var的值。
						[me@linuxbox ~]$ foo=
						[me@linuxbox ~]$ echo ${foo:="default value if unset"}
						default value if unset
						[me@linuxbox ~]$ echo $foo
						default value if unset
						[me@linuxbox ~]$ foo=bar
						[me@linuxbox ~]$ echo ${foo:="default value if unset"}
						bar
						[me@linuxbox ~]$ echo $foo
						bar
						注意:位置参数或其它的特殊参数不能以这种方式赋值。

				${var:?word}
					若var没有设置或为空,这种展开导致脚本带有错误退出,并且word的内容会发送到标准错误。
					若var不为空,展开结果是var的值。
						[me@linuxbox ~]$ foo=
						[me@linuxbox ~]$ echo ${foo:?"var is empty"}
						bash: foo: var is empty
						[me@linuxbox ~]$ echo $?
						1
						[me@linuxbox ~]$ foo=bar
						[me@linuxbox ~]$ echo ${foo:?"var is empty"}
						bar
						[me@linuxbox ~]$ echo $?
						0

				${var:+word}
					若var没有设置或为空,展开结果为空。
					若var不为空,展开结果是word的值会替换掉var的值；然而,var的值不会改变。
						[me@linuxbox ~]$ foo=
						[me@linuxbox ~]$ echo ${foo:+"substitute value if set"}
						[me@linuxbox ~]$ foo=bar
						[me@linuxbox ~]$ echo ${foo:+"substitute value if set"}
						substitute value if set

				shell具有返回变量名的能力。这会用在一些相当独特的情况下。
				${!prefix*}
				${!prefix@}
					这种展开会返回以prefix开头的已有变量名。根据bash文档,这两种展开形式的执行结果相同。 
					这里,我们列出了所有以BASH开头的环境变量名:
						[me@linuxbox ~]$ echo ${!BASH*}
						BASH BASH_ARGC BASH_ARGV BASH_COMMAND BASH_COMPLETION
						BASH_COMPLETION_DIR BASH_LINENO BASH_SOURCE BASH_SUBSHELL
						BASH_VERSINFO BASH_VERSION

				有大量的展开形式可用于操作字符串。其中许多展开形式尤其适用于路径名的展开。
				${#var}
					展开成由var所包含的字符串的长度。通常,var是一个字符串；然而,如果var是@或*的话,则展开结果是位置参数的个数。
						[me@linuxbox ~]$ foo="This string is long."
						[me@linuxbox ~]$ echo "'$foo' is ${#foo} characters long."
						'This string is long.' is 20 characters long.

				${var:offset}
				${var:offset:length}
					这些展开用来从var所包含的字符串中提取一部分字符。提取的字符始于第offset个字符(从字符串开头算起)直到字符串的末尾,除非指定提取的长度。
						[me@linuxbox ~]$ foo="This string is long."
						[me@linuxbox ~]$ echo ${foo:5}
						string is long.
						[me@linuxbox ~]$ echo ${foo:5:6}
						string
					若offset的值为负数,则认为offset值是从字符串的末尾开始算起,而不是从开头。
					注意:负数前面必须有一个空格,为防止与${var:-word}展开形式混淆。
					length若出现,则必须不能小于零。
					如果var是@,展开结果是length个位置参数,从第offset个位置参数开始。
						[me@linuxbox ~]$ foo="This string is long."
						[me@linuxbox ~]$ echo ${foo: -5}
						long.
						[me@linuxbox ~]$ echo ${foo: -5:2}
						lo

				${var#pattern}
				${var##pattern}
					这些展开会从paramter所包含的字符串中清除开头一部分文本,这些字符要匹配定义的pattern。
					pattern是通配符模式,就如那些用在路径名展开中的模式。
					这两种形式的差异之处是该#形式清除最短的匹配结果,而该##模式清除最长的匹配结果。
						[me@linuxbox ~]$ foo=file.txt.zip
						[me@linuxbox ~]$ echo ${foo#*.}
						txt.zip
						[me@linuxbox ~]$ echo ${foo##*.}
						zip
				
				${var%pattern}
				${var%%pattern}
					这些展开和上面的 # 和 ## 展开一样,除了它们清除的文本从 var 所包含字符串的末尾开始,而不是开头。
						[me@linuxbox ~]$ foo=file.txt.zip
						[me@linuxbox ~]$ echo ${foo%.*}
						file.txt
						[me@linuxbox ~]$ echo ${foo%%.*}
						file

				${var/pattern/string}
				${var//pattern/string}
				${var/#pattern/string}
				${var/%pattern/string}
					这种形式的展开对 var 的内容执行查找和替换操作。如果找到了匹配通配符 pattern 的文本, 则用 string 的内容替换它。在正常形式下,只有第一个匹配项会被替换掉。在该 // 形式下,所有的匹配项都会被替换掉。 该 /# 要求匹配项出现在字符串的开头,而 /% 要求匹配项出现在字符串的末尾。/string 可能会省略掉,这样会导致删除匹配的文本。
						[me@linuxbox~]$ foo=JPG.JPG
						[me@linuxbox ~]$ echo ${foo/JPG/jpg}
						jpg.JPG
						[me@linuxbox~]$ echo ${foo//JPG/jpg}
						jpg.jpg
						[me@linuxbox~]$ echo ${foo/#JPG/jpg}
						jpg.JPG
						[me@linuxbox~]$ echo ${foo/%JPG/jpg}
						JPG.jpg

				最新的bash版本已经支持字符串的大小写转换了。bash有四个参数展开和declare命令的两个选项来支持大小写转换。
					declare命令可以用来把字符串规范成大写或小写字符。
					使用declare命令,我们能强制一个变量总是包含所需的格式,无论如何赋值给它。
						#!/bin/bash
						# ul-declare: demonstrate case conversion via declare
						declare -u upper
						declare -l lower
						if [[ $1 ]]; then
							upper="$1"
							lower="$1"
							echo $upper
							echo $lower
						fi

					有四个参数展开,可以执行大小写转换操作:
						格式		 结果
						${var^^}	把var的值全部转换成大写字母。
						${var,,}	把var的值全部展开成小写字母。
						${var^}		仅仅把var的第一个字符转换成大写字母(首字母大写)。
						${var,}		仅仅把var的第一个字符转换成小写字母(首字母小写)。

				我们看过八进制(以8为底)和十六进制(以16为底)的数字。在算术表达式中,shell支持任意进制的整型常量。
					表示法			 描述
					number			默认情况下,没有任何表示法的数字被看做是十进制数(以10为底)。
					0number			在算术表达式中,以零开头的数字被认为是八进制数。
					0xnumber		十六进制表示法
					base#number		number以base为底
				一些例子:
					[me@linuxbox ~]$ echo $((0xff))
					255
					[me@linuxbox ~]$ echo $((2#11111111))
					255
				
				有两个一元运算符,+ 和 -,它们被分别用来表示一个数字是正数还是负数。例如,-5。
					运算符	 描述
					+		加
					-		减
					*		乘
					/		整除
					**		乘方
					%		取模(余数)
				其中大部分运算符是不言自明的,但是整除和取模运算符需要进一步解释一下。
				因为 shell 算术只操作整型,所以除法运算的结果总是整数:
					[me@linuxbox ~]$ echo $(( 5 / 2 ))
					2
				这使得确定除法运算的余数更为重要:
					[me@linuxbox ~]$ echo $(( 5 % 2 ))
					1
				通过使用除法和取模运算符,我们能够确定5除以2得数是2,余数是1。

				每次我们给变量一个值,我们就执行了一次赋值运算。我们也能在算术表达式中执行赋值运算:
					[me@linuxbox ~]$ foo=
					[me@linuxbox ~]$ echo $foo
					[me@linuxbox ~]$ if (( foo = 5 ));then echo "It is true."; fi
					It is true.
					[me@linuxbox ~]$ echo $foo
					5
				在上面的例子中,首先我们给变量foo赋了一个空值,然后验证foo的确为空；下一步,我们执行一个if复合命令(( foo = 5 ))。
				这个过程完成两件有意思的事情:1)它把5赋值给变量foo,2)它计算测试条件为真,因为foo的值非零。
				注意:记住上面表达式中'='符号的真正含义非常重要。
					单个'='运算符执行赋值运算。foo = 5是说"使得foo等于5",
					而'=='运算符计算等价性。foo == 5是说"是否 foo 等于5？"。
					这会让人感到非常迷惑,因为test命令接受单个'='运算符来测试字符串等价性,这也是使用更现代的[[ ]]和(( ))复合命令来代替test命令的另一个原因。
				
				除了'='运算符,shell也提供了其它一些表示法,来执行一些非常有用的赋值运算:
					表示法				 描述
					var = value			简单赋值。给 var 赋值。
					var += value		加。等价于 var = var + value。
					var -= value		减。等价于 var = var – value。
					var *= value		乘。等价于 var = var * value。
					var /= value		整除。等价于 var = var / value。
					var %= value		取模。等价于 var = var % value。
					var++				后缀自增变量。等价于 var = var + 1。
					var--				后缀自减变量。等价于 var = var - 1。
					++var				前缀自增变量。等价于 var = var + 1。
					--var				前缀自减变量。等价于 var = var - 1。
				特别关注一下自增(++)和自减(--)运算符,它们会把它们的参数值加1或减1。这种风格的表示法取自C编程语言并且被其它几种编程语言吸收,包括bash。

				位运算符是一类以不寻常的方式操作数字的运算符。这些运算符工作在位级别的数字。它们被用在某类底层的任务中,经常涉及到设置或读取位标志。
					运算符	 描述
					~		按位取反。对一个数字所有位取反。
					<<		位左移. 把一个数字的所有位向左移动。
					>>		位右移. 把一个数字的所有位向右移动。
					&		位与。对两个数字的所有位执行一个 AND 操作。
					|		位或。对两个数字的所有位执行一个 OR 操作。
					^		位异或。对两个数字的所有位执行一个异或操作。
				注意:除了按位取反(即'~')运算符之外,其它所有位运算符都有相对应的赋值运算符(例如,<<=)。

				复合命令(( ))支持各种各样的比较运算符。还有一些可以用来计算逻辑运算。这里是比较运算符的完整列表:
					运算符	 描述
					<=		小于或相等
					>=		大于或相等
					<		小于
					>		大于
					==		相等
					!=		不相等
					&&		逻辑与
					||		逻辑或
					expr1?expr2:expr3	条件(三元)运算符。若表达式 expr1 的计算结果为非零值(算术真),则 执行表达式 expr2,否则执行表达式 expr3。
				当表达式用于逻辑运算时,表达式遵循算术逻辑规则；也就是,表达式的计算结果是零,则认为假,而非零表达式认为真。


			bc语言
				我们已经看到shell是可以处理所有类型的整型算术的,但是如果我们需要执行更高级的数学运算或仅使用浮点数,该怎么办？ 
				答案是,我们不能这样做。至少不能直接用shell完成此类运算。为此,我们需要使用外部程序,有几种途径可供我们采用:
				嵌入的Perl或者AWK程序是一种可能的方案,但是不幸的是,它们超出了本书的内容大纲。 
				另一种方式就是使用一种专业的计算器程序,这样一个程序叫做bc(在大多数Linux系统中都可以找到它)。
				
				bc程序读取一个用它自己的类似于C语言的语法编写的脚本文件。一个bc脚本可能是一个分离的文件或者是从标准输入读入。
				bc语言支持相当少的功能,包括变量、循环和程序员定义的函数。让我们从一个简单的例子开始。我们将编写一个bc脚本来执行2加2运算:
					/* A very simple bc script */
					2 + 2
				脚本的第一行是一行注释。bc使用和C编程语言一样的注释语法。注释可能会跨越多行,开始于/*,结束于*/。

				如果我们把上面的bc脚本保存为foo.bc,然后我们就能这样运行它:
					[me@linuxbox ~]$ bc foo.bc
					bc 1.06.94
					Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software
					Foundation, Inc.
					This is free software with ABSOLUTELY NO WARRANTY.
					For details type `warranty'.
					4
				如果我们仔细观察,我们看到算术结果在最底部,版权信息之后。可以通过[-q(quiet)]选项禁止这些版权信息。
				bc也能够交互使用:
					[me@linuxbox ~]$ bc -q
					2 + 2
					4
					quit
				当使用bc交互模式时,我们简单地输入我们希望执行的运算,结果就立即显示出来。bc的quit命令结束交互会话。
				也可能通过标准输入把一个脚本传递给 bc 程序:
					[me@linuxbox ~]$ bc < foo.bc
					4
				这种接受标准输入的能力,意味着我们可以使用here document,here字符串和管道来传递脚本。这里是一个使用here字符串的例子:
					[me@linuxbox ~]$ bc <<< "2+2"
					4

		15) shell的分支和循环
			if分支
				if commands; then
					commands
				[elif commands; then
					commands...]
				[else
					commands]
				fi
				这里的commands是指一系列命令,如果if之后跟随一系列命令,则将计算列表中的'最后一个命令'。
				在我们弄清楚这些语句之前,我们必须看一下shell是如何评判一个命令的成功与失败的。

				退出状态
					当命令执行完毕后,命令(包括我们编写的脚本和shell函数)会给系统发送一个值(即'退出状态',这个值是一个0~255之间的整数,表示命令执行成功或是失败)。
					按照惯例,0表示成功,其它所有值表示失败。 另一方面,Shell提供了一个参数'?',我们可以用它检查'退出状态'。用具体实例看一下:
						[me@linuxbox ~]$ ls -d /usr/bin
						/usr/bin
						[me@linuxbox ~]$ echo $?
						0
						[me@linuxbox ~]$ ls -d /bin/usr
						ls: cannot access /bin/usr: No such file or directory
						[me@linuxbox ~]$ echo $?
						2
					有些命令使用不同的退出值来表示错误,大多数命令失败时会简单地退出并发送一个1。然而,0总是表示成功。

					shell提供了两个极其简单的内部命令,它们不做任何事情,除了以一个0或1退出状态来终止执行:true命令总是执行成功,而false命令总是执行失败。(True等价于true,False等价于false)

				test命令
					到目前为止,经常与if一块使用的命令是test。test命令执行各种各样的检查与比较。
					它有两种等价模式:test expression,但比较流行的格式是:[ expression ]
					这里的expression是一个表达式,必须与'['和']'之间各保留一个空格,其执行结果是true或false。换言之,整个test命令的退出状态要么为0,要么为1。
				
					常见的文件表达式:
						表达式				 如果下列条件为真则表达式返回True
						file1 -ef file2		file1 和 file2 拥有相同的索引号(通过硬链接两个文件名指向相同的文件)。
						file1 -nt file2		file1 新于 file2。
						file1 -ot file2		file1 早于 file2。
						
						-e file				file 存在。
						-s file				file 存在且其长度大于零。
						
						-f file				file 存在并且是一个普通文件。
						-d file				file 存在并且是一个目录。
						-L file				file 存在并且是一个符号链接。
						-S file				file 存在且是一个网络socket。
						-c file				file 存在并且是一个字符(设备)文件。
						-b file				file 存在并且是一个块(设备)文件。
						-t fd				fd   是一个定向到终端／从终端定向的文件描述符。这可以被用来决定是否重定向了标准输入／输出错误。

						-r file				file 存在并且可读(有效用户有可读权限)。
						-w file				file 存在并且可写(有效用户拥有可写权限)。
						-x file				file 存在并且可执行(有效用户有执行／搜索权限)。

						-O file				file 存在并且由有效用户ID拥有。
						-g file				file 存在并且设置了组ID。
						-u file				file 存在并且设置了setuid位。
						-G file				file 存在并且由有效组ID拥有。
						
						-k file				file 存在并且设置了它的"sticky bit"。
						-p file				file 存在并且是一个命名管道。
						
					常见的字符串表达式
						表达式				 	 如果下列条件为真则表达式返回True
						string					string 不为 null。
						-n string				字符串 string 的长度大于零。
						-z string				字符串 string 的长度为零。
						string1 == string2		string1 和 string2 相同。
						string1 = string2		同上,单或双等号都可以,更推荐'=='的形式。
						string1 != string2		string1 和 string2 不相同。
						string1 > string2		sting1 排列在 string2 之后。
						string1 < string2		string1 排列在 string2 之前。
						警告:当与test命令一块使用的时候,> 和 < 操作符必须用引号引起来(或者是用反斜杠转义)。否则,它们会被shell解释为重定向操作符,造成潜在的破坏结果。 
						同时,也要注意虽然bash文档声明排序遵从当前语系的排列规则,但并不这样。将来的bash版本(包含4.0),使用ASCII(POSIX)排序规则。

					常见的整数表达式
						表达式					 如果下列条件为真则表达式返回True
						integer1 -eq integer2	integer1 等于 integer2。
						integer1 -ne integer2	integer1 不等于 integer2。
						integer1 -le integer2	integer1 小于或等于 integer2。
						integer1 -lt integer2	integer1 小于 integer2。
						integer1 -ge integer2	integer1 大于或等于 integer2。
						integer1 -gt integer2	integer1 大于 integer2。

					目前的bash版本包括一个复合命令,作为加强的test命令替代物。它使用以下语法:[[ expression ]]
					类似于test命令,expression是一个表达式,必须与'[['和']]'之间各保留一个空格,其计算结果为真或假。
					这个[[ ]]命令非常相似于test命令(它支持所有的表达式),但是增加了一个重要的新的字符串表达式:string1 =~ regex,即如果string1匹配扩展的正则表达式regex,其返回值为True。

					除了[[ ]]复合命令之外,bash也提供了(( ))复合命令,其有利于操作'整数运算'或'赋值'.
					(( ))被用来执行算术真测试。如果算术计算的结果是非零值,则其测试值为真。
						[me@linuxbox ~]$ if ((1)); then echo "It is true."; fi
						It is true.
						[me@linuxbox ~]$ if ((0)); then echo "It is true."; fi
						[me@linuxbox ~]$
					注意我们使用小于和大于符号,以及==用来测试是否相等。这是使用整数较为自然的语法了。
					也要注意,因为复合命令(( ))是shell语法的一部分,而不是一个普通的命令,而且它只处理整数。所以,它能够通过名字识别出变量,而不需要执行展开操作。例如:i=8; (( i=i+2 ))

					也有可能把表达式结合起来创建更复杂的计算。通过使用逻辑操作符来结合表达式。有三个用于test命令和[[ ]]的逻辑操作。
					它们是AND、OR 和 NOT。test命令和[[ ]]使用不同的操作符来表示这些操作:
						操作符		test命令中的写法		[[ ]]和(( ))中的写法
						AND			-a					&&
						OR			-o					||
						NOT			!					!

					知道了test命令和[[ ]]基本上完成相同的事情,哪一个更好呢？
					test命令更传统(是POSIX 的一部分),然而[[ ]]特定于bash。知道怎样使用test很重要,因为它被非常广泛地应用,但是显然[[ ]]更有用,并更易于编码。

			特殊分支
				bash支持两种可以执行分支任务的控制操作符。&&(AND)和||(OR)操作符作用如同复合命令[[ ]]中的逻辑操作符。
				这是语法:
					command1 && command2
					command1 || command2
				理解这些操作很重要:
					对于 && 操作符,先执行command1,如果并且只有如果command1执行成功后,才会执行command2。
					对于 || 操作符,先执行command1,如果并且只有如果command1执行失败后,才会执行command2。

			校正输入
				从键盘输入这种新技能,带来了额外的编程挑战——校正输入。
				很多时候,一个良好编写的程序与一个拙劣程序之间的区别就是程序处理意外的能力。通常,意外会以错误输入的形式出现。
				在前面章节中的计算程序,我们已经这样做了一点儿,我们检查整数值、甄别空值和非数字字符。
				每次程序接受输入的时候,执行这类的程序检查非常重要,为的是避免无效数据。对于由多个用户共享的程序,这个尤为重要。
				如果一个程序只使用一次且只被作者用来执行一些特殊任务,那么为了经济利益而忽略这些保护措施,可能会被原谅。
				即使这样,如果程序执行危险任务,比如说删除文件,所以最好包含数据校正,以防万一。

				这里我们有一个校正各种输入的示例程序:
					#!/bin/bash
					# read-validate: validate input
					invalid_input () {
						echo "Invalid input '$REPLY'" >&2
						exit 1
					}
					read -p "Enter a single item > "
					# input is empty (invalid)
					[[ -z $REPLY ]] && invalid_input
					# input is multiple items (invalid)
					(( $(echo $REPLY | wc -w) > 1 )) && invalid_input
					# is input a valid filename?
					if [[ $REPLY =~ ^[-[:alnum:]\._]+$ ]]; then
						echo "'$REPLY' is a valid filename."
						if [[ -e $REPLY ]]; then
							echo "And file '$REPLY' exists."
						else
							echo "However, file '$REPLY' does not exist."
						fi
						# is input a floating point number?
						if [[ $REPLY =~ ^-?[[:digit:]]*\.[[:digit:]]+$ ]]; then
							echo "'$REPLY' is a floating point number."
						else
							echo "'$REPLY' is not a floating point number."
						fi
						# is input an integer?
						if [[ $REPLY =~ ^-?[[:digit:]]+$ ]]; then
							echo "'$REPLY' is an integer."
						else
							echo "'$REPLY' is not an integer."
						fi
					else
						echo "The string '$REPLY' is not a valid filename."
					fi
				这个脚本提示用户输入一个数字。随后,分析这个数字来决定它的内容。
				正如我们所看到的,这个脚本使用了许多我们已经讨论过的概念,包括shell函数,[[ ]],(( )),控制操作符&&,以及if和一些正则表达式。

			case循环
				Bash的多选复合命令称为case。它的语法规则如下所示:
					case var in
						[pattern [| pattern]...) commands ;;]
						...
					esac
				1) case命令检查一个变量值(即var),然后试图去匹配其中一个具体的模式。
				当与之相匹配的模式找到之后,就会执行与该模式相关联的命令。
				2) case命令找到一个模式之后,就不会再继续寻找。
				但如果将';;'替换为';;&',则可以多模式执行,即找到一个模式之后,仍会继续寻找。
				3) case命令使用的模式和路径展开中使用的那些是一样的,只不过是以")"作为终止符。
				4) case命令可以使用'|'操作符将'多个模式'结合起来,创建条件'或'模式。
				
				以下是一些有效模式的示例:
					模式			 模式含义
					a)				若单词为"a",则匹配
					[[:alpha:]])	若单词是一个字母字符,则匹配
					???)			若单词只有3个字符,则匹配
					*.txt)			若单词以".txt"字符结尾,则匹配
					*)				匹配任意单词。把这个模式做为case命令的最后一个模式,是一个很好的兜底做法。
									它可以捕捉到任意一个与先前模式不匹配的数值(即捕捉到任何可能的无效值)

			菜单示例
				一种常见的交互类型称为菜单驱动。在菜单驱动程序中,呈现给用户一系列选择,并要求用户选择一项。
				例如,我们可以想象一个展示以下信息的程序:
					Please Select:
					1.Display System Information
					2.Display Disk Space
					3.Display Home Space Utilization
					0.Quit
					Enter selection [0-3] >

				使用我们从编写sys_info_page程序中所学到的知识,我们能够构建一个菜单驱动程序来执行上述菜单中的任务:
					#!/bin/bash
					# read-menu: a menu driven system information program
					clear
					echo "
					Please Select:

						1. Display System Information
						2. Display Disk Space
						3. Display Home Space Utilization
						0. Quit
					"
					read -p "Enter selection [0-3] > "

					if [[ $REPLY =~ ^[0-3]$ ]]; then
						if [[ $REPLY == 0 ]]; then
							echo "Program terminated."
							exit
						fi
						if [[ $REPLY == 1 ]]; then
							echo "Hostname: $HOSTNAME"
							uptime
							exit
						fi
						if [[ $REPLY == 2 ]]; then
							df -h
							exit
						fi
						if [[ $REPLY == 3 ]]; then
							if [[ $(id -u) -eq 0 ]]; then
								echo "Home Space Utilization (All Users)"
								du -sh /home/*
							else
								echo "Home Space Utilization ($USER)"
								du -sh $HOME
							fi
							exit
						fi
					else
						echo "Invalid entry." >&2
						exit 1
					fi
				从逻辑上讲,这个脚本被分为两部分。第一部分显示菜单和用户输入。第二部分确认用户反馈,并执行选择的行动。
				注意脚本中使用的exit命令。在这里,在一个行动执行之后,exit被用来阻止脚本执行不必要的代码。 
				通常在程序中出现多个 exit 代码不是一个好主意(它使程序逻辑较难理解),但是它在这个脚本中可以使用。

			while循环
				while命令的语法是:
					while commands; do
						commands
					done
				脚本示例:
					#!/bin/bash
					# while-count: display a series of numbers
					count=1
					while [ $count -le 5 ]; do
						echo $count
						count=$((count + 1))
					done
					echo "Finished."

				和if一样,while计算一系列命令的退出状态。只要退出状态为零,它就执行循环内的命令。 
				bash 提供了两个内部命令,它们可以用来在循环内部控制程序流程:
					1) break命令立即终止一个循环,且程序继续执行循环之后的语句。 
					2) continue命令导致程序跳过循环中剩余的语句,且程序继续执行下一次循环。

			until循环
				until命令与while命令非常相似,除了当遇到一个非零退出状态的时候:while退出循环,而until不退出。一个until循环会继续执行直到它接受了一个退出状态零。

				脚本示例:
					#!/bin/bash
					# until-count: display a series of numbers
					count=1
					until [ $count -gt 5 ]; do
						echo $count
						count=$((count + 1))
					done
					echo "Finished"

			for循环
			for循环不同于while和until循环,因为在循环中,它提供了一种处理序列的方式。
			这在编程时非常有用,因此在bash脚本中,for循环是非常流行的构造,for命令语法是:
				for var [in words]; do
					commands
				done
				var是一个变量的名字,这个变量在循环执行期间会增加；
				words是一个可选条目列表,它会按顺序赋值给var；若省略,则默认为'$@'(表示从命令行接收内容)；
				commands是在每次循环迭代中要执行的命令。


			我们可以很容易的说明它是如何工作的:
				[me@linuxbox ~]$ for i in A B C D; do echo $i; done
				A
				B
				C
				D
			在这个例子中,for循环有一个四个单词的列表:"A"、"B"、"C"和 "D"。
			由于这四个单词的列表,for循环会执行四次。每次循环执行的时候,就会有一个单词赋值给变量i。
			在循环体内,我们有一个echo命令会显示i变量的值,来演示赋值结果。与while和until循环一样,done关键字会结束整个循环。
			因此,for命令真正强大的功能是我们可以通过许多有趣的方式创建words。例如,通过花括号展开:
				[me@linuxbox ~]$ for i in {A..D}; do echo $i; done
				A
				B
				C
				D
			
			科普:为什么for循环的实例大都选择i作为变量？
				这一传统的基础源于Fortran编程语言。
				在Fortran语言中,以字母I、J、K、L和M开头的未声明变量的类型自动设为整形,而以其它字母开头的变量则为实数类型(带有小数的数字)。
				这种行为导致程序员使用变量I、J和 K 作为循环变量,因为当需要一个临时变量(正如循环变量)的时候,使用它们工作量比较少。
				这也引出了如下基于Fortran的俏皮话:"神是实数,除非是声明的整数。"

			最新版本的bash已经添加了第二种格式的for命令语法,该语法相似于C语言中的for语法格式。其它许多编程语言也支持这种格式:
				for (( expression1; expression2; expression3 )); do
					commands
				done

				这里的expression1、expression2和expression3都是'算术表达式',commands是每次循环迭代时要执行的命令。在行为方面,这相当于以下构造形式:
					(( expression1 ))
					while (( expression2 )); do
						commands
						(( expression3 ))
					done
				expression1用来初始化循环条件；expression2用来决定循环结束的时间；还有在每次循环迭代的末尾会执行expression3。这里是一个典型应用:
					#!/bin/bash
					# simple_counter : demo of C style for command
					for (( i=0; i<5; i=i+1 )); do
						echo $i
					done
			
			select循环
				select循环与for循环很相似,只不过它会先顺序输出一遍带项目数字的words列表,然后显示提示符(提示符内容取决于变量PS3的值)并等待用户输入,非常适合'菜单式的交互设计'。select循环的语法如下:
					select var [in words]; do
						commands 
					done
					var是一个变量的名字,这个变量在循环执行期间会增加；
					words是一个可选条目列表,它会按顺序赋值给var；若省略,则默认为'$@'(表示从命令行接收内容)；
					commands是在每次循环迭代中要执行的命令；
					变量REPLY对应提示符后用户输入的项目数字；

		16) shell的数组
			目前我们所见到的数据类型在计算机科学圈里被称为'标量变量',即只能包含一个值的变量。
			另一种数据结构叫做数组,数组能存放多个值。数组几乎是所有编程语言的一个特性。shell也支持它们。

			数组是一次能存放多个数据的变量。数组的组织结构就像一张表。我们拿电子表格举例:
			一张电子表格就像是一个二维数组,它既有行也有列并且电子表格中的一个单元格,可以通过单元格所在的行和列的地址定位它的位置。
			数组行为也是如此。数组有单元格(即'元素'),而且每个元素会包含数据,使用一个称为索引或下标的地址可以访问一个单独的数组元素。

			Bash中的数组仅限制为单一维度。我们可以把它们看作是只有一列的电子表格。尽管有这种局限,但是有许多应用使用它们。 
			对数组的支持第一次出现在bash版本2中。原来的Unix shell程序(即sh),根本就不支持数组。

			数组变量就像其它bash变量一样命名,当被访问的时候,它们会被自动地创建。这里是一个例子:
				[me@linuxbox ~]$ a[1]=foo
				[me@linuxbox ~]$ echo ${a[1]}
				foo
			也可以用declare命令创建一个数组:
				[me@linuxbox ~]$ declare -a a
			使用[-a]选项,declare命令的这个例子创建了数组a。

			有两种方式可以给数组赋值:
				单个值赋值使用以下语法:
					name[subscript]=value

					这里的name是数组的名字；
					subscript是一个大于或等于零的整数(或算术表达式)。注意:数组第一个元素的下标是0；
					数组元素的值value可以是一个字符串或整数。

				多个值赋值使用下面的语法:
					name=(value1 value2 ...)
					name=(`命令`)
					name=($(命令))

					这里的name是数组的名字；
					value...是要按照顺序赋给数组的值,从元素0开始。
						例如,如果我们希望把星期几的英文简写赋值给数组days,我们可以这样做:
							[me@linuxbox ~]$ days=(Sun Mon Tue Wed Thu Fri Sat)
						还可以通过指定下标,把值赋给数组中的特定元素:
							[me@linuxbox ~]$ days=([0]=Sun [1]=Mon [2]=Tue [3]=Wed [4]=Thu [5]=Fri [6]=Sat)
					命令的结果会被展开赋值给数组name；
					
			下标 * 和 @ 可以被用来访问数组中的每一个元素。与位置参数一样,@表示法在两者之中更有用处。
				[me@linuxbox ~]$ for i in "${animals[*]}"; do echo $i; done
				a dog a cat a fish
				[me@linuxbox ~]$ for i in "${animals[@]}"; do echo $i; done
				a dog
				a cat
				a fish
			表示法 ${animals[*]} 和 ${animals[@]}的行为是一致的直到它们被用引号引起来。

			使用参数展开,我们能够确定数组元素的个数,与计算字符串长度的方式几乎相同。这里是一个例子:
				[me@linuxbox ~]$ a[100]=foo
				[me@linuxbox ~]$ echo ${#a[@]} # number of array elements
				1
				[me@linuxbox ~]$ echo ${#a[100]} # length of element 100
				3
			
			因为bash允许赋值的数组下标包含"间隔",有时候确定哪个元素真正存在是很有用的。为做到这一点,可以使用以下形式的参数展开:
				${!array[*]}
				${!array[@]}
			这里的array是一个数组变量的名字。和其它使用符号 * 和 @ 的展开一样,用引号引起来的 @ 格式是最有用的,因为它能展开成分离的词。
				[me@linuxbox ~]$ foo=([2]=a [4]=b [6]=c)
				[me@linuxbox ~]$ for i in "${foo[@]}"; do echo $i; done
				a
				b
				c
				[me@linuxbox ~]$ for i in "${!foo[@]}"; do echo $i; done
				2
				4
				6

			如果我们需要在数组末尾附加数据,那么知道数组中元素的个数是没用的,因为通过 * 和 @ 表示法返回的数值不能告诉我们使用的最大数组索引。
			幸运地是,shell为我们提供了一种解决方案。通过使用 += 赋值运算符,我们能够自动地把值附加到数组末尾。这里,我们把三个值赋给数组foo,然后附加另外三个。
				[me@linuxbox~]$ foo=(a b c)
				[me@linuxbox~]$ echo ${foo[@]}
				a b c
				[me@linuxbox~]$ foo+=(d e f)
				[me@linuxbox~]$ echo ${foo[@]}
				a b c d e f

			经常有必要对一列数据进行排序。shell没有这样做的直接方法,但是通过一点儿代码并不难实现。
				#!/bin/bash
				# array-sort : Sort an array
				a=(f e d c b a)
				echo "Original array: ${a[@]}"
				a_sorted=($(for i in "${a[@]}"; do echo $i; done | sort))
				echo "Sorted array: ${a_sorted[@]}"
			通过使用一个复杂的命令替换把原来的数组(a)中的内容复制到第二个数组(a_sorted)中。 
			通过修改管道线的设计,这个基本技巧可以用来对数组执行各种各样的操作。

			删除一个数组,使用 unset 命令:
				[me@linuxbox ~]$ foo=(a b c d e f)
				[me@linuxbox ~]$ echo ${foo[@]}
				a b c d e f
				[me@linuxbox ~]$ unset foo
				[me@linuxbox ~]$ echo ${foo[@]}
				[me@linuxbox ~]$
			也可以使用 unset 命令删除单个的数组元素:
				[me@linuxbox~]$ foo=(a b c d e f)
				[me@linuxbox~]$ echo ${foo[@]}
				a b c d e f
				[me@linuxbox~]$ unset 'foo[2]'
				[me@linuxbox~]$ echo ${foo[@]}
				a b d e f
			我们删除了数组中的第三个元素,下标为2。记住,数组下标开始于0而不是1。
			也要注意数组元素必须用引号引起来为的是防止shell执行路径名展开操作。

			有趣地是,给一个数组赋空值不会清空数组内容:
				[me@linuxbox ~]$ foo=(a b c d e f)
				[me@linuxbox ~]$ foo=
				[me@linuxbox ~]$ echo ${foo[@]}
				b c d e f

			任何没有下标的对数组变量的引用都指向数组元素0:
				[me@linuxbox~]$ foo=(a b c d e f)
				[me@linuxbox~]$ echo ${foo[@]}
				a b c d e f
				[me@linuxbox~]$ foo=A
				[me@linuxbox~]$ echo ${foo[@]}
				A b c d e f

			关联数组
				现在最新的bash版本支持关联数组了。关联数组使用字符串而不是整数作为数组索引。 
				这种功能给出了一种有趣的新方法来管理数据。例如,我们可以创建一个叫做"colors"的数组,并用颜色名字作为索引。
					declare -A colors
					colors["red"]="#ff0000"
					colors["green"]="#00ff00"
					colors["blue"]="#0000ff"
				不同于整数索引的数组,仅仅引用它们就能创建数组,关联数组必须用带有[-A]选项的declare命令创建。

Linux中的随机数
===============================================
	方法1
		RANDOM
			--> 环境变量RANDOM可以生成0~32767之间的随机数；
			--> echo $RANDOM
				27789
				
	
	方法2
		openssl rand -base64 随机位数
			--> openssl命令可以生成一个'指定位数'的Base64编码的字符串；
			--> openssl rand -base64 10
				b3FTCyH/oJGzCg==
	
	方法3
		date +%s%N
			--> date命令可以以'时间戳秒数'+'纳秒数'的格式显示当前时间；
				'+'与'格式字符串'之间禁止空格；
			--> date +%s%N
				1540606185948115472
	
	方法4
		head /dev/urandom | cksum
			--> 利用/dev/urandom这个(非阻塞的)随机数生成器文件,并通过cksum命令返回该文件的'校验和与字节数'；
			--> head /dev/urandom | cksum
				2732732957 1713
	
	方法5
		cat /proc/sys/kernel/random/uuid
			--> 利用/proc/sys/kernel/random/uuid这个生成uuid的文件返回UUID值；
			--> cat /proc/sys/kernel/random/uuid
				c38ac43b-11e3-4f07-9ec9-35f11a402a9c

	方法6
		mkpasswd -l 随机数长度 -d 数字数量 -c 小写字母数量 -C 大写字母数量 -s 特殊字符数量
			--> 利用expect包中的mkpasswd命令生成随机数；
			--> 前提:yum install expect
				mkpasswd -l 10 -c 3 -C 2 -d 4 -s 1
				29k4uL2;Og

	随机数的格式统一
		使用md5sum命令

编写shell脚本
===============================================
	一个shell脚本就是一个包含一系列命令的文件。shell读取这个文件,然后执行文件中的所有命令,就好像这些命令已经直接被输入到了命令行中一样。

	编写脚本流程:
		1) 编写一个脚本 
			Shell脚本,就如同普通的文本文件(通常以'.sh'结尾),可以使用vim,gedit,kate和许多其它的编辑器来编写。

		2) 赋予可执行权限
			系统会相当挑剔不允许任何旧的文本文件被看作是一个程序,并且有充分的理由,所以我们需要设置脚本文件的权限来允许其可执行。

		3) 把脚本放置到shell能够找到的地方
			当没有指定可执行文件明确的路径名时,shell会自动地搜索某些目录来查找此可执行文件。为了最大程度的方便,我们会把脚本放到这些目录当中。

	shell脚本示例:
		#!/bin/bash
		# This is our first script.
		echo 'Hello World!'

		1) 脚本的第一行
			第一行的<#!.....>是一种特殊结构,叫做'sheang',被用于告诉操作系统执行当前脚本使用的解释器。
			注意:这种结构仅出现在脚本第一行时才会生效,其他位置会被视作注释。
		
		2) 脚本中的注释
			#字符后面的所有字符都会被视作注释内容。
			通常,在规范开发时会在脚本的开头部分注释上该脚本的相关信息,例如:
				# Date: xxxx
				# Author: xxxx
				# Description: xxxx
				# Version: xxxx
			这只是良好的规范和习惯,并不强制要求。

		3) 脚本权限
			脚本文件有两个常见的权限设置；
				权限755,该脚本可以被任何人执行；
				权限700,该脚本仅可以被文件所有者执行；
				当然,前提是脚本文件必须是可读的。

		4) 执行脚本
			为了运行脚本,我们必须指明脚本文件的路径。如果我们没有,则会提示:
				[me@linuxbox ~]$ hello_world
				bash: hello_world: command not found

			如果没有给出可执行程序的明确路径,则系统每次都会搜索一系列的目录来查找该程序。更确切地说,系统会沿着环境变量PATH的值顺序查找,变量如下:
				[me@linuxbox ~]$ echo $PATH
				/home/me/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
			如果我们的脚本位于该目录列表的任意目录中,它都会被查找到。

			执行脚本时,shell会先搜集并加载'系统环境变量'(即启动文件),然后向系统'申请新的进程'从上至下、从左至右地执行脚本中的命令
			(如果执行途中开启了子shell,则会先执行完子shell,在返回父shell处继续向下执行)。
		
			执行方式
				bash 脚本名
					--> 推荐方式,通常用于'脚本文件'无可执行权限时；
				
				脚本绝对路径名
					--> 通常用于'脚本文件'未加入环境变量PATH时；

				source 脚本名
					--> 通常用于希望'脚本文件'与其父脚本共享变量时
						注意:bash和sh方式执行会开启子shell来执行脚本,而source方式是将被执行的脚本加载到当前shell,因此能够实现变量共享；
						注意:这里的'共享'特指父shell能够识别子shell中的变量,因为无论哪种执行方式子shell都能识别父shell中的变量(就像'继承'一样)；

编写shell程序
===============================================
	我们将建设一个项目。这个项目的目的是为了了解怎样使用各种各样的shell功能来创建程序,更重要的是创建好程序。

	通过创建一个名为title的变量,并把"System Information Report"字符串赋值给它,我们就可以利用参数展开功能,把这个字符串放到文件中的多个位置。
	那么,我们怎样来创建一个变量呢？很简单,我们只管使用它。当shell碰到一个变量的时候,它会自动地创建它。这不同于许多编程语言,它们中的变量在使用之前,必须显式的声明或是定义。
	关于这个问题,shell要求非常宽松,这可能会导致一些问题。例如,考虑一下在命令行中发生的这种情形:
		[me@linuxbox ~]$ foo="yes"
		[me@linuxbox ~]$ echo $foo
		yes
		[me@linuxbox ~]$ echo $fool
		[me@linuxbox ~]$
	首先我们把"yes"赋给变量foo,然后用echo命令来显示变量值。接下来,我们显示拼写错误的变量名"fool"的变量值,然后得到一个空值。
	这是因为当shell遇到fool的时候, 它很高兴地创建了变量fool并且赋给fool一个空的默认值。因此,我们必须小心谨慎地拼写！同样,理解实例中究竟发生了什么事情也很重要。

	变量
		变量的命名规则:
			1) 变量名由字母、数字和'_'字符任何组成,禁止使用空格和标点符号,且禁止以数字开头。
			2) 变量名、等号和变量值之间必须没有空格,建议使用""将变量值包裹起来。
			3) 约定俗成,常量使用全大写字母,普通变量使用小写字母(小驼峰标识)。
			4) 可以借助'空格分隔'一次性赋值多个变量,例如:a=5 b="a string"
			5) 可以借助``字符将命令或命令的结果赋值给变量,例如:var=`echo 123`,结果var=123
			6) 变量没有数据类型的区分,若需要强调类型,请使用declare命令；
				shell不在乎变量值的类型,因为shell把它们均视作字符串,赋值示例如下:
					a=z                     # Assign the string "z" to variable a.
					b="a string"            # Embedded spaces must be within quotes.
					c="a string and $b"     # Other expansions such as variables can be expanded into the assignment.
					d=$(ls -l foo.txt)      # Results of a command.
					e=$((5 * 7))            # Arithmetic expansion.
					f="\t\ta string\n"      # Escape sequences such as tabs and newlines.
					declare -r var=xxxx		# 强调var是常量
					declare -i var=num 		# 强调var是整数
		
		变量分类
			变量,可以分为'环境变量'(即全局变量)和'普通变量'(即局部变量)。
			'环境变量',可以在创建它们的shell以及任何子shell中生效、使用,又细分为'自定义的环境变量'和'bash内置的环境变量'； 
			'普通变量',可以在创建它们的shell脚本或函数中生效、使用；

vim编辑器
===============================================
	vim编辑器配置
		配置文件及路径				  	   功能描述
		/etc/vimrc						系统级的vim配置文件
		~/.vimrc						用户级的vim配置文件
		~/.viminfo 			 			用户级的vim操作历史记录文件
		/usr/share/vim/vim74/colors/	存放配色模板文件的目录

	使用vim编辑器并以'.sh'结尾保存文件,则会在文件的开头自动增加版权信息；
